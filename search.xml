<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bean 延迟查找</title>
    <url>/posts/cdfc.html</url>
    <content><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectProviderDemo</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// @Configuration 是非必须注解</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册配置类</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>ObjectProviderDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找集合对象</span>
    <span class="token function">lookupByObjectProvider</span><span class="token punctuation">(</span>annotationConfigApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lookupIfAvailable</span><span class="token punctuation">(</span>annotationConfigApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lookupByStreamOps</span><span class="token punctuation">(</span>annotationConfigApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lookupByObjectProvider</span><span class="token punctuation">(</span>
      AnnotationConfigApplicationContext annotationConfigApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectProvider<span class="token operator">&lt;</span>String<span class="token operator">></span> objectProvider <span class="token operator">=</span>
        annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanProvider</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objectProvider<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lookupIfAvailable</span><span class="token punctuation">(</span>
      AnnotationConfigApplicationContext annotationConfigApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectProvider<span class="token operator">&lt;</span>User<span class="token operator">></span> userObjectProvider <span class="token operator">=</span>
        annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanProvider</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    User user <span class="token operator">=</span> userObjectProvider<span class="token punctuation">.</span><span class="token function">getIfAvailable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"hah"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user: "</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lookupByStreamOps</span><span class="token punctuation">(</span>
      AnnotationConfigApplicationContext annotationConfigApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectProvider<span class="token operator">&lt;</span>String<span class="token operator">></span> objectProvider <span class="token operator">=</span>
        annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanProvider</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    objectProvider<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> String <span class="token function">helloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 方法名就是 Bean 名称 = "helloWorld</span>
    <span class="token keyword">return</span> <span class="token string">"hello, world!"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token annotation punctuation">@Primary</span>
  <span class="token keyword">public</span> String <span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    Message
    user: User{id=1, name='hah'}
    hello, world!
    Message */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的不足</title>
    <url>/posts/26f4.html</url>
    <content><![CDATA[<h3 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h3><p>检查异常会在编译时强制执行try catch处理，同时还需要进行某种排序处理。检查异常是一个失败的实践，几乎所有的主要API提供者都返回可检查异常。Kotlin中摒弃了检查异常。</p>
<h3 id="基本类型和数组"><a href="#基本类型和数组" class="headerlink" title="基本类型和数组"></a>基本类型和数组</h3><p>Java的这个设计保留了字节码的底层细节，违反了“凡事皆为对象”的原则，如泛型无法包容基本类型就是一个例子。这也使得Java的类型系统显得不是那么地简单统一。比较好的方案是，源代码不用直接使用基本类型和数组，由编译器（或者JVM）来决定是否可以帮你对其优化，而Kotlin正是这么做的。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态方法经常会导致需要显式的定义接口，从而使得API更加复杂。一个更好的办法就是采用单例对象，单例对象在大多数情况下表现得与静态对象差不多，但是可以像一个对象被传递。Kotlin中提供了object单例对象。</p>
<h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>在Java中我们不得不写一堆防御代码来避免令人头疼的NPE。Kotlin中引入可空类型与安全调用符、Elvis操作符等特性来实现空安全。</p>
<h3 id="一堆getter-setter单调冗长的样板代码"><a href="#一堆getter-setter单调冗长的样板代码" class="headerlink" title="一堆getter/setter单调冗长的样板代码"></a>一堆getter/setter单调冗长的样板代码</h3><p>在Kotlin中，我们可以使用数据类：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> id<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre>
<h3 id="不容易传递函数"><a href="#不容易传递函数" class="headerlink" title="不容易传递函数"></a>不容易传递函数</h3><p>Java中没有一等函数类型，函数式（FP）编程只能通过使用接口类型以及多态特性“曲线”来实现。Java会将每一个算法（方法）都放入类中，这种限制会出现这样的“荒唐事”：我们只想实现一个函数算法，而这个时候必须还要给出一个类来放置这个方法；同样，如果在其它地方调用这个方法，必须通过创建该类来实现调用。在Kotlin中直接提供了一等函数（First-Class Function Type）类型，其跟普通类型一样，函数类型可以作为值来传递，也可以作为返回值。</p>
<blockquote>
<p>不可否认的是，C、C++和Java语言都是非常优秀的编程语言。但是事物总是不断发展变化的。就像C++语言是对C语言的继承与发展，Java语言是对C++语言的继承与改造，而Kotlin语言也是对Java语言的继承与变革。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotin介绍</title>
    <url>/posts/5487.html</url>
    <content><![CDATA[<h3 id="Kotlin的主要特征"><a href="#Kotlin的主要特征" class="headerlink" title="Kotlin的主要特征"></a>Kotlin的主要特征</h3><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><p>Kotlin和Java一样是一种静态类型的编程语言。这意味着<code>所有表达式的类型在编译器已经确定了，而编译器就能验证对象是否包含了你想访问的方法或者字段</code>。</p>
<p>这与动态类型的编程语言形成了鲜明的对比，后者在JVM上的代表包括Grovvy和JRuby。这些语言<code>允许你定义可以存储任何数据类型的变量，或者返回任何数据类型的函数，并在运行时才解析方法和字段引用</code>。这会减少代码量并增加创建数据结构的灵活性。但它的缺点是，在编译期不能发现像名字拼写错误这样的问题，继而导致运行时的错误。</p>
<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>另一方面，与Java不同的是，<code>Kotin不需要你在源代码中显式地声明每个变量的类型。很多情况下，变量类型可以根据上下文来自动推断</code>，这样就可以省略类型声明。如</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token number">1</span></code></pre>
<p>在声明这个变量时，由于变量初始化整型值，Kotin自动判断出它的类型是Int。<code>编译器这种从上下文推断变量类型的能力称作类型推导</code>。</p>
<h4 id="扩展函数与扩展属性"><a href="#扩展函数与扩展属性" class="headerlink" title="扩展函数与扩展属性"></a>扩展函数与扩展属性</h4><p>扩展函数与扩展属性的“好玩”之处在于，可以在不修改原来类的条件下自定义函数和属性，是它们表现得就像是属于这个类一样。例如，我们给String类型扩展一个返回字符串首字母的firstChar()函数，代码如下：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//调用我们自定义的扩展函数</span>
    <span class="token keyword">val</span> firstChar <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token function">firstChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this first char <span class="token interpolation variable">$firstChar</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">firstChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="不可空类型与空安全"><a href="#不可空类型与空安全" class="headerlink" title="不可空类型与空安全"></a>不可空类型与空安全</h4><p>Kotlin中引入了不可空类型与可空类型来明确声明一个变量是否可能为null，同时在编译器通过类型是否匹配来检查空指针异常，大大降低了空指针异常出现的概率。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span>  <span class="token comment" spellcheck="true">//声明一个字符串，编译器会默认推断变量a的类型为不可空的String</span>
a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不可空类型不能赋值为null</span>
error<span class="token operator">:</span> Null can not be a value of a non<span class="token operator">-</span><span class="token keyword">null</span> type String

<span class="token keyword">var</span> b<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"abc"</span>
b<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">//可空类型不能直接调用方法，需要使用安全调用符?.或者断言调用!!.</span>
b<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">//使用安全调用符，null对象使用安全调用符访问length属性，直接返回null</span></code></pre>
<p>这个问号确实非常简洁易懂，同时能够时刻提醒我们：这个调用者有可能是null的。这个语言明显比Java8中引入的Optional&lt;String&gt;更加简单、直接。</p>
<h4 id="一等函数支持"><a href="#一等函数支持" class="headerlink" title="一等函数支持"></a>一等函数支持</h4><p>在Kotlin中函数是第一等类型：我们可以将函数像值一样传递，函数可以作为另一个函数的返回值。我们通常称之为“一等函数”支持。</p>
<p>下面是把一个函数作为参数传递给函数的Lambda表达式的例子：</p>
<pre class=" language-kotlin"><code class="language-kotlin"> <span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>
 <span class="token keyword">val</span> filterList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">}</span></code></pre>
<h3 id="Kotin设计哲学"><a href="#Kotin设计哲学" class="headerlink" title="Kotin设计哲学"></a>Kotin设计哲学</h3><h4 id="务实"><a href="#务实" class="headerlink" title="务实"></a>务实</h4><p>JetBrains内部和社区的开发者已经使用Kotlin的早起版本很多年，Kotlin能够帮助解决实际项目的问题。</p>
<h4 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h4><p>许多标准的Java样板代码，例如getter、setter以及将构造方法的参数赋值给字段的逻辑，在Kotlin中都是隐式的，并不会使你的源代码变得混乱。</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Kotlin设计了一个“归一化”的类型系统（一切类型皆是引用类型），纯天然地设置了一道空指针的屏障，使得Kotin比Java更加安全可靠。Kotlin有助与避免的另一种异常类型就是ClassCastException。当你把一个对象转换成一种类型，而没有事先检查它是否是正确的类型时，就会发生这个异常。Kotlin中的检查和转换被组合成了一次操作：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">is</span> String<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//不需要额外的转换就能直接引用属于这个类型的成员</span>
  <span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h4><p>Kotlin的优势是既有Java的完整生态（Kotlin完全无缝使用各类Java API框架库）,又有现代语言的高级特性（语法糖）。</p>
<h3 id="编程哲学"><a href="#编程哲学" class="headerlink" title="编程哲学"></a>编程哲学</h3><p>编程的真正问题在于，如何把人类脑子里对问题的解决方案“具化”到机器世界，而这个“具化”过程正是编程语言所要表达的东西。如何富有表现力并且安全简洁的表达，这是所有编程语言所要解决的问题。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的初始化方式</title>
    <url>/posts/c3f8.html</url>
    <content><![CDATA[<h3 id="PostConstruct标注方法"><a href="#PostConstruct标注方法" class="headerlink" title="@PostConstruct标注方法"></a>@PostConstruct标注方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：@PostConstruct Employee 初始化中... */</span></code></pre>
<h3 id="自定义初始化方法"><a href="#自定义初始化方法" class="headerlink" title="自定义初始化方法"></a>自定义初始化方法</h3><ul>
<li>XML配置：&lt;bean init-method = “init” … /&gt;</li>
</ul>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initEmployee<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre>
<ul>
<li>Java注解：@Bean(initMethod = “init”)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中... */</span></code></pre>
<ul>
<li>Java API: AbstractBeanDefinition#setInitMethodName(String)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    AbstractBeanDefinition beanDefinition <span class="token operator">=</span>
        BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setInitMethodName</span><span class="token punctuation">(</span><span class="token string">"initEmployee"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>
        <span class="token string">"myEmployee"</span><span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中... */</span></code></pre>
<h3 id="实现InitialzingBean接口的afterPropertiesSet方法"><a href="#实现InitialzingBean接口的afterPropertiesSet方法" class="headerlink" title="实现InitialzingBean接口的afterPropertiesSet方法"></a>实现InitialzingBean接口的afterPropertiesSet方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...    */</span></code></pre>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>@PostConstruct ——&gt; InitialzingBean ——&gt; 自定义初始化方法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin内联:noinline与crossinline</title>
    <url>/posts/11c5.html</url>
    <content><![CDATA[<p>在Kotlin中，内部Lambda是不允许中断外部函数执行的。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    test1<span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token label symbol">@test1</span>    <span class="token comment" spellcheck="true">//如果直接return（不带@test1）就会报错，内部Lambda是不允许中断外部函数执行的</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span>l<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
            hello 
            hello */</span></code></pre>
<p>inline的Lambda可以中断外部函数调用:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    test1<span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span>l<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果：hello */</span></code></pre>
<p>crossinline不允许inline的Lambda中断外部函数执行。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    test1 <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token label symbol">@test1</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello1"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello2"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> l<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果：
            hello
            hello2 */</span></code></pre>
<p>noinline拒绝内联。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> runnable <span class="token operator">=</span> Runnable <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runnable"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> test2 <span class="token operator">=</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> runnable<span class="token operator">::</span>run<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 如果函数返回值是一个lambda表达式的话，我需要对这个lambda表达式加上 noinline 关键字</span>
<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">test2</span><span class="token punctuation">(</span>l0<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">,</span> <span class="token keyword">noinline</span> l1<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token punctuation">{</span>
    l0<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    l1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> l1
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin单例</title>
    <url>/posts/9fbb.html</url>
    <content><![CDATA[<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Singleton <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Singleton <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Holder<span class="token punctuation">.</span>instance
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">object</span> Holder <span class="token punctuation">{</span>
        <span class="token keyword">val</span> instance <span class="token operator">=</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL修改表</title>
    <url>/posts/1e9.html</url>
    <content><![CDATA[<p>在实际的项目中，即使把表创建了出来，也需要对表经常修改。比如希望可以输入更多的字符、需要添加列、想要修改列名等情况。</p>
<h3 id="ALTER-TABLE-命令"><a href="#ALTER-TABLE-命令" class="headerlink" title="ALTER TABLE 命令"></a>ALTER TABLE 命令</h3><p>我们可以使用 ALTER TABLE 命令修改列的结构。根据需要修改的类型，可以像下面这样使用带有 MODIFY、ADD、CHANGE、DROP 的语句。</p>
<ul>
<li>当修改列的定义时：ALTER TABLE … MODIFY …</li>
<li>当添加列时：ALTER TABLE … ADD …</li>
<li>当修改列名和定义时：ALTER TABLE … CHANGE ….</li>
<li>当删除列时：ALTER TABLE … DROP …</li>
</ul>
<h3 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h3><p>任何时候都可以修改列的数据类型。例如当我们需要向设置成 VARCHAR 的列中输入大量字符时，就可以把列修改成 TEXT 类型。</p>
<p>但是，数据类型的修改必须具有兼容性。不具有兼容性的修改会导致错误发生。需要注意的是，即使数据类型可以修改，也可能发生数据类型变成没有意义的值、全部或者部分数据丢失之类的情况。如果把已经输入了 100 个字符的列修改为 VARCHAR(50)，毫无疑问，第 50 个字符之后的数据就会丢失。</p>
<p>当修改列的数据类型时，我们需要使用下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE 表名 MODIFY 列名 数据类型;</code></pre>
<p>例如把列 name 中允许的字符原本不超过 10 个，现在我们把它修改为不超过 100 个：</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 MODIFY name VARCHAR(100);</code></pre>
<p>修改后，执行下面的命令：</p>
<pre class=" language-bash"><code class="language-bash">$ DESC tb1<span class="token punctuation">;</span>
+-------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> Field <span class="token operator">|</span> Type         <span class="token operator">|</span> Null <span class="token operator">|</span> Key <span class="token operator">|</span> Default <span class="token operator">|</span> Extra <span class="token operator">|</span>
+-------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> empid <span class="token operator">|</span> varchar<span class="token punctuation">(</span>10<span class="token punctuation">)</span>  <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> name  <span class="token operator">|</span> varchar<span class="token punctuation">(</span>100<span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> age   <span class="token operator">|</span> int          <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
+-------+--------------+------+-----+---------+-------+</code></pre>
<blockquote>
<p><strong>修改数据类型要慎重</strong>    在大多数情况下，存储了 “开头不是 0 且仅由数值字符组成的数据” 的列能按照 “INT类型” —&gt; “VARCHAR类型” —&gt; “INT类型” 的方式进行修改。但是，如果列中存在数据，原则上就不应该再修改列的数据类型了。</p>
</blockquote>
<h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><p>现在员工信息表 tb1 定义了 empid、name 和 age 这 3 个列。下面试着添加能够输入员工出生日期的 DATETIME 类型的列 birth。</p>
<p>我们可以使用下面的命令将新建的列添加到最后的位置。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE 表名 ADD 列名 数据类型;</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 ADD birth DATETIME;</code></pre>
<p>修改后，执行下面的命令：</p>
<pre class=" language-bash"><code class="language-bash">$ DESC tb1<span class="token punctuation">;</span>
+-------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> Field <span class="token operator">|</span> Type         <span class="token operator">|</span> Null <span class="token operator">|</span> Key <span class="token operator">|</span> Default <span class="token operator">|</span> Extra <span class="token operator">|</span>
+-------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> empid <span class="token operator">|</span> varchar<span class="token punctuation">(</span>10<span class="token punctuation">)</span>  <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> name  <span class="token operator">|</span> varchar<span class="token punctuation">(</span>100<span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> age   <span class="token operator">|</span> int          <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> birth <span class="token operator">|</span> datetime     <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
+-------+--------------+------+-----+---------+-------+</code></pre>
<p>在输入出生日期的情况下，使用仅能输入日期的 DATE 类型就足够了。但这次我们的选择更近一步，使列 birth 中能够输入包括出生时间在内的出生日期。</p>
<h3 id="添加员工信息记录"><a href="#添加员工信息记录" class="headerlink" title="添加员工信息记录"></a>添加员工信息记录</h3><p>向表 tb1 中插入 empid 为 “N111”、name为 “松田”、age为 “27”、birth为 “1993-08-10” 的记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO tb1 VALUES('N111', '松田', 28, '1993-08-10');</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-bash"><code class="language-bash">$ SELECT * FROM tb1<span class="token punctuation">;</span>
+-------+--------+------+---------------------+
<span class="token operator">|</span> empid <span class="token operator">|</span> name   <span class="token operator">|</span> age  <span class="token operator">|</span> birth               <span class="token operator">|</span>
+-------+--------+------+---------------------+
<span class="token operator">|</span> N111  <span class="token operator">|</span> 松田   <span class="token operator">|</span>   28 <span class="token operator">|</span> 1993-08-10 00:00:00 <span class="token operator">|</span>
+-------+--------+------+---------------------+</code></pre>
<p>我们使用了需要输入日期与时间的数据类型 DATETIME，所以没有输入的时间部分被自动设置成了 “00:00:00”，即 0 时 0分 0秒。</p>
<h3 id="修改列的位置"><a href="#修改列的位置" class="headerlink" title="修改列的位置"></a>修改列的位置</h3><p>向 <code>ALTER TABLE ...ADD...</code>，新建的列会添加到表的最后面。如果在该命令的基础上加上 <code>FIRST</code>。新建的列就会添加到最前面。下面的命令用于将 DATETIME 类型的列 birth 添加到表 tb1 的最前面。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 ADD birth DATETIME FIRST;</code></pre>
<h4 id="把列添加到任意位置"><a href="#把列添加到任意位置" class="headerlink" title="把列添加到任意位置"></a>把列添加到任意位置</h4><p>使用 AFTER 能够把列添加到指定的位置。下面的命令用于将列 birth 添加到表 tb1 的列 empid 的后面。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 ADD birth DATETIME AFTER empid;</code></pre>
<h3 id="修改列的顺序"><a href="#修改列的顺序" class="headerlink" title="修改列的顺序"></a>修改列的顺序</h3><p>添加了列 birth 之后，试着修改员工信息表 tb1 的列的顺序。具体来说，就是把表 tb1 的列 birth 换到最前面的位置。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 MODIFY birth DATETIME FIRST;</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-bash"><code class="language-bash">$ DESC tb1<span class="token punctuation">;</span>
+--------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> Field  <span class="token operator">|</span> Type         <span class="token operator">|</span> Null <span class="token operator">|</span> Key <span class="token operator">|</span> Default <span class="token operator">|</span> Extra <span class="token operator">|</span>
+--------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> birth  <span class="token operator">|</span> datetime     <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> empid  <span class="token operator">|</span> varchar<span class="token punctuation">(</span>10<span class="token punctuation">)</span>  <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> name   <span class="token operator">|</span> varchar<span class="token punctuation">(</span>100<span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> age    <span class="token operator">|</span> int          <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
+--------+--------------+------+-----+---------+-------+
5 rows <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.00 sec<span class="token punctuation">)</span>
$ SELECT * FROM tb1<span class="token punctuation">;</span>
+---------------------+-------+--------+------+
<span class="token operator">|</span> birth               <span class="token operator">|</span> empid <span class="token operator">|</span> name   <span class="token operator">|</span> age  <span class="token operator">|</span>
+---------------------+-------+--------+------+
<span class="token operator">|</span> 1993-08-10 00:00:00 <span class="token operator">|</span> N111  <span class="token operator">|</span> 松田    <span class="token operator">|</span>   28 <span class="token operator">|</span>
+---------------------+-------+--------+------+
1 row <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.00 sec<span class="token punctuation">)</span></code></pre>
<h3 id="修改列名和数据类型"><a href="#修改列名和数据类型" class="headerlink" title="修改列名和数据类型"></a>修改列名和数据类型</h3><p>我们刚刚给 tb1 添加了新的记录。其中，列 birth 保存的应该是出生日期，但是却添加了时间 “00:00:00“。所以最好还是不使用 DATETIME 类型，而是使用单纯的日期类型 DATE。</p>
<h4 id="修改列的数据类型或位置的同时也修改列名"><a href="#修改列的数据类型或位置的同时也修改列名" class="headerlink" title="修改列的数据类型或位置的同时也修改列名"></a>修改列的数据类型或位置的同时也修改列名</h4><pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE 表名 CHANGE 修改前的列名 修改后的列名 修改后的数据类型</code></pre>
<p>下面试着把列 birth 的数据类型修改为 DATE，并把列名修改为 bithday。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 CHANGE birth birthday DATE;</code></pre>
<p>现在列 birthday 中仅能输入日期了，之前的 “00:00:00” 等时间数据部分被删除了。</p>
<h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><p>前面我们对表 tb1 的列 birthday 进行了各种修改，最后我们来删除出生日期相关的数据。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE 表名 DROP 列名</code></pre>
<p>删除表 tb1 的列 birthday</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 DROP birthday</code></pre>
<blockquote>
<p><strong>故意输入超过指定数量的字符</strong>    当数据类型指定为 VARCHAR(10)，如果输入了 10 个以上的字符，多于 10 个字符的部分会被省略掉。也就是说，超过指定字符数的部分被自动删除了。我们需要注意避免出现输入的数据在不知不觉中丢失的情况。</p>
</blockquote>
<h3 id="设置主键"><a href="#设置主键" class="headerlink" title="设置主键"></a>设置主键</h3><h4 id="什么是唯一"><a href="#什么是唯一" class="headerlink" title="什么是唯一"></a>什么是唯一</h4><p>创建了数据库后，就需要想办法能从大量的数据中只确定一个符合条件的记录。例如让每个员工都有一个独一无二的会员id，或者让一个商品条码对应一种价格等。</p>
<p>这种 “只会确定一个” 的独一无二的状态，称为 <strong>唯一</strong>。</p>
<h4 id="什么是主键"><a href="#什么是主键" class="headerlink" title="什么是主键"></a>什么是主键</h4><p>创建唯一的记录时，会给列设置一个用于和其它列进行区分的特殊属性。在这种情况下需要用到的就是<strong>主键（PRIMARY KEY）</strong>。主键是在多条记录中用于确定一条记录时使用的标识符。</p>
<p>为了可以严密地确定某条记录，主键需要具备以下特征：</p>
<ul>
<li>没有重复的值</li>
<li>不允许输入空值（NULL）</li>
</ul>
<p>如果在创建表的时候设置主键，就需要使用下面的命令。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE 表名 (列名    数据类型    PRIMARY KEY ...)</code></pre>
<h3 id="设置唯一键"><a href="#设置唯一键" class="headerlink" title="设置唯一键"></a>设置唯一键</h3><p>此外，我们还可以设置具有 “不允许重复” 这一限制属性的 <strong>唯一键</strong> (unique key)。</p>
<p>下面创建表 t_uniq，该表包括 INT 类型的唯一键列 a 和 VARCHAR(10) 类型的列 b。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE t_uniq (a INT UNIQUE, b VARCHAR(10))</code></pre>
<p>唯一键虽然不允许列中有重复值，但允许输入 NULL。即允许在列中输入空值但不允许重复。</p>
<h3 id="使列具有自动连续编号功能"><a href="#使列具有自动连续编号功能" class="headerlink" title="使列具有自动连续编号功能"></a>使列具有自动连续编号功能</h3><p>下面我们试着让列能够从 1 开始自动输入逐次加 1 的连续数字。</p>
<p>对于书单或者列表的序号等，我们每次都要输入数字作为列的数据，这不仅麻烦，还容易出错。所以如果能够自动输入1、2、3、4 这样的连续序号，就会方便很多。</p>
<h4 id="具有自动连续编号功能的列的定义"><a href="#具有自动连续编号功能的列的定义" class="headerlink" title="具有自动连续编号功能的列的定义"></a>具有自动连续编号功能的列的定义</h4><ul>
<li>数据类型为 INT 等整数类型</li>
</ul>
<p>具有自动连续编号功能的列必须为 INT、TINYINT、和 SMALLINT 等整数类型。既然是连续编号，自然为整数。</p>
<ul>
<li>加上 AUTO_INCREMENT</li>
</ul>
<p>要给数据类型 INT 加上关键字 <strong>AUTO_INCREMENT</strong>。它用于声明连续编号。</p>
<ul>
<li>设置 PRIMARY KEY，使列具有唯一性</li>
</ul>
<p>具有自动连续编号功能的列需要具有唯一性，我们可以设置 PRIMARY KEY 使其变成主键。</p>
<p>在使用 CREATE TABLE 命令创建表的时候，我们使用了 “a INT, b VARCHAR…” 这样的语句，AUTO_INCREMENT 和 PRIMARY_KEY 等需要记述到数据类型 INT 的后面。</p>
<p>另外，设置为 AUTO_INCREMENT 的列自然是不允许重复的（唯一的状态）。这样的列非常适合作为主键使用。</p>
<h4 id="创建具有自动连续编号功能的列"><a href="#创建具有自动连续编号功能的列" class="headerlink" title="创建具有自动连续编号功能的列"></a>创建具有自动连续编号功能的列</h4><p>我们来试着创建一个具有自动连续编号功能的表 t_series 用于练习。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE t_series(a INT AUTO_INCREMENT PRIMARY KEY, b VARCHAR(10));</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-bash"><code class="language-bash">$ DESC t_series<span class="token punctuation">;</span>
+-------+-------------+------+-----+---------+----------------+
<span class="token operator">|</span> Field <span class="token operator">|</span> Type        <span class="token operator">|</span> Null <span class="token operator">|</span> Key <span class="token operator">|</span> Default <span class="token operator">|</span> Extra          <span class="token operator">|</span>
+-------+-------------+------+-----+---------+----------------+
<span class="token operator">|</span> a     <span class="token operator">|</span> int         <span class="token operator">|</span> NO   <span class="token operator">|</span> PRI <span class="token operator">|</span> NULL    <span class="token operator">|</span> auto_increment <span class="token operator">|</span>
<span class="token operator">|</span> b     <span class="token operator">|</span> varchar<span class="token punctuation">(</span>10<span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>                <span class="token operator">|</span>
+-------+-------------+------+-----+---------+----------------+
2 rows <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.01 sec<span class="token punctuation">)</span></code></pre>
<p>在通过 DESC 命令显示的内容中，项目 Key 显示为 PRI，它表示主键 PRIMARY KEY。另外，项目 Extra 显示为 auto_increment，它表示设置了自动连续编号功能。</p>
<h3 id="设置连续编号的初始值"><a href="#设置连续编号的初始值" class="headerlink" title="设置连续编号的初始值"></a>设置连续编号的初始值</h3><p>拥有自动连续编号功能的列还可以设置任意的值。</p>
<p>例如执行：</p>
<pre class=" language-mysql"><code class="language-mysql">INSERT INTO t_series VALUES(100， '哈哈');</code></pre>
<p>列 a 中就如输入值 “100”，然后从 “101” 开始分配连续的编号，即从已经输入的最大值 +1 开始分配值。由于设置了 PRIMARY KEY 属性，所以不能输入重复的值。</p>
<p>如果想把所有的记录都删除掉，并且让编号从 1 开始输入（初始化），就需要按照下面的方式对 AUTO_INCREMENT 的值进行初始化。</p>
<pre class=" language-mysql"><code class="language-mysql"># 初始化 AUTO_INCREMENT 的值
$ ALTER TABLE 表名 AUTO_INCREMENT = 1</code></pre>
<p>当表中存在数据时，如果设置的编号值比已经存在的值大，也可能通过上面的语句重新设置编号的初始值。</p>
<p>另外，即使向拥有自动连续编号功能的列中输入 0，0 也不会输入进去。例如执行：</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO t_series VALUES(0, '夹克衫')</code></pre>
<p>编号只会根据规则连续输入进去。因此，如果总是向拥有自动连续编号功能的列中输入 0，错误发生的概率就会降低。</p>
<blockquote>
<p><strong>提示</strong>    假设表 t_series 的列 a 中已经存在的最大值为 4，这是设置 AUTO_INCREMENT=10，下一次编号的初始值就是 10（10 比已经存在的最大值 4 大，可以重新设置编号的初始值）。如果设置 AUTO_INCREMENT = 1，下一次编号的初始值就是 5（1 比已经存在的最大值 4 小，不能重新设置编号的初始值）。</p>
</blockquote>
<h3 id="设置列的默认值"><a href="#设置列的默认值" class="headerlink" title="设置列的默认值"></a>设置列的默认值</h3><p>在设置列的默认值时，需要给列加上 <strong>DEFAULT</strong> 关键字。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE 表名 （列名 数据类型 DEFAULT 默认值...）</code></pre>
<ul>
<li>修改列结构的定义</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb1 MODIFY name VARCHAR(10) DEFAULT "未输入姓名"</code></pre>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>当查找表中的数据时，如果数据量过于庞大，查找操作就会花费很多时间。在这种情况下，最好在表上创建 <strong>索引</strong>。</p>
<p>如果事先在表上创建了索引，查找时就不用对全表进行扫描，而是利用索引进行扫描。这就可以缩短查找时间。对于企业中使用的大型表来说，索引的设置会极大地影响处理速度。</p>
<h4 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h4><pre class=" language-mysql"><code class="language-mysql">$ CREATE INDEX 索引名 ON 表名(列名)</code></pre>
<p>在表 tb1 的列 empid 上创建名为 my_ind 的索引。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE INDEX my_ind ON tb1(empid)</code></pre>
<h4 id="显示索引"><a href="#显示索引" class="headerlink" title="显示索引"></a>显示索引</h4><pre class=" language-mysql"><code class="language-mysql">$ SHOW INDEX FROM 表名</code></pre>
<p>执行命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SHOW INDEX FROM tb1;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| tb1   |          1 | my_ind   |            1 | empid       | A         |           1 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</code></pre>
<p>执行结果看起来有点乱。我们可以把命令最后的 “;” 换成 “\G”（G是大写字母），纵向显示列值，这样看起来会更清晰一些。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SHOW INDEX FROM tb1 \G
*************************** 1. row ***************************
        Table: tb1
   Non_unique: 1
     Key_name: my_ind
 Seq_in_index: 1
  Column_name: empid
    Collation: A
  Cardinality: 1
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
1 row in set (0.00 sec)</code></pre>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><pre class=" language-mysql"><code class="language-mysql">$ DROP INDEX 索引名 ON 表名;</code></pre>
<p>下面是删除表 tb1 上创建的索引 my_ind 的示例。</p>
<pre class=" language-mysql"><code class="language-mysql">$ DROP INDEX my_ind ON tb1;</code></pre>
<blockquote>
<p><strong>索引与处理速度的关系</strong>    实际上，创建了索引并不代表一定会缩短查找时间。因为根据查找条件的不同，有时候不需要用到索引，而且在某些情况下，使用索引反而会花费更多的时间。</p>
<p>例如，人们都说在相同值较多（重复值较多）的情况下最好不要创建索引。我们举一个极端的例子，当某列中只有 “YES” 和 “NO” 这两个值时，即使在该列上创建索引也不会提高处理速度。</p>
<p>另外，当对创建了索引的表进行更新时，也需要对已经存在的索引信息进行维护。所以，在使用索引的情况下，检索速度可能会变快，但与此同时，更新速度也很可能会变慢。</p>
<p>在使用索引的情况下，即使索引在创建过程中出现了错误，查找结果也不会收到任何影响。创建索引只会影响数据库整体的处理速度。</p>
<p>索引的创建是影响整个数据库处理效率的重要问题。我们把这种提高处理效率的对策称为调优（tuning）。如何调优就要看数据工程师的技能了。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL字符编码设置</title>
    <url>/posts/d16b.html</url>
    <content><![CDATA[<h3 id="关于中文的设置"><a href="#关于中文的设置" class="headerlink" title="关于中文的设置"></a>关于中文的设置</h3><p>某种字符的集合称为<strong>字符集（character set）</strong>。例如中文汉字和英文字母都是字符集的一种。</p>
<p>在计算机和网络上表示字符时，需要给各个字符添加识别信息，例如数字或者符号等。给各个字符分配的数字或者符号称为<strong>字符代码（character code）</strong>。</p>
<p>给字符集分配字符代码时的规则称为<strong>字符编码（character encoding）</strong>，中文相关的主流字符编码如下所示：</p>
<table>
<thead>
<tr>
<th>字符编码名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ISO-8859-1</td>
<td>字母的字符编码（单字节编码）</td>
</tr>
<tr>
<td>GB 2312</td>
<td>1981 年 5 月 1 日发布的简体中文汉字编码国家标准</td>
</tr>
<tr>
<td>GBK</td>
<td>1995 年 12 月发布的汉字编码国际标准，是对 GB 2312 编码的补充</td>
</tr>
<tr>
<td>cp936</td>
<td>微软 Windows 环境上在 GB 2312 的基础上扩展的字符编码，通常被视为等同于 GBK</td>
</tr>
<tr>
<td>EUC-CN</td>
<td>Linux/Unix 环境上以 GB 2312 为基础的字符编码</td>
</tr>
<tr>
<td>GB 18030</td>
<td>2000 年 3 月 17 日发布的汉字编码国际标准，是对 GBK 编码的补充，兼容 GBK 和 GB 2312 字符集</td>
</tr>
<tr>
<td>UTF-8</td>
<td>针对 Unicode 字符集的一种可变长度字符编码</td>
</tr>
</tbody></table>
<p>举例来说，“啊” 字在中国国家标准 GB 2312、GBK 和 GB 18030 字符编码中的编码都为 “B0A1”，而在 UTF-8 中则为 “E5958A”。从中可以看出，即使文字相同，如果字符编码不同，表示的字符也可能不同，由此才出现了乱码现象。</p>
<p>世界上有许多语言系统和文字，所以除了上面介绍的内容之外还有无数的字符集和字符编码。但这样一来，面向全世界发布的网页等就会变得很难处理，因此人们开发了可以支持全世界所有字符的字符集 Unicode。Unicode 的字符编码方式有好几种，现在最为常用的是在 HTML 5 中被默认使用的 UTF-8。顺便说一下，在 UTF-8 的情况下，字符集和字符编码都称为 UTF-8。</p>
<h3 id="MySQL的字符编码设置"><a href="#MySQL的字符编码设置" class="headerlink" title="MySQL的字符编码设置"></a>MySQL的字符编码设置</h3><p>通过 Web 应用程序，我们可以把输入的数据存储到数据库，再从数据库读出数据显示在 Web 画面上。在 Web 的世界中默认使用的字符编码是 UTF-8，所以如果数据库的字符编码也是 UTF-8，就不需要进行字符编码的转换了。</p>
<p>因为中文 Windows 系统中命令行的默认字符编码是 GBK，所以 MySQL 监视器的输入输出字符串的字符编码也是 GBK。也就是说，存储在数据库中的字符的字符编码和客户端的输入输出中使用的字符编码并不相同。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_11-28-25.png" style="zoom:50%;">

<p>在这种情况下，当向数据库存储数据时（GBK —&gt; UTF-8），以及从数据库读取数据显示在客户端上时（UTF-8—&gt; GBK），都需要进行字符编码的转换。可以通过 修改MySQL 的设置文件（my.ini ）即可：</p>
<pre class=" language-shell"><code class="language-shell"># SQL 的安装目录下,如：C:\ProgramData\MySQL\MySQL Server 8.0\my.ini
character-set-server=utf8
default-character-set=gbk</code></pre>
<h3 id="命令提示符的UTF-8设置"><a href="#命令提示符的UTF-8设置" class="headerlink" title="命令提示符的UTF-8设置"></a>命令提示符的UTF-8设置</h3><p>Windows终端默认使用字符编码GBK进行数据的输入和输出，而数据库则使用UTF-8存储数据。其实我们也可以把命令终端的字符编码设置成UTF-8。我们需要按照下面的格式在命令终端执行<code>chcp</code></p>
<pre><code>shell</code></pre>
<p>chcp用于修改命令终端的字符编码，<code>65001代表UTF-8</code>。如果这样设置，就不需要修改 my.ini 中的内容了。</p>
<h3 id="确认MySQL中字符编码的设置情况"><a href="#确认MySQL中字符编码的设置情况" class="headerlink" title="确认MySQL中字符编码的设置情况"></a>确认MySQL中字符编码的设置情况</h3><p>启动MySQL监视器，输入status。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/one.png"></p>
<p>1代表服务器端的字符编码设置，2代表客户端的字符编码设置。</p>
<p>指定字符编码启动MySQL监视器</p>
<pre class=" language-sh"><code class="language-sh">$ mysql -uroot -proot --default-character-set=gbk</code></pre>
<p>另外字符编码设置情况还可以通过下面的命令查看</p>
<pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'char%'</code></pre>
<p>按下<code>F7键后，历史命令</code>会全部显示出来。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/posts/f499.html</url>
    <content><![CDATA[<h3 id="什么是数据类型"><a href="#什么是数据类型" class="headerlink" title="什么是数据类型"></a>什么是数据类型</h3><p>数据库的表中只能输入各个列执行格式的数据。例如，指定为 “数值类型” 的列中不能输入字符等数据。指定为 “日期类型“的列中，只能输入日期数据。这种数据的格式称为”数据类型“。</p>
<p>数据类型具有降低输入错误数据的可能行、保证数据库整体可信赖的特点。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="常用的数值型数据类型"><a href="#常用的数值型数据类型" class="headerlink" title="常用的数值型数据类型"></a>常用的数值型数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
<th>对应的范围</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>整数</td>
<td>-2 147 483 648～2 147 483 647</td>
</tr>
<tr>
<td>TINYINT</td>
<td>极小的整数</td>
<td>-128 ～ 127</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小整数</td>
<td>-32 768 - 32 767</td>
</tr>
<tr>
<td>MDEIUMINT</td>
<td>中等整数</td>
<td>-8 388 608 ～ 8 388 607</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数</td>
<td>-9 223 372 036 854 775 808 ～ -9 223 372 036 854 775 807</td>
</tr>
<tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>3.402823466E+38 ~ 1.175494351E-38, <br>0 <br>1.175494351E-38~3.402823466E+38</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>-1.7976931348623157E+308 ~ -2.2250738585072014E-308<br>0<br>2.2250738585072014E-308 to 1.7976931348623157E+308</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>精确小数</td>
<td>DECINAL(最大位数，小数点之后的位数) 的格式中的 “最大位数” 可以指定不大于 65 的值，“小数点之后的位数” 可以指定不大于 30 的值，不会产生误差。</td>
</tr>
</tbody></table>
<h4 id="输入数值数据"><a href="#输入数值数据" class="headerlink" title="输入数值数据"></a>输入数值数据</h4><p>数值也可以使用指数表示法输入。例如，“6.02E+23” 表示 <code>6.02 乘以 10 的 23 次方</code>。</p>
<p>举例来说，当向表 tb1A 的 INT 类型的列 age 中输入 10000 时，如果使用指数格式，就是下面这种形式：</p>
<pre class=" language-mysql"><code class="language-mysql">INSERT INTO tb1A (age) VALUES(1E+4);</code></pre>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="常用的字符串数据类型"><a href="#常用的字符串数据类型" class="headerlink" title="常用的字符串数据类型"></a>常用的字符串数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
<th>对应的范围</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>固定长度字符串</td>
<td>长度不超过 255 个字符</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>可变长度字符串</td>
<td>1 ～ 65532 字节。字符数的上限取决于使用的字符编码</td>
</tr>
<tr>
<td>TEXT</td>
<td>长文本字符串</td>
<td>长度不超过 65 535 个字符</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>极长的文本字符串</td>
<td>长度不超过 4 294 967 295 个字符</td>
</tr>
</tbody></table>
<p>一般情况下，长度不超过 255 个字符的用 VARCHAR ，超过 255 个字符的用 TEXT 就足够了。</p>
<p>CHAR 类型为固定长度的字符串，在保存数据的时候，字符数如果没有达到（）中指定的数量就会用空格填充。但是，读取时这些填充的空格会被自动删除。而 VARCHAR 为可变长度字符串，保存数据时不会填充空格。</p>
<h4 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h4><p>字符串数据需要用双引号<code>"</code>或者单引号<code>'</code> 括起来。如果输入的字符串数据中包含 <code>'</code>，那么 <code>'</code>之后出现的 <code>'</code> 就会被解释为表示字符串结束的<code>'</code>。</p>
<p>所以当把 <code>' '</code> 当成字符输入时，要在它的前面加上 “\”，该操作称为<strong>转义处理（escape processing）</strong>。</p>
<p>下面是向表 tb1B 的列 name 中输入带单引号 <code>'西泽'</code> 的例子</p>
<pre class=" language-mysql"><code class="language-mysql">INSERT INTO tb1B (name) VALUES ('\'西泽\'');</code></pre>
<p>同样，当输入 “\” 时，也需要在前面加上 “\”，输入 “\”。</p>
<h4 id="VARCHAR-和-CHAR-的位数单位"><a href="#VARCHAR-和-CHAR-的位数单位" class="headerlink" title="VARCHAR 和 CHAR 的位数单位"></a>VARCHAR 和 CHAR 的位数单位</h4><p>在 MySQL 4.1 以后的版本中，VARCHAR 和 CHAR 的 () 中指定的位数单位变成了 “字符”。以 VARCHAR(10) 为例，不管输入的是中文还是半角英文字母和数字，最多都只能保存10 个字符。</p>
<h3 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h3><h4 id="常用的日期与时间数据类型"><a href="#常用的日期与时间数据类型" class="headerlink" title="常用的日期与时间数据类型"></a>常用的日期与时间数据类型</h4><p>能够保存日期或时间的列的数据类型包括 DATE（日期）、TIME（时间）、YEAR（年），以及把日期和时间组合在一起的 DATETIME 等。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
<th>对应的范围</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>日期和时间</td>
<td>1000-01-01 00:00:00 ～ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>日期</td>
<td>1000-01-01 ～ 9999-12-31</td>
</tr>
<tr>
<td>YEAR</td>
<td>年</td>
<td>1901 ～2155（4 位时）<br>1970 ～ 2069（70 ～ 69）（2 位时）</td>
</tr>
<tr>
<td>TIME</td>
<td>时间</td>
<td>-838:59:59 ～ 838:59:59</td>
</tr>
</tbody></table>
<h4 id="输入日期与时间类型的数据"><a href="#输入日期与时间类型的数据" class="headerlink" title="输入日期与时间类型的数据"></a>输入日期与时间类型的数据</h4><p>日期与时间类型的数据需要使用单引号 <code>'</code> 或者 双引号 <code>"</code> 括起来。在 MySQL 中，日期必须以 YYYY-MM-DD 的格式输入，时间必须以 HH:MM:SS 的格式输入（高版本的 MySQL 没有此限制）。</p>
<h3 id="修改提示符的字符串"><a href="#修改提示符的字符串" class="headerlink" title="修改提示符的字符串"></a>修改提示符的字符串</h3><p>在 MySQL 监视器运行的时候，我们能够在提示符 “&gt;” 中执行显示自己想显示的内容。</p>
<p>当 MySQL 监视器启动时，我们可以指定 “–promat = 提示符的内容” 选项设置提示符，但如果设置的提示符中包含中文就会发生乱码（在 Windows 的情况下）。当发生这种情况时，我们可以在 MySQL 监视器启动后使用 prompt 命令修改提示符的内容。</p>
<ul>
<li>设置作为提示符显示的文本</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ prompt 作为提示符显示的文本</code></pre>
<p>设置 MySQL 监视器提示符的显示内容为 “当前数据库名：主机名&gt;”</p>
<pre class=" language-bash"><code class="language-bash">$ prompt \d:\h<span class="token operator">></span>
PROMPT <span class="token keyword">set</span> to <span class="token string">'\d:\h>'</span>
$ db1:localhost<span class="token operator">></span></code></pre>
<ul>
<li>回到初期状态</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ prompt mysql<span class="token operator">></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL权限相关</title>
    <url>/posts/8cf.html</url>
    <content><![CDATA[<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class=" language-mysql"><code class="language-mysql">$ SET PASSWORD FOR root@localhost='A123456!'</code></pre>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre class=" language-mysql"><code class="language-mysql"># CREATE USER 新用户名 IDENTIFIED BY '密码'
$ CREATE USER asiama@localhost IDENTIFIED BY 'A123456!'</code></pre>
<h3 id="设置用户权限"><a href="#设置用户权限" class="headerlink" title="设置用户权限"></a>设置用户权限</h3><pre class=" language-mysql"><code class="language-mysql"># GRANT 赋予的权限 ON 数据库名.表名 TO 用户名
$ GRANT ALL ON db1.* TO asiama@localhost</code></pre>
<blockquote>
<p><strong>注意</strong>    用户名需要按照“用户名@主机名”的方式书写（如果不确定主机名，可以”用户名@%”来允许所有主机）。“赋予的权限”如果是所有的权限，就设置为“ALL”；如果仅允许SELECT和UPDATE,就设置为“SELECT, UPDATE”；如果是所有的数据库的所有表，就设置为“*.*”</p>
</blockquote>
<h3 id="安全地输入密码"><a href="#安全地输入密码" class="headerlink" title="安全地输入密码"></a>安全地输入密码</h3><pre class=" language-bash"><code class="language-bash">$ mysql -uroot -p</code></pre>
<p>在这里输入 “root” 之类的密码，就可以像前面一样启动 MySQL 监视器了。该方法可以避免通过命令历史盗取密码。</p>
<blockquote>
<p><strong>MySQL 命令的选项</strong>    在启动 MySQL 监视器的时候，我们输入了 <code>mysql -u root -proot</code>，这个命令其实就是在 mysql 命令的基础上添加了 -u 和 -p 两个选项。给 mysql  命令设置选项的方法主要有以下两种：</p>
<ol>
<li>给 “-” 指定选项名，然后加上设置的值。例如：-u root（在这种情况下，选项名只占 1 个字符）</li>
<li>在 “–选项名=” 后加上设置的值。例如：<code>mysql --user=root --password=root --default-character-set=gbk</code></li>
</ol>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的概要</title>
    <url>/posts/1a43.html</url>
    <content><![CDATA[<h3 id="数据库的概要"><a href="#数据库的概要" class="headerlink" title="数据库的概要"></a>数据库的概要</h3><h4 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h4><p>MySQL 是世界上最受欢迎的开源数据库软件。那么，我们常常听到的数据库到底是什么呢？</p>
<p>据说，第二次世界大战后，美军为了有效管理大量的资料，便把所有的信息都集中在一个基地里，这个集中了所有信息的基地就称为数据库（databse）。“数据库” 一次便由此诞生。</p>
<p>现在，数据库表示 <strong>“具有某种数据规则的集合”</strong>。但提到数据库时，我们一般都默认它<strong>具备对数据进行添加、查询和提取等用于管理数据</strong>的功能。所以，只是随便收集起来的数据的集合不能称为数据库。只有具备了有效运用这些数据的管理功能，才能称为数据库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_11-15-05.png"></p>
<h4 id="关系数据库是什么"><a href="#关系数据库是什么" class="headerlink" title="关系数据库是什么"></a>关系数据库是什么</h4><p>现在使用最广泛的是<strong>关系数据库</strong> （Relational Database，RDB）。</p>
<p>在关系数据库中，一条数据用多个项目来表示。例如，关系数据库将一条会员数据分成会员编号、姓名、住址和出生年月日等项目，然后把各个会员的相关数据收集起来。</p>
<p>其中，一条数据称为<strong>记录（record）</strong>，各个项目称为<strong>列</strong>（column）。在刚才的例子中，xx 先生 或者 xx小姐的数据是记录，会员编号和姓名等项目是列。</p>
<p>如果想象成 Excel 的工作表（work sheet），横向的一行就相当于记录。注意，纵向的一列中输入的是相同类型的数据。</p>
<p>我们把收集了这些数据的表格称为<strong>表</strong>（table）。一个数据库中可以包含多个表。</p>
<p>管理关系数据库的系统称为 <strong>RDBMS（Relational DataBase Management System）</strong>，关系数据库系统。MySQL 也是 RDBMS 的一种。</p>
<p>在关系数据库中，不用把所有的项目都存入一个表里。我们可以把各个项目拆到多个 “具有关联性” 表中，只对需要用到的数据进行收集和使用。</p>
<h4 id="数据库的特征"><a href="#数据库的特征" class="headerlink" title="数据库的特征"></a>数据库的特征</h4><p>如果是 Excel 的工作表，在任何单元格中都可以自由地输入字符串或数值，而且还可以通过拖拽鼠标来自由地挪动数据。但是在数据库中，上面的做法是行不通的。如果最开始决定 “在列 a 中输入整数” ，之后在列 a 中就只能输入整数，不能再输入字符串。</p>
<p>另外，很多应用程序都有<code>还原（UNDO）</code>功能，如果操作结果不理想，可以使用该功能进行还原。但是在数据库中，如果不使用<strong>事务（t ransaction）</strong>等特殊功能，就无法还原到上一步操作。</p>
<p>大家也许一开始会讨厌数据库这种 “缺乏灵活性” 的特性。但是多亏了这一特性，数据库才变得安全且稳定，才成了可靠的数据存储场所。“只能按照决定好的规则来操作，并且严格地进行管理” 的特征，正是数据库值得信赖的原因。</p>
<h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><h4 id="主流数据库"><a href="#主流数据库" class="headerlink" title="主流数据库"></a>主流数据库</h4><table>
<thead>
<tr>
<th>名称</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>Oracle</td>
<td>世界上最常用的商用 RDBMS</td>
</tr>
<tr>
<td>Access</td>
<td>微软公司 Office 系列的 RDBMS</td>
</tr>
<tr>
<td>Microsoft SQL Server</td>
<td>微软公司的商用RDBMS</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>和 MySQL 一样是开源的 RDBMS，在日本很受欢迎</td>
</tr>
<tr>
<td>MySQL</td>
<td>世界上最常用的 RDBMS</td>
</tr>
</tbody></table>
<h4 id="MySQL历史"><a href="#MySQL历史" class="headerlink" title="MySQL历史"></a>MySQL历史</h4><p>MySQL 是米卡埃尔·维徳纽斯（Michael Widenius） 在 1995 年开发的 RDBMS。最初，MySQL  是由瑞典的 MySQL AB 公司进行支持和开发的。维德妞斯正是这家公司的前身公司创始人。但是在 2008 年 2 月，MySQL AB 公司被 Sun 公司收购。而拥有被认为是世界第一的商用数据库 Oracle 的 Oracle 公司又与 2010年 1 月收购了 Sun 公司。也就是说，作为开源数据库世界第一的 MySQL 和作为商用数据库世界第一的 Oracle，现在都在由同一家公司管理。</p>
<p>另外，维德妞斯原供职于 Sun 公司，但是他在 Oracle 公司收购 Sun 公司前从 Sun 公司离职，并与 2010 年创建了 MariaDB 公司，开始开发和 MySQL 具有兼容性的 MariaDB 数据库。MySQL 源与维德妞斯大女儿的名字 “My”，而 MariaDB 则源自与维德妞斯二女儿的名字“Maria”。</p>
<p>MariaDB 最初发布的版本只是增强了 MySQL 的部分功能，但是从 2014 年 3 月发布的 10.0 版本起，MariaDB 开始有了自己专有的功能，逐渐和 MySQL 区分开来。</p>
<h4 id="MySQL-的两种版本"><a href="#MySQL-的两种版本" class="headerlink" title="MySQL 的两种版本"></a>MySQL 的两种版本</h4><ul>
<li>MySQL 社区版<ul>
<li>可免费使用</li>
<li>有参考手册（reference manual）</li>
<li>有论坛和邮件列表，但没有技术支持</li>
</ul>
</li>
<li>MySQL 商业版<ul>
<li>需要付费</li>
<li>定期更新，并且提供服务包（service pack）及技术支持</li>
<li>拥有以下多个版本：MySQL 标准版（Standard Edition），MySQL 企业版（Enterprise Edition），MySQL 集群运营商级版（Cluster Carrier Grade Edition）</li>
</ul>
</li>
</ul>
<h4 id="MySQL-特征"><a href="#MySQL-特征" class="headerlink" title="MySQL 特征"></a>MySQL 特征</h4><ol>
<li>执行速度快</li>
<li>开放源代码</li>
<li>支持在多种操作系统上运行</li>
<li>支持多种编程语言</li>
<li>拥有免费和付费两种版本</li>
</ol>
<p>MySQL 的执行速度非常快，这种轻快性正是它的卖点。早期的版本为了维持这种轻快性，曾削减事物、子查询和存储过程等功能，所以给人一种 ”执行速度快、但功能太简单“ 的感觉。不过，现在 MySQL 在功能方面已经不逊色于其它 RDBMS 了。</p>
<p>MySQL 新功能的添加历史</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>添加该功能时的MySQL版本</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>4.0（从版本3.23.38开始可以使用该功能）</td>
</tr>
<tr>
<td>合并</td>
<td>4.0</td>
</tr>
<tr>
<td>子查询</td>
<td>4.1</td>
</tr>
<tr>
<td>视图</td>
<td>5.0</td>
</tr>
<tr>
<td>存储过程</td>
<td>5.0</td>
</tr>
<tr>
<td>存储函数</td>
<td>5.0</td>
</tr>
<tr>
<td>触发器</td>
<td>5.0</td>
</tr>
<tr>
<td>默认存储引擎变为InnoDB</td>
<td>5.5</td>
</tr>
<tr>
<td>半同步复制</td>
<td>5.5</td>
</tr>
<tr>
<td>无损半同步复制</td>
<td>5.7</td>
</tr>
</tbody></table>
<h3 id="SQL的概要"><a href="#SQL的概要" class="headerlink" title="SQL的概要"></a>SQL的概要</h3><h4 id="查询和SQL"><a href="#查询和SQL" class="headerlink" title="查询和SQL"></a>查询和SQL</h4><p>在操作数据库的时候，作为用户的我们会向数据库发出命令（command），并指定需要处理的内容。表示这种命令的语句就是查询（query）。例如，创建表时使用的查询时 “CREATE TABLE…”，插入数据库时使用的查询是 “INSERT INTO …”。</p>
<p>编写查询需要遵守 <strong>SQL（Structured Query Language）</strong> 的规则。SQL 直译过来就是结构化查询语言，用于对数据库进行操作。</p>
<p>我们来看一个例子。假设你在政府办公室等地方进行咨询，在向政府办公室窗口的负责人提出 “想请 XX 部门帮忙提供 XX 证明” 的申请后，就能得到需要的文件了。如果把申请对象换成数据库，申请手续就是 SQL。SQL是数据库的窗口，充当用户与数据库交互的媒介。</p>
<h4 id="SQL的”方言“"><a href="#SQL的”方言“" class="headerlink" title="SQL的”方言“"></a>SQL的”方言“</h4><p>SQL原本是IBM公司开发的语言，但现在这门语言基本可以在所有的数据库上使用。不过麻烦的是，各个数据库使用的SQL语法稍有不同。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis小热身</title>
    <url>/posts/4f87.html</url>
    <content><![CDATA[<h3 id="redis-server-配置"><a href="#redis-server-配置" class="headerlink" title="redis-server 配置"></a>redis-server 配置</h3><p>Redis 支持通过配置文件来设置启动参数，如：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-server /path/to/redis.conf</code></pre>
<p>通过启动参数传递同名的配置选项会覆盖配置文件中相应的参数，就像这样：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-server /path/to/redis.conf --loglevel warning</code></pre>
<p>Redis 运行时通过 CONFIG SET 命令在不重新启动 Redis 的情况下动态修改部分 Redid配置：</p>
<pre class=" language-bash"><code class="language-bash">$ CONFIG SET loglevel warning
OK</code></pre>
<p>并不是所有配置都可以使用Config SET 命令修改。同样在运行的时候也可以使用 CONFIG GET 命令获得 Redis 当前的配置情况：</p>
<pre class=" language-bash"><code class="language-bash">$ CONFIG GET loglevel
1<span class="token punctuation">)</span> <span class="token string">"loglevel"</span>
2<span class="token punctuation">)</span> <span class="token string">"notice"</span></code></pre>
<p>其中第一行字符串回复表示的是选项名，第二行既是选项值。</p>
<h3 id="redsic-cli-连接"><a href="#redsic-cli-连接" class="headerlink" title="redsic-cli 连接"></a>redsic-cli 连接</h3><p>通过 redis-cli 向 Redis 发送命令有两种方式，第一种方式是将命令作为 redis-cli 的参数执行，如：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli SHUTDOWN</code></pre>
<p>redis-cli 执行时会自动按照默认配置（服务器地址为 127.0.0.1，端口号为 6379）连接 Redis，通过 -h 和 -p 参数可以自定义地址和端口号，-a 参数后跟 redis 连接密码：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -h 127.0.0.1 -p 6379 -a password</code></pre>
<p>第二种方式是不附带参数运行 redis-cli，这样会进入交互模式，可以自由输入命令，例如：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli
127.0.0.1:6379<span class="token operator">></span> PING
PONG</code></pre>
<p>这种方式在输入多条命令时比较方便。</p>
<h3 id="简单的几个小命令"><a href="#简单的几个小命令" class="headerlink" title="简单的几个小命令"></a>简单的几个小命令</h3><ol>
<li>获得符合规则的键名列表</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ KEYS pattern</code></pre>
<p>pattern 支持 glob 风格通配符格式：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配一个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意个（包括0个）字符</td>
</tr>
<tr>
<td>[]</td>
<td>匹配括号间的任一字符，可以使用 “-” 符号表示一个范围，如 a[b-d] 可以匹配 “ab”、“ac” 和 “ad”</td>
</tr>
<tr>
<td>\x</td>
<td>匹配字符 x，用于转义符号。如要匹配 “?” 就需要使用 ?</td>
</tr>
</tbody></table>
<blockquote>
<p>KEYS 命令需要遍历 Redis 中的所有键，当键的数量较多时会影响性能，不建议在生产环境中使用。Redis 不区分命令大小写。</p>
</blockquote>
<ol start="2">
<li>判断一个键是否存在</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ EXISTS key</code></pre>
<p>如果键存在则返回整数类型1，否则返回0。</p>
<ol start="3">
<li>删除键</li>
</ol>
<pre><code>$ DEL key</code></pre>
<p>可以删除一个或多个键，返回值是删除的键的个数。</p>
<blockquote>
<p><strong>技巧</strong>     DEL 命令的参数不支持通配符，但我们可以结合 Linux 的管道和 xargs 命令自己实现删除所有符合规则的键盘。比如要删除所有以 “user:” 开头的键，就可以执行<code>redis-cli KEYS "user:*" | xagrs redis cli DEL</code>。另外由于 DEL 命令支持多个键作为参数，所以还可执行如下命令来达到同样的效果，性能更好。</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli DEL `redis-cli KEYS <span class="token string">"user:*"</span>`</code></pre>
<p>如果连接redis 需要密码，则可以使用下面的这个命令</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -a 123456 DEL `redis-cli -a 123456 keys <span class="token string">"user:*"</span>`</code></pre>
</blockquote>
<ol start="4">
<li>获得键值的数据类型</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ TYPE key</code></pre>
<h3 id="命名习惯"><a href="#命名习惯" class="headerlink" title="命名习惯"></a>命名习惯</h3><blockquote>
<p>Redis 对于键的命名并没有强制的要求，但比较好的实践是用 <strong>“对象类型:对象ID:对象属性”</strong> 来命名一个键，如使用键  <code>user:1:friends</code> 来存储 ID 为 1 的用户的好友列表。对于多个单词则推荐使用 <code>“.”</code> 分隔，一方面是沿用以前的习惯（Redis 以前版本键名不能包含空格等特殊字符），另一方面是在 redis-cli 中容易输入，无需使用双引号包裹。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis位操作</title>
    <url>/posts/5969.html</url>
    <content><![CDATA[<h3 id="位操作命令"><a href="#位操作命令" class="headerlink" title="位操作命令"></a>位操作命令</h3><pre class=" language-bash"><code class="language-bash">$ GETBIT key offset
$ SETBIT key offset value
$ BITCOUNT key <span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token punctuation">[</span>end<span class="token punctuation">]</span>
$ BITOP operation destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>一个字节由 8 个二进制位组成，Redis 提供了 4 个命令可以直接对二进制位进行操作。为了演示，我们首先将 foo 赋值为 bar：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK</code></pre>
<p>bar 的 3 个字母 “b”, “a” 和 “r” 对应的 ASCII 码分别为98、97 和 114，转换为二进制后分别为 1100010、1100001 和 1110010，所以 foo 键中的二进制位结构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/14771610958236_.pic_hd.jpg"></p>
<p><code>GETBIT</code> 命令可以获得一个字符串类型键指定位置的二进制位的值（0 或 1），索引从 0 开始：</p>
<pre class=" language-bash"><code class="language-bash">$ GETBIT foo 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
$ GETBIT foo 6
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>如果需要获取的二进制位的索引超出了键值的二进制为的实际长度则默认值是0：</p>
<pre class=" language-bash"><code class="language-bash">$ GETBIT foo 10000
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p><code>SETBIT</code> 命令可以设置字符串类型键指定位置的二进制位的值，返回值是该位置的旧值。如我们要将 foo 键值设置为 arr，可以通过位操作将 foo 键的二进制位的索引第 6 位设为0，第 7 位设为1：</p>
<pre class=" language-bash"><code class="language-bash">$ SETBIT foo 6 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ SETBIT foo 7 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
$ GET foo
<span class="token string">"aar"</span></code></pre>
<p>如果要设置的位置超过了键值的二进制位的长度，<code>SETBIT</code> 命令会自动将中间的二进制位设置为 0。</p>
<p><code>BITCOUNT</code> 命令可以获得字符串类型键中值是1的二进制位个数，如：</p>
<pre class=" language-bash"><code class="language-bash">$ BITCOUNT foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10</code></pre>
<p>可以通过参数来限制统计的字节范围，如我们只希望统计前两个字节（即 “aa” ）:</p>
<pre class=" language-bash"><code class="language-bash">$ BITCOUNT foo 0 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6</code></pre>
<p><code>BITOP</code> 命令可以对多个字符串类型键进行位运算，并将结果存储在 destkey 参数指定的键中。<code>BITOP</code> 命令支持的运算操作有 AND、OR、XOR 和 NOT。</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo1 bar
OK
$ SET foo2 aar
OK
$ BITOP OR res foo1 foo2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ GET res
<span class="token string">"car"</span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/14841610959643_.pic_hd.jpg"></p>
<p><code>BITPOS</code>  命令可以获得指定键的第一个位置是 0 或者 1 的位置。还是以 ”bar“这个键值位例，如果想获取键值中的第一个二进制位为 1 的偏移量，则可以执行：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK
$ BITPOS foo 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p><code>BITOPS</code> 命令的第二个和第三个参数分别可以用来指定要查询的起始字节和结束字节。注意这里的单位不再是二进制位，而是字节。如果我们想查询的第二个字节到第三个字节之间（即 ”a“ 和 ”r“）出现的第一个值位 1 的二进制位的偏移量，则可以执行：</p>
<pre><code>$ BITPOS foo 1 1 2
(integer) 9</code></pre>
<p>这里的返回结果的偏移量是从头开始算起的，与起始字节无关。</p>
<blockquote>
<p>如果不设置结束字节且键值的所有二进制位都是 1 ，则当要查询值为 0 的二进制位偏移量时，返回结果会是键值长度的下一个字位的偏移量。这是因为 Redis 会认为键值长度之后的二进制位都是 0。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/posts/a455.html</url>
    <content><![CDATA[<blockquote>
<p>在微博中，用户之间是 “关注” 和 “被关注”的关系。如果要使用 Redis 存储这样的关系可以使用集合类型。思路是对每个用户使用两个集合类型键，分别名为 <code>user:用户ID:followers</code> 和 <code>user:用户ID:following</code> ，用来存储<strong>关注该用户的用户集合</strong> 和 <strong>该用户关注的集合</strong>。</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">follow</span><span class="token punctuation">(</span>$currentUser<span class="token punctuation">,</span> $targetUser<span class="token punctuation">)</span>
SADD user<span class="token punctuation">:</span>$currentUser<span class="token punctuation">:</span>following<span class="token punctuation">,</span> $targetUser
SADD user<span class="token punctuation">:</span>$taegetUser<span class="token punctuation">:</span>followers<span class="token punctuation">,</span> $currentUser</code></pre>
<p>如 ID 为 1 的用户 A 想关注 ID 为 2 的用 B，只需要执行 follow(1, 2) 即可。然而在实现该功能的时候发现了一个问题：完成关注操作需要一次执行两条 Redis 命令，如果在第一条命令执行完后，因为某种原因导致第二条命令没有执行。就会出现一个奇怪的现象：A 查看自己关注的用户列表时会发现其中有 B，而 B 查看关注自己的用户列表时却没有 A 。换句话说就是，A 虽然关注了 B ，却不是 B 的粉丝。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 中的事务（transaction） 是一组命令的集合。事务同命令一样都是 Redis 的最小执行单位，一个事务中的命令要么都执行，要么都不执行。</p>
<p>事务的原理是先将属于一个事务的命令发送给 Redis，然后将 Redis 依次执行这些命令。如：</p>
<pre class=" language-bash"><code class="language-bash">$ MULTI
OK
$ SADD <span class="token string">"user:1:following"</span> 2
QUEUED
$ SADD <span class="token string">"user:2:followers"</span> 1
QUEUED
$ EXEC
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre>
<p>首先使用 MULTI 命令告诉 Redis：“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来。” Redis 回答：“OK”。</p>
<p>而后我们发送了两个 SADD 命令来实现关注和被关注操作，可以看到 Redis 遵守了承诺，没有执行这些命令，而是返回 QUEUED 表示这两条命令已经进入等待执行的事务队列中了。</p>
<p>当把所有要在同一个事务中执行的命令都发给 Redis 后，我们使用 Exec 命令告诉 Redis 将等待执行的事务队列中的所有命令（即刚才所有返回 QUEUE 的命令）按照发送顺序依次执行。EXEC 命令的返回值就是这些命令的返回值组成的列表，返回值顺序和命令的顺序相同。</p>
<p>Redis 保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送 EXEC 命令前客户端断线了，则 Redis 会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了 EXEC 命令，所有的命令都会被执行，即使此后客户端断线也没关系，因为 Redis 中已经记录了所有要执行的命令。</p>
<p>除此之外，Redis 的事务还能保证一个事务内的命令一次执行而不被其它命令插入。试想客户端 A 需要执行几条命令，同时客户端 B 发送了一条命令，如果不使用事务，则客户端 B 的命令可能会插入到 客户端 A 的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>一个事务中的某个命令出错，针对错误的不同，Redis 会有不同的不同。</p>
<ul>
<li>语法错误。语法错误指命令不存在或者命令参数的个数不对。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ MULTI
OK
$ SET key value
QUEUED
$ SET key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR wrong number of arguments <span class="token keyword">for</span> <span class="token string">'set'</span> <span class="token function">command</span>
$ ERRORCOMMAND key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR unknown <span class="token function">command</span> <span class="token variable"><span class="token variable">`</span>ERRORCOMMAND<span class="token variable">`</span></span>, with args beginning with: <span class="token variable"><span class="token variable">`</span>key<span class="token variable">`</span></span>,
$ EXEC
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> EXECABORT Transaction discarded because of previous errors.</code></pre>
<p>只要有一个命令语法错误，执行 EXEC 命令后 Redis 就会直接返回错误，连语法正确的命令也不会执行。</p>
<ul>
<li>运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ MULTI
OK
$ SET key 1
QUEUED
$ SADD key 2
QUEUED
$ <span class="token keyword">set</span> key 3
QUEUED
$ EXEC
1<span class="token punctuation">)</span> OK
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> WRONGTYPE Operation against a key holding the wrong kind of value
3<span class="token punctuation">)</span> OK</code></pre>
<p>可见，如果事务里的一条命名出现了运行错误，事务里其它的命令依然会继续执行。</p>
<p>Redis 的事务没有回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的烂摊子（将数据库复原回事务执行前的状态等）。</p>
<h3 id="WATCH-命令"><a href="#WATCH-命令" class="headerlink" title="WATCH 命令"></a>WATCH 命令</h3><p><code>WATCH</code> 命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到 <code>EXEC</code> 命令。</p>
<pre class=" language-bash"><code class="language-bash">$ SET key 1
OK
$ WATCH key
OK
$ SET key 2
OK
$ MULTI
OK
$ SET key 3
QUEUED
$ EXEC
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
$ GET key
<span class="token string">"2"</span></code></pre>
<p>上例中在执行 <code>WATCH</code> 命令后、事务执行前修改了 key 的值（即 SET key 2) ，所以最后事务中的命令 <code>SET key 3</code> 没有执行， <code>EXEC</code> 返回空结果。</p>
<blockquote>
<p>由于 <code>WATCH</code> 命令的作用只是当被监控的键值被修改后，阻止之后一个事务的执行，而不能保证其它客户端不修改这以键值，所以我们需要在 <code>EXEC</code> 执行失败后，重新执行整个函数。</p>
</blockquote>
<p>执行 EXEC 命令会取消对所有键的监控。</p>
<p>可以使用 UNWATCH 命令来保证下一个事务的执行不会收到影响。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之发布-订阅模式</title>
    <url>/posts/8649.html</url>
    <content><![CDATA[<h3 id="发布-订阅-模式"><a href="#发布-订阅-模式" class="headerlink" title="发布/订阅 模式"></a>发布/订阅 模式</h3><p>Redis 提供了一组命令可以让开发者实现 “发布/订阅”（publish/subscribe）模式。“发布/订阅” 模式同样可以实现进程间的消息传递，其原理是这样的：</p>
<p>“发布/订阅” 模式中包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或若干个频道（channel），而发布者可以向指定的频道发布消息，所有订阅此频道的订阅者都可以收到此消息。</p>
<p>发布者发布消息的命令是 <code>PUBLISH</code>，用法是 <code>PUBLISH channel message</code>，如向 <code>channel.1</code> 说一声 “hi”：</p>
<pre class=" language-bash"><code class="language-bash">$ PUBLISH channel.1 hi
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>这样消息就发出去了。<code>PUBLISH</code> 命令的返回值表示接收到这条消息的订阅者数量。因为此时没有客户端订阅 <code>channel.1</code>，所以返回 0。发出去的消息不会被持久化，也就是说当有客户端订阅  <code>channel.1</code> 后只能收到后续发布到该频道的消息，之前发送的就收不到了。</p>
<p>订阅频道的命令是 <code>SUBSCRIBE</code>，可以同时订阅多个频道，用法是：</p>
<pre class=" language-bash"><code class="language-bash">$ SUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>现在新开一个 redis-cli 实例 A，用来订阅 <code>channel.1</code> ：</p>
<pre class=" language-bash"><code class="language-bash">$ SUBSCRIBE channel.1
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
1<span class="token punctuation">)</span> <span class="token string">"subscribe"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.1"</span>
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>执行 <code>SUBSCRIBE</code> 命令后，客户端会进入订阅状态，处于此状态下客户端不能使用除<code>SUBSRCIBE</code> 、<code>UNSUBSRCIBE</code> 、<code>PSUBSCRIBE</code> 、<code>PUNSUBSCRIBE</code> 这4个属于“发布/订阅”模式的命令之外的命令，否则会报错。</p>
<p>进入订阅状态后客户端可能收到三种类型的回复。每种类型的回复都包含3个值，第一个值是消息的类型，根据消息类型的不同，第二、第三个值的含义也不同。</p>
<p>消息类型的取值可能有一下3个：</p>
<ul>
<li><code>subscribe</code>。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个值是当前客户端订阅的频道数量。</li>
<li><code>message</code>。这个类型的回复是我们最关心的，它表示接收到的消息。第二个值表示产生消息的频道名称，第三个值是消息的内容。</li>
<li><code>unsubscribe</code>。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量。当此值为 0 时，客户端会退出订阅状态，之后就可以执行其它非 “发布/订阅” 模式的命令了。</li>
</ul>
<p>上例中当实例 A 订阅了 <code>channel.1</code>，进入订阅状态后收到一条 <code>subscribe</code> 类型的回复，这是我们打开另一个 redis-cli 实例 B，并向 <code>channel.1</code> 发送一条消息：</p>
<pre class=" language-bash"><code class="language-bash">$ PUBLISH channel.1 good
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>返回值为 1 表示有一个客户端订阅了 <code>channel.1</code>，此时实例 A 收到了类型为 <code>message</code> 的回复：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"message"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.1"</span>
3<span class="token punctuation">)</span> <span class="token string">"good"</span></code></pre>
<p>使用 UNSUBSCRIBE 命令可以取消订阅者指定的频道，用法为 </p>
<pre class=" language-bash"><code class="language-bash">UNSUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>如果不指定频道，则会取消订阅所有频道。</p>
<h3 id="按照规则订阅"><a href="#按照规则订阅" class="headerlink" title="按照规则订阅"></a>按照规则订阅</h3><p>除了可以使用 <code>SUBSCRIBE</code> 命令订阅指定的频道外，还可以使用 <code>PSUBSCRIBE</code> 命令订阅指定的规则。规则支持 <code>glob</code> 风格通配符格式。</p>
<pre class=" language-bash"><code class="language-bash">$ PSUBSCRIBE channel.?*
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
1<span class="token punctuation">)</span> <span class="token string">"psubscribe"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.?*"</span>
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>规则 <code>channel.1?*</code> 可以匹配 <code>channel.1</code> 和 <code>channel.10</code>。 但不会匹配 <code>channel.</code>。</p>
<p>这时在实例 B 中发布消息：</p>
<pre class=" language-bash"><code class="language-bash">$ PUBLISH channel.1 hi
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p>返回结果为 2 是因为实例 A 和 实例 C 两个客户端都订阅了 <code>channel.1</code> 频道。实例 C 收到的回复是：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"pmessage"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.?*"</span>
3<span class="token punctuation">)</span> <span class="token string">"channel.1"</span>
4<span class="token punctuation">)</span> <span class="token string">"hi"</span></code></pre>
<p>第一个值表示这条消息是通过 <code>PSUBSCRIBE</code> 命令订阅频道收到的，第二个值表示订阅时使用的通配符，第三个值表示产生消息的频道命令，第四个值则是消息内容。</p>
<blockquote>
<p><strong>提示</strong>    使用 <code>PSUBSCRIBE</code> 命令可以重复订阅一个频道，如某客户端执行了 <code>PUBSCRIBE  channel.?  channel.?*</code> ，这是向 <code>channel.2</code> 发布消息后该客户端会收到两条消息，而同时 <code>PUBLISH</code> 命令的返回值也是 2 不是 1。同样的，如果有两一个客户端执行了 <code>SUBSCRIBE channel.10</code> 和 <code>PSUBSCRIBE channel.?*</code> 的话，向 <code>channel.10</code> 发送命令该客服端也会收到两条消息（但是是两种类型：<code>message</code> 和 <code>pmessage</code>），同时 <code>PUBLISH</code> 命令会返回 2。</p>
</blockquote>
<p><code>PUNSUBSCRIBE</code> 命令可以退订指定的规则，用法是 ：</p>
<pre class=" language-bash"><code class="language-bash">$ PUNSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>如果没有参数则会退订所有规则。</p>
<blockquote>
<p><strong>注意</strong>    使用 <code>PUNSUBSCRIBE</code> 命令只会退订通过 <code>PSUBSCIBE</code> 命令订阅的规则，不会影响直接通过 <code>SUBSCRIBE</code> 命令订阅的频道；同样 <code>UNSUBSCRIBE</code> 命令也不会影响通过 <code>PSUBSCRIBE</code> 命令订阅的规则。另外容易出错的一点是使用 <code>PUNSUBSCIBE</code> 命令退订某个规则时，不会将其中的通配符展开，而是进行严格的字符串匹配，所有 <code>PUNSUBSCRIBE *</code> 无法退订 <code>channel.*</code> 规则，而是必须使用 <code>PUNSUBSCRIBE channel.*</code> 才能退订。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/posts/f2a0.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 支持两种方式的持久化，一种是 RDB 方式，另一种是 AOF 方式。前者会根据指定的规则 “定时” 将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。两种持久化方式可以单独使用其中一种，但更多情况下是将二者结合使用。</p>
<h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>RDB 方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即为“快照”。Redis 会在一下几种情况下对数据进行快照：</p>
<ul>
<li>根据配置规则进行自动快照</li>
</ul>
<p>Redis 允许用户自定义快照条件，当符合快照条件时，Redis 会自动执行快照条件。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：<strong>时间窗口 M 和 改动的键的个数 N。</strong>每当时间 M 内被更改键的个数大于 N 时，即符合自动快照条件。例如 Redis 安装目录中包含的样例配置文件中预置的3个条件：</p>
<pre class=" language-shell"><code class="language-shell">save 900 1
save 300 10
save 60 10000</code></pre>
<p>每条快照条件占一行，并且以 save 参数开头。同样可以存在多个条件，条件之间是 “或” 的关系。就这个例子而言，<code>save 900 1</code> 的意思是在 15 分钟（900秒）内由一个或一个以上的键被更改则进行快照。同理，<code>save 300 10</code> 表示在 300 秒内至少有10个键被修改则进行快照。</p>
<ul>
<li>用户执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令</li>
</ul>
<p>除了让 Redis 自动进行快照外，当进行服务重启、手动迁移以及备份时我们也会需要手动执行快照操作。Redis 提供了两个命令来完成这一任务。</p>
<ol>
<li><code>SAVE</code> 命令</li>
</ol>
<p>当执行 SAVE 命令时，Redis 同步地进行快照操作，在快照执行过程中会阻塞所有来自客户端地请求。当数据库中的数据比较多时，这一过程导致 Redis 较长时间不响应，所以要尽量避免在生产环境使用这一命令。</p>
<ol start="2">
<li><code>BGSAVE</code> 命令</li>
</ol>
<p>需要手动执行快照时推荐使用 <code>BGSAVE</code> 命令。<code>BGSAVE</code> 命令可以在后台异步地进行快照操作，快照的同时服务器还可以继续相应来自客户端的请求。执行 <code>BGSAVE</code> 后 Redis 会立即返回 OK 表示开始执行快照操作，如果想知道快照是否完成，可以通过 <code>LASTSAVE</code> 命令获取最近一次成功执行快照的时间，返回结果是一个 Unix 时间戳，如：</p>
<pre class=" language-bash"><code class="language-bash">$ LASTSAVE
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1611125890</code></pre>
<ul>
<li>执行 <code>FLUSHALL</code> 命令</li>
</ul>
<p>当执行 FLUSHALL 命令时，Redis 会清除数据库中的所有数据。需要注意的是，不论清空数据的操作是否出发了自动快照条件，只要自动快照条件不为空，Redis 就会执行一次快照操作。</p>
<p>当没有定义快照条件时，执行 <code>FLUSHALL</code> 则不会进行快照。</p>
<ul>
<li>执行复制（replication） 时</li>
</ul>
<p>当设置了主从模式时，Redis 会在复制初始化时自动进行自动快照。即使没有定义自动快照条件，并且手动没有执行过快照操作，也会生成 RDB 快照文件。</p>
<h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>理清 Redis 实现快照的过程对我们了解快照文件的特性有很大的帮助。Redis 默认会将快照文件存储在 Redis 当前进程的工作目录中的 <code>dump.rdb</code> 文件中，可以通过配置 <code>dir</code> 和 <code>dbfilename</code> 两个参数分别指定快照文件的存储路径和文件名。快照的过程如下：</p>
<ol>
<li>Redis 使用 fork 函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li>父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li>当子进程写入完所有数据后会用该临时文件替换旧的 RDB 文件，至此一次快照操作完成。</li>
</ol>
<blockquote>
<p><strong>提示</strong>    在执行 fork 的时候，操作系统（类 Unix 操作系统）会使用写时复制（copy-on-write）策略，即 fork 函数发生的一刻，父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保子进程的数据不受影响，所以新的 RDB 文件存储的是执行 fork 一刻的内存数据。</p>
<p>写时复制策略也保证了在 fork 的时刻，虽然看上去生成了两份内存副本，但实际上内存的占用量并不会增加一倍。这意味着当系统内存只有 2GB ，而 Redis 数据库的内存有 1.5GB，执行 fork 后内存使用量并不会增加到 3GB（超过物理内存）。为此需要确保 Linux 系统允许应用程序申请超过可用内存（物理内存和交换区）的空间，方法是在 <code>/etc/sysctl.conf</code> 文件加入 <code>vm.overcommit_memory = 1</code>，然后重启系统或者执行<code>sysctl vm.overcommit_memeoty = 1</code> 确保设置生效。</p>
<p>另外需要注意的是，当进行快照的过程中，如果写入操作较多，造成 fork 前后数据差异较大，是会使得内存使用量显著超过实际数据大小的，因为内存中不仅保存了当前的数据库数据，而且还保存着 fork 时刻的内存数据。进行内存用量估算时很容易忽略这一问题，造成内存用量超限。</p>
</blockquote>
<p>通过上述过程可以发现 Redis 在进行快照的过程中不会修改 RDB 文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候 RDB 文件都是完整的。这使得我们可以通过定时备份 RDB 文件来实现 Redis 数据库备份。 RDB 文件是讲过压缩的二进制格式（可以配置 <code>rdbcompression</code> 参数以禁用压缩节省 CPU 占用），所以占用的空间会小于内存中的数据大小，更加利于传输。</p>
<p>Redis 启动后会读取 RDB 快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录 1000 万个字符串类型键、大小为 1GB 的快照文件载入到内存中需要花费 20~30 秒。</p>
<p>通过 RDB 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。例如，使用 Redis 存储缓存数据时，丢失最近几秒的数据或者丢失最近更新的几十个键并不会有很大的影响。如果数据相对重要，希望将损失降到最小，则可以使用 AOF 的方式进行持久化。</p>
<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>当使用 Redis 存储非临时数据时，一般需要打开 AOF 持久化来降低进程终止导致的数据损失。AOF 可以将 Redis 执行的每一条写命令追加到硬盘文件中，这一过程显然会降低 Redis 的性能，但是大部分情况下这个影响是可以接受的，另外使用较快的硬盘可以提高 AOF 的性能。</p>
<ul>
<li>开启 AOF</li>
</ul>
<p>默认情况下，Redis 没有开启 AOF（append only file） 方式的持久化，可以通过 <code>appendonly</code>   参数启用：</p>
<pre class=" language-shell"><code class="language-shell">appendonly yes</code></pre>
<p>开启 AOF 持久化后没执行一条会更改 Redis 中的数据的命令，Redis 就会将命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>，可以通过 <code>appendfilename</code> 参数修改：</p>
<pre class=" language-sehll"><code class="language-sehll">appendonlyname appendonly.aof</code></pre>
<h3 id="AOF实现"><a href="#AOF实现" class="headerlink" title="AOF实现"></a>AOF实现</h3><p>AOF 文件以纯文本的形式记录了 Redis 执行的写命令，例如在开启 AOF 持久化的情况下执行了如下 4 个命令：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">set</span> foo 1
OK
$ <span class="token keyword">set</span> foo 2
OK
$ <span class="token keyword">set</span> foo 3
OK
$ get foo
<span class="token string">"3"</span></code></pre>
<p>此时 AOF 文件中的内容如下：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> appendonly.aof
*2
<span class="token variable">$6</span>
SELECT
<span class="token variable">$1</span>
0
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$1</span>
1
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$1</span>
2
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$1</span>
3</code></pre>
<p>可见 AOF 文件的内容正是 Redis 客户端 向 Redis 发送的原始通信协议的内容，从中可见 Redis 确实只记录了前 3 条命令。然后这时有一个问题是前 2 条命令其实都是冗余的，因为这两条的执行结果会被第三条命令覆盖。随着执行的命令越来越多，AOF 文件的大小也会越来越大，即使内存中实际的数据并没有多少。</p>
<p>很自然地，我们希望 Redis 可以自动优化 AOF 文件，就上例而言，就是将前两条无用地记录删除，只保留第三条。实际上 Redis 也正是这样做的，每当达到一定条件时，Redis 就会自动重写AOF 文件, 这个条件可以在配置文件中设置：</p>
<pre class=" language-shell"><code class="language-shell">auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb</code></pre>
<p>auto-aof-rewrite-percentage 参数的意义是当前的 AOF 文件大小超过上一次重写时的 AOF 文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的 AOF 文件大小为依据。</p>
<p>auto-aof-rewrite-min-size 参数限制了允许重写的最小 AOF 文件大小，通常在 AOF 文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。</p>
<p>除了让 Redis 自动执行重写外，我们还可以主动使用 <code>BGREWRITEAOF</code> 命令手动执行 AOF 重写。</p>
<h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>虽然每次执行更改数据库内容的操作时，AOF 都会将命令记录在 AOF 文件中，但是事实上，由于操作系统的缓存机制，数据没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每 30 秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30 秒的过程如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用 AOF 持久化的应用都无法容忍这样的损失，这就需要 Redis 在写入 AOF 文件后主动要求系统将缓存内容同步到硬盘中。在 Redis 中我们可以通过 <code>appendfsync</code> 参数设置同步的时机：</p>
<pre class=" language-shell"><code class="language-shell"># appendfsync always
appendfsync everysec
# appendfsync no</code></pre>
<p>默认情况下 Redis 采用 <code>everysec</code> 规则，即每秒执行一次同步操作。<code>always</code> 表示每次执行写入都会执行同步，这是最安全也是最慢的方式。<code>no</code> 表示不主动进行同步操作，而是完全交由操作系统来做（即每 30 秒一次），这是最快但最不安全的方式。一般情况下使用 <code>everysec</code> 足够了，即兼顾了性能又保证了安全。</p>
<blockquote>
<p>Redis 允许同时开启 AOF 和 RDB，即保证了数据安全又使得进行备份等操作十分容易。此时重新启动 Redis 后， Redis会使用 AOF 文件来恢复数据，因为 AOF 方式的持久化可能丢失的数据更少。 </p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的安装与启动</title>
    <url>/posts/dc55.html</url>
    <content><![CDATA[<h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wget</span> https://download.redis.io/releases/redis-6.0.10.tar.gz
$ <span class="token function">tar</span> xzf redis-6.0.10.tar.gz
$ <span class="token function">cd</span> redis-6.0.10
$ <span class="token function">make</span></code></pre>
<p>Redis 没有其它外部依赖，安装过程很简单。编译后在<strong>Redis源代码目录的 src 文件夹</strong>中可以找到若干个可执行程序，最好在编译后直接执行 <code>make install</code> 命令来将这些可执行程序复制到 <code>/user/local/bin</code> 目录中以便以后执行程序时不用输入完整的路径。</p>
<p>在实际运行 Redis 前推荐使用 <code>make test</code> 命令测试 Redis 是否编译正确，尤其是在编译一个不稳定版本的 Redis  时。</p>
<h3 id="启动和停止-Redis"><a href="#启动和停止-Redis" class="headerlink" title="启动和停止 Redis"></a>启动和停止 Redis</h3><p>在这之前需要了解 Redis 包含的可执行文件有哪些，如下：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>redis-server</td>
<td>Redis服务器</td>
</tr>
<tr>
<td>redis-cli</td>
<td>Redis命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>Redis性能测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>AOF文件修复工具</td>
</tr>
<tr>
<td>redis-check-rdb</td>
<td>RDB文件检查工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>Sentinel服务器</td>
</tr>
</tbody></table>
<p>如果在编译后执行了 <code>make install</code> 命令，这些程序会被复制到 <code>/usr/local/bin</code> 目录内，所以在命令行中直接输入程序名称即可执行。</p>
<h4 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h4><p>启动 Redis 有直接启动和通过初始化脚本启动两种方式，分别适用于开发环境和生产环境。</p>
<ul>
<li>直接启动</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ redis-server</code></pre>
<p>Redis 服务器默认会使用 6379 端口，通过 –port 参数可以自定义端口号：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-server --port 6380</code></pre>
<ul>
<li>通过初始化脚本启动 redis</li>
</ul>
<p>在 Linux 系统中可以通过初始化脚本启动 Redis, 使得 Redis 能随系统自动运行，在生产环境中推荐使用此方法运行Redis，这 <strong>Redis 源代码目录得 utils 文件夹中有一个名为 redis_init_script 的初始化脚本文件</strong>，内容如下：</p>
<pre class=" language-shell"><code class="language-shell">#!/bin/sh
#
# Simple Redis init.d script conceived to work on Linux systems
# as it does use of the /proc filesystem.

### BEGIN INIT INFO
# Provides:     redis_6379
# Default-Start:        2 3 4 5
# Default-Stop:         0 1 6
# Short-Description:    Redis data structure server
# Description:          Redis data structure server. See https://redis.io
### END INIT INFO

REDISPORT=6379    # 端口号
EXEC=/usr/local/bin/redis-server # redis-server 启动脚本的位置
CLIEXEC=/usr/local/bin/redis-cli # redis-cli 客户端启动脚本的位置

PIDFILE=/var/run/redis_${REDISPORT}.pid
CONF="/etc/redis/${REDISPORT}.conf"    # redis.conf 配置文件的位置

case "$1" in
    start)
        if [ -f $PIDFILE ]
        then
                echo "$PIDFILE exists, process is already running or crashed"
        else
                echo "Starting Redis server..."
                $EXEC $CONF
        fi
        ;;
    stop)
        if [ ! -f $PIDFILE ]
        then
                echo "$PIDFILE does not exist, process is not running"
        else
                PID=$(cat $PIDFILE)
                echo "Stopping ..."
                $CLIEXEC -p $REDISPORT shutdown
                while [ -x /proc/${PID} ]
                do
                    echo "Waiting for Redis to shutdown ..."
                    sleep 1
                done
                echo "Redis stopped"
        fi
        ;;
    *)
        echo "Please use start or stop as first argument"
        ;;
esac</code></pre>
<p>我们需要配置 Redis 的运行方式和持久化文件、日志文件的存储位置等，具体步骤如下。</p>
<ol>
<li>配置初始化脚本。首先将初始化脚本复制到 <code>/etc/init.d</code> 目录中，文件名<strong>redis_端口号</strong>，其中端口号表示要让 Redis 监听的端口号，客户端通过该端口连接 Redis 。然后修改脚本第14行的  <code>REDISPORT</code>  变量的值为同样的端口号。</li>
<li>建立需要的文件夹：</li>
</ol>
<table>
<thead>
<tr>
<th>目录名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/redis</td>
<td>存放 Redis 的配置文件</td>
</tr>
<tr>
<td>/var/redis/端口号</td>
<td>存放 Redis 的持久化文件</td>
</tr>
</tbody></table>
<ol start="3">
<li>修改配置文件。首先将配置文件模板（ Redis 提供了一个配置文件的模板 <code>redis.conf</code>，位于源代码目录的根目录中）复制到 /etc/redis 目录中，以端口号命名（如“6379.conf“），然后对其中的部分参数进行编辑：</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes</td>
<td>使 Redis 以守护进程模式运行</td>
</tr>
<tr>
<td>pidfile</td>
<td>/var/run/redis_端口号.pid</td>
<td>设置 Redis 的 PID 文件位置</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
<td>设置 Redis 监听的端口号</td>
</tr>
<tr>
<td>dir</td>
<td>/var/redis/端口号</td>
<td>设置持久化文件存放位置</td>
</tr>
<tr>
<td>bind</td>
<td>0.0.0.0</td>
<td>允许远程连接</td>
</tr>
<tr>
<td>requirepass</td>
<td>“123456”</td>
<td>设置连接密码123456</td>
</tr>
</tbody></table>
<p>现在就可以使用如下命令来启动 Redis 了：</p>
<pre class=" language-bash"><code class="language-bash">$ /etc/init.d/redis_端口号 start</code></pre>
<p>设置开机自启动：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">chkconfig</span> redis_6379 on</code></pre>
<blockquote>
<p>系统开机启动时会去加载/etc/init.d/下面的脚本，通常而言每个脚本文件会自定义实现程序的启动；若想将新的程序开机自启动，只需在该目录下添加一个自定义启动程序的脚本，然后设置相应规则即可。<br>如在这里我们在/etc/init.d/下新建一个 redis_端口号 的脚本，开机启动时会去加载执行该脚本。</p>
</blockquote>
<h3 id="停止Redis"><a href="#停止Redis" class="headerlink" title="停止Redis"></a>停止Redis</h3><p>考虑到 Redis 有可能正在将内存中的数据同步到硬盘中，强制终止 Redis 进行可能会导致数据丢失。正确停止 Redis 的方式应该是向 Redis 发送 SHUTDOWN 命令，方法为：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli SHUTDOWN</code></pre>
<p>当 Redis 收到 <code>SHUTDOWN</code> 命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>
<p>Redis 可以妥善处理 SIGTERM （signal termination） 信号，所以使用 kill Redis 进行的 PID 也可以正常结束 Redis，效果与发送 SHTUDOWN 命令一样。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的SORT命令</title>
    <url>/posts/7886.html</url>
    <content><![CDATA[<p><code>SORT</code> 命令可以对列表类型、集合类型和有序集合类型键进行排序。</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH myList 4 2 6 1 3 7
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
$ LRANGE myList 0 -1
1<span class="token punctuation">)</span> <span class="token string">"7"</span>
2<span class="token punctuation">)</span> <span class="token string">"3"</span>
3<span class="token punctuation">)</span> <span class="token string">"1"</span>
4<span class="token punctuation">)</span> <span class="token string">"6"</span>
5<span class="token punctuation">)</span> <span class="token string">"2"</span>
6<span class="token punctuation">)</span> <span class="token string">"4"</span>
$ SORT myList
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span>
5<span class="token punctuation">)</span> <span class="token string">"6"</span>
6<span class="token punctuation">)</span> <span class="token string">"7"</span></code></pre>
<p>在对有序集合排序时会忽略元素的分数，只针对元素自身的值进行排序。比如：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD myzset 50 2 40 3 20 1 60 5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
$ SORT myzset
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"5"</span></code></pre>
<p>除了可以排列数字外，SORT 命令还可以通过 ALPHA 参数实现按照字典顺序排列非数字元素，就像这样：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH myList z c d a e h j b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 8
$ SORT myList
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR One or <span class="token function">more</span> scores can<span class="token string">'t be converted into double
$ SORT myList ALPHA
1) "a"
2) "b"
3) "c"
4) "d"
5) "e"
6) "h"
7) "j"
8) "z"
$ ZADD myzset 77 asiaMa 90 xiu 68 min
(integer) 3
$ SORT myzset
(error) ERR One or more scores can'</span>t be converted into double
$ SORT myzset ALPHA
1<span class="token punctuation">)</span> <span class="token string">"asiaMa"</span>
2<span class="token punctuation">)</span> <span class="token string">"min"</span>
3<span class="token punctuation">)</span> <span class="token string">"xiu"</span></code></pre>
<p>从这段示例中可以看到如果没有加 <code>ALPHA</code> 参数的话，<code>SORT</code> 命令会尝试将所有元素转换成双精度数来比较，如果无法转换则会提示错误。</p>
<p><code>SORT</code> 命令还支持 <code>LIMIT</code> 参数来返回指定范围的记过。用法同 SQL 语句一样，<code>LIMIE offset count</code>, 表示跳过前 offset 个元素并获取之后的 count 个元素。</p>
<pre class=" language-bash"><code class="language-bash">$ SORT tag:ruby:posts DESC LIMIT 1 2</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis管理</title>
    <url>/posts/3687.html</url>
    <content><![CDATA[<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Redis 的作者 <code>Salvatore Sanfilippo</code> 曾经发表过 Redis 宣言，其中提到 Redis 以简洁为美。同样在安全层面 Redis 也没有做太多的工作。 </p>
<h3 id="可信的环境"><a href="#可信的环境" class="headerlink" title="可信的环境"></a>可信的环境</h3><p>Redis 的安全设计是在 “ Redis 运行在可信环境” 这个前提下做出的。在生产环境运行时不能允许外界直接连接到 Redis 服务器上，而应该通过应用程序中转，运行在可信的环境中是保证 Redis 安全的最重要方法。</p>
<p>如只允许本机应用连接 Redis ，可以将 bind 参数改成：</p>
<pre class=" language-bash"><code class="language-bash">bind 127.0.0.1</code></pre>
<p>bind 参数只能绑定一个地址，如果想更自由的设置绑定规则需要通过防火墙来完成。</p>
<h3 id="数据库密码"><a href="#数据库密码" class="headerlink" title="数据库密码"></a>数据库密码</h3><p>可以通过配置文件中的 <code>requirepass</code> 参数为 Redis 设置一个密码。例如：</p>
<pre class=" language-shell"><code class="language-shell">requirepass 123456</code></pre>
<p>客户端每次连接到 Redis 时都需要发送密码，否则 Redis 会拒绝执行客户端发来的命令。</p>
<p>例如：</p>
<pre class=" language-bash"><code class="language-bash">$ GET foo
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR operation not permitted.</code></pre>
<p>发送密码需要使用 AUTH 命令，就像这样：</p>
<pre class=" language-bash"><code class="language-bash">$ AUTH 123456
OK</code></pre>
<p>之后就可以执行任何命令了。</p>
<p>由于 Redis 的性能极高，并且输入错误密码后 Redis 并不会进行主动延迟（考虑到 Redis 的单线程模型），所以攻击者可以通过穷举法破解 Redis 的密码（ 1 秒内能够尝试十几万个密码 ），因此在设置时一定要选择负责的密码。</p>
<blockquote>
<p><strong>提示</strong>    配置 Redis 复制的时候如果主数据库设置了密码，需要在从数据库的配置文件中通过 <code>masterauth</code> 参数设置主数据库的密码，以使从数据库连接主数据库时自动使用 AUTH 命令认证。</p>
</blockquote>
<h3 id="命名命令"><a href="#命名命令" class="headerlink" title="命名命令"></a>命名命令</h3><p>Redis 支持在配置文件中将命令重命名，比如将 <code>FLUASHALL</code> 命令重命名成一个比较复杂的名字，以保证自己的应用可以使用该命令。就像这样：</p>
<pre><code>rename-command FLUSHALL oyfekmjumwar5a8c0it2k</code></pre>
<p>如果希望直接禁用某个命令可以将命令重命名成空字符串：</p>
<pre class=" language-bash"><code class="language-bash">rename-command FLUSHALL <span class="token string">""</span></code></pre>
<blockquote>
<p><strong>注意</strong>    无论设置密码还是重命名命令，都需要保证配置文件的安全性，否则就没有任何意义了。</p>
</blockquote>
<h3 id="Redis-cli"><a href="#Redis-cli" class="headerlink" title="Redis-cli"></a>Redis-cli</h3><h4 id="耗时命令日志"><a href="#耗时命令日志" class="headerlink" title="耗时命令日志"></a>耗时命令日志</h4><p>当一条命令执行时间超过限制时，Redis 会将该命令的执行时间等信息加入耗时命令日志（show log）以供开发者查看。可以通过配置文件的 <code>slowlog-log-slower-than</code> 参数设置这一限制，要注意单位是微秒（1000000微妙相当于 1 秒），默认值是 10 000。耗时命令日志存储在内存中，可以通过配置文件的 <code>slowlog-max-len</code>参数来限制记录的条数。</p>
<p>使用 SLOWLOG GET 命令来获得当前的耗时命令日志，如：</p>
<pre class=" language-bash"><code class="language-bash">redis<span class="token operator">></span> SLOWLOG GET
   1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1611295121
   3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"set"</span>
      2<span class="token punctuation">)</span> <span class="token string">"foo"</span>
      3<span class="token punctuation">)</span> <span class="token string">"bar"</span></code></pre>
<p>每条日志都由以下 4  个部分组成：</p>
<ul>
<li>该日志唯一 ID</li>
<li>该命令执行的 Unix 时间</li>
<li>该命令的耗时时间，单位是微秒</li>
<li>命令及其参数。</li>
</ul>
<blockquote>
<p><strong>提示</strong>    为了产生一些耗时命令日志作为演示，这里将 <code>slowlog-log-slower-than</code> 参数设置为 0，即记录所有命令。如果设置为负数则会关闭耗时命令日志。</p>
</blockquote>
<h4 id="命令监控"><a href="#命令监控" class="headerlink" title="命令监控"></a>命令监控</h4><p>Redis 提供了 MONITOR 命令来监控 Redis 执行的所有命令，redis-cli 同样支持这个命令，如在 redis-cli 中执行 MONITOR：</p>
<pre class=" language-bash"><code class="language-bash">$ MONITOR
OK</code></pre>
<p>这时 Redis 执行的任何命令都会在 redis-cli 中打印出来，如我们打开另一个 redis-cli 执行 <code>SET foo bar</code> 命令，在之前的 redis-cli 中会输出以下内容：</p>
<pre class=" language-bash"><code class="language-bash">1611295421.146357 <span class="token punctuation">[</span>0 127.0.0.1:37122<span class="token punctuation">]</span> <span class="token string">"keys"</span> <span class="token string">"*"</span></code></pre>
<p>MONITOR 命令非常影响 Redis 的性能，一个客户端使用 MONITOR 命令会降低 Redis 将近一半的负载能力。所以 MONITOR 命令只适合用来调试和纠错。</p>
<h3 id="Rdbtools"><a href="#Rdbtools" class="headerlink" title="Rdbtools"></a>Rdbtools</h3><p>Rdbtools 是一个 Redis 的快照文件解析器，它可以根据快照文件导出 JSON 数据文件、分析 Redis 中每个键的占用空间情况等。</p>
<h4 id="安装-Rdbtools"><a href="#安装-Rdbtools" class="headerlink" title="安装 Rdbtools"></a>安装 Rdbtools</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/sripathikrishnan/redis-rdb-tools
<span class="token function">cd</span> redis-rdb-tools
<span class="token function">sudo</span> python3 setup.py <span class="token function">install</span></code></pre>
<h4 id="生成快照文件"><a href="#生成快照文件" class="headerlink" title="生成快照文件"></a>生成快照文件</h4><p>如果没有启用 RDB 持久化，可以使用 SAVE 命令手动使 Redis 生成快照文件。</p>
<h4 id="将快照导出为-JSON-格式"><a href="#将快照导出为-JSON-格式" class="headerlink" title="将快照导出为 JSON 格式"></a>将快照导出为 JSON 格式</h4><p>快照文件时二进制格式，不利于查看，可以使用 Rdbtools 来将其导出为 JSON 格式，命令如下：</p>
<pre class=" language-bash"><code class="language-bash">$ rdb --command json /path/to/dump.rdb <span class="token operator">></span> output_filename.json</code></pre>
<p>其中 <code>/path/to/dump.rdb</code> 是快照文件的路径，<code>output_filename.json</code> 为要导出的文件路径。</p>
<h4 id="生成空间使用情况报告"><a href="#生成空间使用情况报告" class="headerlink" title="生成空间使用情况报告"></a>生成空间使用情况报告</h4><p>Rdbtools 能够将快照文件中记录的每个键的存储情况导出为 CSV 文件，可以将该 CSV 文件导入到 Excel 等数据分析工具中分析来了解 Redis 的使用情况。命令如下：</p>
<pre class=" language-bash"><code class="language-bash">$ rdb -c memory /path/to/dump.rdb --bytes 128 -f memory.csv</code></pre>
<p>导出的 CSV 文件的字段如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>存储该键的数据库索引</td>
</tr>
<tr>
<td>type</td>
<td>键类型（使用 TYPE 命令获得）</td>
</tr>
<tr>
<td>key</td>
<td>键名</td>
</tr>
<tr>
<td>size_in_bytes</td>
<td>键大小（字节）</td>
</tr>
<tr>
<td>encoding</td>
<td>内部编码（使用 OBJECTENCODING 命令获得）</td>
</tr>
<tr>
<td>num_elements</td>
<td>键的元素数</td>
</tr>
<tr>
<td>len_largest_element</td>
<td>最大元素的长度</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream中flatmap使用</title>
    <url>/posts/9fb2.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><p>map：map方法返回的是一个object，map将流中的当前元素替换为此返回值；</p>
<p>flatMap：flatMap方法返回的是一个stream，flatMap将流中的当前元素替换为此返回流拆解的流元素；</p>
<h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><blockquote>
<p>map:Returns a stream consisting of the results of applying the given function to the elements of this stream.</p>
</blockquote>
<p>返回一个流，包含给定函数应用在流中每一个元素后的结果</p>
<blockquote>
<p>flatmap:Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</p>
</blockquote>
<p>返回一个流，包含将此流中的每个元素替换为通过给定函数映射应用于每个元素而生成的映射流的内容</p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>有二箱鸡蛋，每箱5个，现在要把鸡蛋加工成煎蛋，然后分给学生。</p>
<p>map做的事情：把二箱鸡蛋分别加工成煎蛋，还是放成原来的两箱，分给2组学生；</p>
<p>flatMap做的事情：把二箱鸡蛋分别加工成煎蛋，然后放到一起【10个煎蛋】，分给10个学生；</p>
<h3 id="用例一"><a href="#用例一" class="headerlink" title="用例一"></a>用例一</h3><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> data <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"好,好,学"</span><span class="token punctuation">,</span> <span class="token string">"习,天,天"</span><span class="token punctuation">,</span> <span class="token string">"向,上"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> dataArray <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">:</span> dataArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果： [好, 好, 学] [习, 天, 天] [向, 上] */</span>

List<span class="token operator">&lt;</span>String<span class="token operator">></span> dataList <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Stream<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">apply</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dataList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** 输出结果： [好, 好, 学, 习, 天, 天, 向, 上] */</span></code></pre>
<h3 id="用例二"><a href="#用例二" class="headerlink" title="用例二"></a>用例二</h3><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamIndia <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Virat"</span><span class="token punctuation">,</span> <span class="token string">"Dhoni"</span><span class="token punctuation">,</span> <span class="token string">"Jadeja"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamAustralia <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Warner"</span><span class="token punctuation">,</span> <span class="token string">"Watson"</span><span class="token punctuation">,</span> <span class="token string">"Smith"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamEngland <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> <span class="token string">"Bell"</span><span class="token punctuation">,</span> <span class="token string">"Broad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamNewZeland <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Kane"</span><span class="token punctuation">,</span> <span class="token string">"Nathan"</span><span class="token punctuation">,</span> <span class="token string">"Vettori"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamSouthAfrica <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"AB"</span><span class="token punctuation">,</span> <span class="token string">"Amla"</span><span class="token punctuation">,</span> <span class="token string">"Faf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamWestIndies <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Sammy"</span><span class="token punctuation">,</span> <span class="token string">"Gayle"</span><span class="token punctuation">,</span> <span class="token string">"Narine"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamSriLanka <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Mahela"</span><span class="token punctuation">,</span> <span class="token string">"Sanga"</span><span class="token punctuation">,</span> <span class="token string">"Dilshan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamPakistan <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Misbah"</span><span class="token punctuation">,</span> <span class="token string">"Afridi"</span><span class="token punctuation">,</span> <span class="token string">"Shehzad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> playersInWorldCup2016 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamIndia<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamAustralia<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamEngland<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamNewZeland<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamSouthAfrica<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamWestIndies<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamSriLanka<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamPakistan<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// java8之前</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> listOfAllPlayers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> team <span class="token operator">:</span> playersInWorldCup2016<span class="token punctuation">)</span><span class="token punctuation">{</span>
  listOfAllPlayers<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>team<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Players playing in world cup 2016"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listOfAllPlayers<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// java8 使用flatmap</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> flatMapList <span class="token operator">=</span> playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>pList <span class="token operator">-</span><span class="token operator">></span> pList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"List of all Players using Java 8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flatMapList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
   * 输出结果：
   * Players playing in world cup 2016
   * [Virat, Dhoni, Jadeja, Warner, Watson, Smith, Alex,Bell, Broad, Kane, Nathan, Vettori, AB, Amla, Faf, Sammy, Gayle, Narine, Mahela, Sanga, Dilshan, Misbah, Afridi, Shehzad]
   * List of all Players using Java 8
   * [Virat, Dhoni, Jadeja,Warner, Watson, Smith, Alex, Bell, Broad, Kane, Nathan, Vettori, AB, Amla, Faf, Sammy, Gayle,Narine, Mahela, Sanga, Dilshan, Misbah, Afridi, Shehzad]
   */</span></code></pre>
<h3 id="用例3"><a href="#用例3" class="headerlink" title="用例3"></a>用例3</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>KlassGroup<span class="token operator">></span> groupList <span class="token operator">=</span>
        Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Klass<span class="token operator">>></span> result <span class="token operator">=</span>
        groupList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it<span class="token punctuation">.</span><span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> result2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>KlassGroup group <span class="token operator">:</span> groupList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result2<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>group<span class="token punctuation">.</span><span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result2 = "</span> <span class="token operator">+</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> result3 <span class="token operator">=</span>
        groupList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it<span class="token punctuation">.</span><span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result3 = "</span> <span class="token operator">+</span> result3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Klass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> field<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Klass</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>field <span class="token operator">=</span> field<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">"field="</span> <span class="token operator">+</span> field<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">KlassGroup</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">KlassGroup</span><span class="token punctuation">(</span>Klass<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> objList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>Klass item <span class="token operator">:</span> objList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> <span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> group<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream中reduce使用</title>
    <url>/posts/801f.html</url>
    <content><![CDATA[<p>reduce方法用于对stream中元素进行聚合求值，最常见的用法就是将stream中一连串的值合成为单个值，比如为一个包含一系列数值的数组求和。</p>
<p>reduce方法有三个重载的方法，方法签名如下：</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">reduce</span><span class="token punctuation">(</span>BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span>
T <span class="token function">reduce</span><span class="token punctuation">(</span>T identity<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>U<span class="token operator">></span> U <span class="token function">reduce</span><span class="token punctuation">(</span>U identity<span class="token punctuation">,</span>
                 BiFunction<span class="token operator">&lt;</span>U<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> U<span class="token operator">></span> accumulator<span class="token punctuation">,</span>
                 BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="第一个签名方法"><a href="#第一个签名方法" class="headerlink" title="第一个签名方法"></a>第一个签名方法</h3><p>接受一个BinaryOperator类型的lambada表达式， 常规应用方法如下：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>代码实现了对numList中的元素累加。lambada表达式的a参数是表达式的执行结果的缓存，也就是表达式这一次的执行结果会被作为下一次执行的参数，而第二个参数b则是依次为stream中每个元素。如果表达式是第一次被执行，a则是stream中的第一个元素。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a="</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">",b="</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在表达式中假如打印参数的代码，打印出来的内容如下：</p>
<pre class=" language-java"><code class="language-java">a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span>
a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span>
a<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">4</span>
a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">5</span></code></pre>
<p>表达式被调用了4次， 第一次a和b分别为stream的第一和第二个元素，因为第一次没有中间结果可以传递， 所以 reduce方法实现为直接将第一个元素作为中间结果传递。</p>
<h3 id="第二个签名方法"><a href="#第二个签名方法" class="headerlink" title="第二个签名方法"></a>第二个签名方法</h3><pre class=" language-java"><code class="language-java">T <span class="token function">reduce</span><span class="token punctuation">(</span>T identity<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>与第一个签名的实现的唯一区别是它首次执行时表达式第一次参数并不是stream的第一个元素，而是通过签名的第一个参数identity来指定。我们来通过这个签名对之前的求和代码进行改进：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>  a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>其实这两种实现几乎差别，第一种比第一种仅仅多了一个字定义初始值罢了。 此外，因为存在stream为空的情况，所以第一种实现并不直接方法计算的结果，而是将计算结果用Optional来包装，我们可以通过它的get方法获得一个Integer类型的结果，而Integer允许null。第二种实现因为允许指定初始值，因此即使stream为空，也不会出现返回结果为null的情况，当stream为空，reduce为直接把初始值返回。</p>
<h3 id="第三个签名方法"><a href="#第三个签名方法" class="headerlink" title="第三个签名方法"></a>第三个签名方法</h3><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>U<span class="token operator">></span> U <span class="token function">reduce</span><span class="token punctuation">(</span>U identity<span class="token punctuation">,</span>
                 BiFunction<span class="token operator">&lt;</span>U<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> U<span class="token operator">></span> accumulator<span class="token punctuation">,</span>
                 BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>第三种签名的用法相较前两种稍显复杂，由于前两种实现有一个缺陷，它们的计算结果必须和stream中的元素类型相同，如上面的代码示例，stream中的类型为int，那么计算结果也必须为int，这导致了灵活性的不足，甚至无法完成某些任务， 比入我们咬对一个一系列int值求和，但是求和的结果用一个int类型已经放不下，必须升级为long类型，此实第三签名就能发挥价值了，它不将执行结果与stream中元素的类型绑死。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>0L<span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>  a <span class="token operator">+</span> b<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> 0L <span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>如上代码所示，它能见int类型的列表合并成long类型的结果。<br> 当然这只是其中一种应用罢了，由于摆脱了类型的限制我们还可以通过他来灵活的完成许多任务，比入将一个int类型的ArrayList转换成一个String类型的ArrayList。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"element-"</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>执行结果为：</p>
<pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>element<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span></code></pre>
<p>这个示例显得有点鸡肋，一点不实用，不过在这里我们的主要目的是说明代码能达到什么样的效果，因此代码示例也不必取自实际的应用场景。</p>
<p>从上面两个示例可以看出第三个reduce比前面两个强大的多，它的功能已经完全覆盖前面两个的实现，如果我们不考虑代码的简洁性，甚至可以抛弃前面两个。</p>
<p>另外，还需要注意的是这个reduce的签名还包含第三个参数，一个BinaryOperator&lt;U&gt;类型的表达式。在常规情况下我们可以忽略这个参数，敷衍了事的随便指定一个表达式即可，目的是为了通过编译器的检查，因为在常规的stream中它并不会被执行到，然而， 虽然此表达式形同虚设，可是我们也不是把它设置为null，否者还是会报错。 在并行stream中，此表达式则会被执行到，在这里我们不进行讲解，因为我自己也没用过。</p>
<pre><code>numList.parallelStream()</code></pre>
<p>可获得并行stream。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin如何实现空安全</title>
    <url>/posts/b698.html</url>
    <content><![CDATA[<ol>
<li><p>通过静态代码检查，编译插件检查，在编译器避免空指针异常</p>
</li>
<li><p>每次引用对象的时候，都去进行对象判空，在运行期间避免对象空指针</p>
</li>
</ol>
<blockquote>
<p>将一个对象的两种类型（可以为空的类型与不可以为空的类型）做一个彻底的分离。如果是不可能为空的对象，在编译期会禁止赋一个null值（编译期避免）；如果是有可能为空的对象，那么在对这个对象进行调用的时候，都会进行的非空判断（运行期避免）。</p>
</blockquote>
<h3 id="可空对象"><a href="#可空对象" class="headerlink" title="可空对象"></a>可空对象</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> a<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> s<span class="token operator">?</span><span class="token punctuation">.</span>length
<span class="token punctuation">}</span></code></pre>
<p>进行反编译，可以看到kotlin生成的class文件中进行了非空判断。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>Metadata<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>NotNull<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Nullable<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Metadata</span><span class="token punctuation">(</span>mv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"\000\020\n\000\n\002\020\016\n\002\b\002\n\002\020\002\n\000\032\020\020\000\032\0020\0012\b\020\002\032\004\030\0010\001\032\006\020\003\032\0020\004\006\005"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"getValue"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">"main"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"my-kotlin"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HelloKt</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String a <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">;</span>
    String str1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@NotNull</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="不可空对象"><a href="#不可空对象" class="headerlink" title="不可空对象"></a>不可空对象</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> a<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">"abc"</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> s<span class="token punctuation">.</span>length
<span class="token punctuation">}</span></code></pre>
<p>进行反编译，可以看到kotlin生成的class文件中直接进行了断言（断言对象不会为null）</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>Metadata<span class="token punctuation">;</span>
<span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>Intrinsics<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>NotNull<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Metadata</span><span class="token punctuation">(</span>mv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"\000\020\n\000\n\002\020\016\n\002\b\002\n\002\020\002\n\000\032\016\020\000\032\0020\0012\006\020\002\032\0020\001\032\006\020\003\032\0020\004\006\005"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"getValue"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">"main"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"my-kotlin"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HelloKt</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    String str1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@NotNull</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin泛型</title>
    <url>/posts/3e59.html</url>
    <content><![CDATA[<p>通过<code>where</code>关键字，对泛型参数限定满足所有条件</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">where</span> T <span class="token operator">:</span> Callback<span class="token punctuation">,</span> T <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">add</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        t<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">open</span> <span class="token keyword">class</span> A <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> B<span class="token operator">:</span> Callback<span class="token punctuation">,</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"callback"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>


<span class="token keyword">interface</span> Callback <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> test <span class="token operator">=</span> Test<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token comment" spellcheck="true">// val test2 = Test&lt;A>() Type argument is not within its bounds. Expected: Callback</span>
<span class="token punctuation">}</span></code></pre>
<p>kotlin的真泛型</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span>  <span class="token keyword">fun</span>  <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">></span> Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> T<span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> T<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装YApi</title>
    <url>/posts/b5f9.html</url>
    <content><![CDATA[<h3 id="启动MongoDB"><a href="#启动MongoDB" class="headerlink" title="启动MongoDB"></a>启动MongoDB</h3><ol>
<li>默认安装mongo</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker run -d --name mongo-yapi mongo</code></pre>
<ol start="2">
<li>挂载宿主目录安装mongo</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建挂载目录</span>
<span class="token function">mkdir</span> -p /data/yapi/mongodata </code></pre>
<ol start="3">
<li>运行mongo映射主机目录/data/yapi/mongodata</li>
</ol>
<pre><code>docker run --restart always -v /data/yapi/mongodata:/data/db  -d --name mongo-yapi mongo</code></pre>
<h3 id="获取YApi镜像"><a href="#获取YApi镜像" class="headerlink" title="获取YApi镜像"></a>获取YApi镜像</h3><ol>
<li>从阿里云镜像仓库拉取</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi</code></pre>
<ol start="2">
<li>初始化 Yapi 数据库索引及管理员账号</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker run -it --rm --link mongo-yapi:mongo   --entrypoint <span class="token function">npm</span>  --workdir /api/vendors  registry.cn-hangzhou.aliyuncs.com/anoy/yapi   run install-server</code></pre>
<blockquote>
<p>自定义配置文件挂载到目录 <code>/api/config.json</code>，官方自定义配置文件 -&gt; <a href="https://github.com/YMFE/yapi/blob/master/config_example.json">传送门</a></p>
</blockquote>
<ol start="3">
<li>启动 Yapi 服务</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker run -d   --name yapi  --link mongo-yapi:mongo  --workdir /api/vendors   -p 3000:3000   registry.cn-hangzhou.aliyuncs.com/anoy/yapi   server/app.js</code></pre>
<h3 id="使用YApi"><a href="#使用YApi" class="headerlink" title="使用YApi"></a>使用YApi</h3><p>访问 <code>http://localhost:3000</code> 登录账号 <code>admin@admin.com</code>，密码 <code>ymfe.org</code></p>
<p>至此，帅气的 Yapi 就可以轻松使用啦！</p>
<h3 id="其它相关操作"><a href="#其它相关操作" class="headerlink" title="其它相关操作"></a>其它相关操作</h3><ol>
<li>关闭yapi</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker stop yapi</code></pre>
<ol start="2">
<li>开启yapi</li>
</ol>
<pre><code>docker start yapi</code></pre>
<ol start="3">
<li>升级yapi</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、停止并删除旧版容器</span>
docker <span class="token function">rm</span> -f yapi

<span class="token comment" spellcheck="true"># 2、获取最新镜像</span>
docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi

<span class="token comment" spellcheck="true"># 3、启动新容器</span>
docker run -d  --name yapi  --link mongo-yapi:mongo  --workdir /api/vendors  -p 3000:3000   registry.cn-hangzhou.aliyuncs.com/anoy/yapi   server/app.js</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>YApi</tag>
      </tags>
  </entry>
  <entry>
    <title>var与val</title>
    <url>/posts/318f.html</url>
    <content><![CDATA[<h3 id="声明一个变量的完整语法"><a href="#声明一个变量的完整语法" class="headerlink" title="声明一个变量的完整语法"></a>声明一个变量的完整语法</h3><p>var &lt;propertyName&gt;[:&lt;PropertyType&gt;]  [= &lt;property_initializer&gt;]</p>
<p>​        [&lt;gettter&gt;]</p>
<p>​        [&lt;setter&gt;]</p>
<p>变量名：变量类型 = 变量初始值</p>
<p>​    getter</p>
<p>​    setter</p>
<h3 id="var-与-val"><a href="#var-与-val" class="headerlink" title="var 与 val"></a>var 与 val</h3><p>var 与 val 声明的变量，最本质的区别是：val 不能有setter。</p>
<p>var变量的声明：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Hello <span class="token punctuation">{</span>
    <span class="token keyword">var</span> str<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> field <span class="token operator">+</span> <span class="token string">"hello"</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            field <span class="token operator">=</span> value <span class="token operator">+</span> <span class="token string">"set"</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> hello <span class="token operator">=</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>str<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// nullhello </span>

    hello<span class="token punctuation">.</span>str <span class="token operator">=</span> <span class="token string">"world"</span>
    <span class="token function">print</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>str<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// worldsethello</span>
<span class="token punctuation">}</span></code></pre>
<p>val变量的声明：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Hello <span class="token punctuation">{</span>
      <span class="token keyword">val</span> str2<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> field <span class="token operator">+</span> <span class="token string">"hello"</span>
        <span class="token punctuation">}</span>
              <span class="token comment" spellcheck="true">/**
        set(value) { // 编译报错： A 'val'-property cannot have a setter
            field = value + "set"
        } */</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="val-常量"><a href="#val-常量" class="headerlink" title="val == 常量?"></a>val == 常量?</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">var</span> birthYear<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> age<span class="token operator">:</span> Int
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span> <span class="token operator">-</span> birthYear
        <span class="token punctuation">}</span>

    <span class="token keyword">fun</span> <span class="token function">plusYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        birthYear<span class="token operator">++</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 20</span>

    person<span class="token punctuation">.</span><span class="token function">plusYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 19</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到，val与常量是不等价的。</p>
<h3 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h3><p>const 只能修饰 object 的属性，或 top-level 变量。</p>
<p>const变量的值必须在编译期间确定下来，所以它的类型只能是String或基本类型。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Perfect</span><span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">/**
    const val  TOP = 1; // 编译报错：Const 'val' are only allowed on top level or in objects
    */</span>
<span class="token punctuation">}</span>

object Perfect<span class="token punctuation">{</span>
    <span class="token keyword">const</span> val  TOP <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Perfect</span> <span class="token punctuation">{</span>
    companion object <span class="token punctuation">{</span>
        <span class="token keyword">const</span> val TOP <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// top-level</span>
<span class="token keyword">const</span> val TOP <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">// OK</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git之前需要做的最小配置</title>
    <url>/posts/5174.html</url>
    <content><![CDATA[<h3 id="配置user-name-和-user-email"><a href="#配置user-name-和-user-email" class="headerlink" title="配置user.name 和 user.email"></a>配置user.name 和 user.email</h3><p>全局配置「对当前用户所有仓库有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --global user.email <span class="token string">"your_email"</span></code></pre>
<p>缺省等同于local「只对某个仓库有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --local user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --local user.email <span class="token string">"your_email"</span></code></pre>
<p>系统配置「对系统所有登录的用户有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --system user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --system user.email <span class="token string">"your_email"</span></code></pre>
<h3 id="显示config的配置"><a href="#显示config的配置" class="headerlink" title="显示config的配置"></a>显示config的配置</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --list --local
$ <span class="token function">git</span> config --list --global
$ <span class="token function">git</span> config --list --system</code></pre>
<h3 id="查看某一个属性"><a href="#查看某一个属性" class="headerlink" title="查看某一个属性"></a>查看某一个属性</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name</code></pre>
<h3 id="移除设置"><a href="#移除设置" class="headerlink" title="移除设置"></a>移除设置</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --unset --global user.email</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Redis实现任务队列</title>
    <url>/posts/4c47.html</url>
    <content><![CDATA[<h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><p>说到队列很自然就能想到 Redis 的列表类型。如果要实现任务队列，只需要让生产者将任务使用 LPUSH 命令加入到某个键中，另一边让消费者不断地使用 RPOP 命令从该键中取出任务即可。</p>
<p>比如完成发邮件的任务，需要知道收件地址、邮件主题和邮件正文。所以生产者需要将这3个信息组成对象并序列化成字符串，然后将其加入到任务队列中。而消费者则循环从队列中拉取任务，就像如下伪代码：</p>
<pre class=" language-shell"><code class="language-shell"># 无限循环读取任务队列中的内容
loop
 $task = RPOP queue
 if $task
     # 如果任务队列有任务则执行它
     execute($task)
 else 
     # 如果没有则等待 1 秒 以免过于频繁的请求数据
     wait 1 second</code></pre>
<p>到此一个使用 Redis 实现的简单的任务队列就写好了。不过还有一点不完美的地方：当任务队列中没有任务时，消费者都会每秒调用一次 <code>RPOP</code> 命令来查看是否有新任务。如果可以实现一旦有新任务加入任务队列就通知消费者就好了。其实借助 <code>BPOP</code> 命令就可以实现这样的需求。</p>
<p><code>BRPOP</code> 命令与 <code>RPOP</code> 命令相似，唯一的区别是当列表中没有元素时 BRPOP 命令会一直阻塞住连接，知道有新元素接入。如上代码可改写为：</p>
<pre class=" language-shell"><code class="language-shell">loop
    # 如果任务队列没有新任务，BRPOP 命令会一直阻塞，不会执行 execute()。
    $task = BRPOP queue 0
    # 返回值是一个数组，数组第二个元素是我们需要的任务。
    execute($task[1])</code></pre>
<p><code>BRPOP</code> 命令接受两个参数，第一个是键名，第二个是超时时间，单位是秒。当超过了此时间仍然没有获得新元素的话就会返回 nil。超时时间如果设置为 “0”，表示不限制等待的时间，即如果没有新元素加入列表就会永远阻塞下去。</p>
<p>当获得一个元素后 <code>BRPOP</code> 命令返回两个值，分别是键名和元素值。为了测试 <code>BRPOP</code> 命令，我们可以打开两个 redis-cli 实例，在实例 A 中：</p>
<pre class=" language-bash"><code class="language-bash">$ BRPOP queue 0</code></pre>
<p>键入回车后实例 A 会处于阻塞状态，这时在实例 B 中向 queue 中加入一个元素：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH queue task
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>在 <code>LPUSH</code> 命令执行后，实例 A 马上就返回了结果：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"queue"</span>
2<span class="token punctuation">)</span> <span class="token string">"task"</span>
<span class="token punctuation">(</span>27.33s<span class="token punctuation">)</span></code></pre>
<p>同时会发现 queue 中的元素已经被取走：</p>
<pre class=" language-bash"><code class="language-bash">$ LLEN queue
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>除了 <code>BRPOP</code> 命令外，Redis 还提供了 <code>BLPOP</code>，和 <code>BRPOP</code> 的区别在于从队列取元素时 <code>BLPOP</code> 会从队列左边取。</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><code>BLPOP</code> 命令可以同时接受多个键，其完整的命令格式为：</p>
<pre class=" language-bash"><code class="language-bash">$ BLPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span></code></pre>
<p>如果没有键都没有元素则阻塞，如果其中一个键有元素则会从该键中弹出元素。例如打开两个 redis-cli 实例，在实例 A 中：</p>
<pre class=" language-bash"><code class="language-bash">$ BLPOP queue:1 queue:2 queue:3 0</code></pre>
<p>在实例 B 中：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH queue:2 task
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>则在实例 A 中会返回：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"queue:2"</span>
2<span class="token punctuation">)</span> <span class="token string">"task"</span>
<span class="token punctuation">(</span>38.74s<span class="token punctuation">)</span></code></pre>
<p>如果多个键都有元素，则按照从左到右的顺序取第一键的一个元素。我们现在 queue:2  和 queue:3 中各加入一个元素：</p>
<pre class=" language-bash"><code class="language-bash">$ RPUSH queue:2 task1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ RPUSH queue:3 task2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>然后执行 BLPOP 命令</p>
<pre class=" language-bash"><code class="language-bash">$ BLPOP queue:1 queue:2 queue:3 0
1<span class="token punctuation">)</span> <span class="token string">"queue:2"</span>
2<span class="token punctuation">)</span> <span class="token string">"task1"</span></code></pre>
<p>借此特性可以实现区分优先级的任务队列。我们分别使用 <code>queue:confirmation.email</code> 和 <code>queue:notification.email</code> 两个键存储发送确认邮件和发送通知邮件两种任务，然后将消费者的代码改为：</p>
<pre class=" language-shell"><code class="language-shell">loop
    $task =
        BLPOP queue:confirmation.email
              queue:notification.email
              0
    execute($task[1])</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用文件进行交互</title>
    <url>/posts/ee67.html</url>
    <content><![CDATA[<h3 id="从文本文件中读取数据（导入）"><a href="#从文本文件中读取数据（导入）" class="headerlink" title="从文本文件中读取数据（导入）"></a>从文本文件中读取数据（导入）</h3><p>当把大量数据输入到表中时，如果打开 MySQL 监视器用键盘手动输入所有数据，就会耗费非常多的时间和精力。</p>
<p>在需要输入成千上万条数据的情况下，我们可以使用 CSV（Comma Separated Values，逗号分隔值）格式的文本文件进行输入，这种读取文件的方式称为<strong>导入</strong>。</p>
<h4 id="CSV-文件"><a href="#CSV-文件" class="headerlink" title="CSV 文件"></a>CSV 文件</h4><p>正如逗号分隔值这个名字所表达的那样，在 CSV 文件中，数据使用逗号隔开的，文件内容仅包含文本。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-28_12-38-37.png" style="zoom:50%;">

<p>每行记录都通过换行符用单独的一行表示</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-28_12-41-02.png" style="zoom:50%;">

<h4 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h4><pre class=" language-mysql"><code class="language-mysql">LOAD DATA INFILE '文件名' INTO table 表名 选项的描述;</code></pre>
<p>除了 CSV 格式的文件以外，不用逗号分隔的文本文件也能被读取。我们可以指定读取的数据的格式，比如指定数据之间的分隔符、换行符，以及从第几行开始读取等。</p>
<p>在这种情况下，“选项的描述” 部分需要按照下面的格式编写。</p>
<pre class=" language-mysql"><code class="language-mysql">$ FIELDS TERMINATED BY 分隔符 (默认是 '\t': TAB)
$ LINES TERMINATED BY 换行符 (默认是 '\b': 换行)
$ IGNORE 最开始跳过的行 LINES (默认是 0)</code></pre>
<h4 id="CSV-文件导入"><a href="#CSV-文件导入" class="headerlink" title="CSV 文件导入"></a>CSV 文件导入</h4><p>CSV 文件内容如下：</p>
<pre><code>A107,87,6
A103,12,6
A104,93,5
A102,205,6
A101,300,5
A103,17,5
A101,184,4
A104,181,4
A102,54,5
A103,101,4</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ LOAD DATA INFILE '/Users/asiama/tb_202101281251.csv' INTO TABLE tb1k FIELDS TERMINATED BY ',';</code></pre>
<blockquote>
<p><strong>提示</strong>    即使在 Windows 的情况下也不要使用 “\”，而要使用 “/”。例如: <code>C:\data\t.csv -&gt; C:/data/t.csv</code></p>
</blockquote>
<h4 id="将数据写入文本文件（导出）"><a href="#将数据写入文本文件（导出）" class="headerlink" title="将数据写入文本文件（导出）"></a>将数据写入文本文件（导出）</h4><p>与导入相反，我们可以将表中的数据提取到 CSV 文件等文本文件中。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * INTO OUTFILE '文件名' 选项的描述 FROM 表名</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * INTO OUTFILE '/Users/asiama/out.csv' FIELDS TERMINATED BY ',' FROM tb1;</code></pre>
<h3 id="从文本中读取并执行-SQL-命令"><a href="#从文本中读取并执行-SQL-命令" class="headerlink" title="从文本中读取并执行 SQL 命令"></a>从文本中读取并执行 SQL 命令</h3><p>当执行复杂且冗余的 SQL 语句时，如果每次都在 MySQL 监视器上编写就会很麻烦。在执行复杂的 SQL 语句的情况下，我们可以将其创建为文本文件，然后执行保存的文件。这种方法可以进一步提高工作效率，还可以显示创建成文本的 SQL 语句，并将其复制、粘贴到 MySQL 监视器上执行。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SOURCE 文本文件名</code></pre>
<blockquote>
<p><strong>将常用表的内容保存到文件中</strong>    使用 MySQL 监视器创建 “需要多次创建的表” 或者 “复杂的表” 效率会很低。在这种情况下，建议在文本中编写处理步骤，然后执行 SOURCE 命令来创建表。</p>
<pre class=" language-mysql"><code class="language-mysql">DROP TABLE IF EXISTS tb1;
CREATE TABLE tb1(empid VARCHAR(10), name VARCHAR(10), age INT);
INSERT INTO tb1 VALUES('A101', '佐腾', 40);
INSERT INTO tb1 VALUES('A102', '时间', 20);
INSERT INTO tb1 VALUES('A103', '舒服', 30);</code></pre>
<p>使用文本编辑器创建好文件后，将其保存到 data 文件夹中。执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SOURCE /data/tb1_make.txt</code></pre>
</blockquote>
<h4 id="通过命令提示符执行编写在文件中的-SQL-命令"><a href="#通过命令提示符执行编写在文件中的-SQL-命令" class="headerlink" title="通过命令提示符执行编写在文件中的 SQL 命令"></a>通过命令提示符执行编写在文件中的 SQL 命令</h4><pre class=" language-mysql"><code class="language-mysql">$ mysql 数据库名 -u 用户名 -p密码 -e "MySQL 监视器的命令"</code></pre>
<p>例如：</p>
<pre class=" language-mysql"><code class="language-mysql">$ mysql db1 -u root -proot -e "SOURCE /data/tb1_make.txt"</code></pre>
<p>即使不启动 MySQL 监视器，也可以通过命令提示符直接执行文本文件中编写的 SQL 命令。</p>
<h3 id="将-SQL-的执行结果保存到文件中"><a href="#将-SQL-的执行结果保存到文件中" class="headerlink" title="将 SQL 的执行结果保存到文件中"></a>将 SQL 的执行结果保存到文件中</h3><p>在 MySQL 监视器上输入的命令会显示在屏幕上，执行结果也会显示在屏幕上。用户可以通过查看屏幕上显示的执行结果来获取信息，也可以将这些执行结果作为数据使用。</p>
<p>那么，如何将 SQL 的执行结果保存到文件中呢？这里我们将介绍 “在 MySQL 监视器上执行 tee 命令” 和 ”使用重定向将结果输出到标准输出“ 这两种方法。</p>
<h4 id="通过重定向将-SQL-语句的执行结果输出到文本文件中"><a href="#通过重定向将-SQL-语句的执行结果输出到文本文件中" class="headerlink" title="通过重定向将 SQL 语句的执行结果输出到文本文件中"></a>通过重定向将 SQL 语句的执行结果输出到文本文件中</h4><p>我们可以在计算机上输入一些数据并让计算机输出处理结果。这时通常会使用键盘进行 “输入”，然后把结果 “输出” 到显示器上。像键盘这种一开始就配备好的输入设备称为 “标准输入”，像显示器这种一开始就配备好的输出设备称为 “标准输出”。</p>
<p>“标准输入” 和 “标准输出” 可以更改。这种更改操作称为 “重定向 (redirect) ”。当进行重定向操作，也就是更改输入、输出目标时，需要使用 “&gt;” 等符号。</p>
<h4 id="通过命令提示符进行重定向"><a href="#通过命令提示符进行重定向" class="headerlink" title="通过命令提示符进行重定向"></a>通过命令提示符进行重定向</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Windnows</span>
$ <span class="token function">dir</span> <span class="token operator">></span> abc.txt
<span class="token comment" spellcheck="true"># MacOS 或 Linux</span>
$ <span class="token function">ls</span> <span class="token operator">></span> abc.txt</code></pre>
<h4 id="通过-mysql-命令使用重定向"><a href="#通过-mysql-命令使用重定向" class="headerlink" title="通过 mysql 命令使用重定向"></a>通过 mysql 命令使用重定向</h4><pre class=" language-mysql"><code class="language-mysql">$ mysql -u root -proot > log.txt</code></pre>
<p>如果按照这种方式启动 MySQL 监视器，SQL 语句的执行结果将不会显示在屏幕上，而是会输入到重定向指定的 log.txt 中。</p>
<p>从命令提示符上执行 SQL 语句文本文件 sql.txt，然后使用重定向将结果直接写入文件文件 log.txt 中：</p>
<pre class=" language-mysql"><code class="language-mysql">$ mysql -u root -proot -e "SOURCE /data/sql.txt" > log.txt</code></pre>
<blockquote>
<p><strong>使用重定向输入 SQL 语句，并通过重定向将结果输出到文件</strong></p>
<p>使用重定向输入文件时需要使用 “&lt;”。这样就可以使用重定向输入并执行文本文件的 SQL 语句 (sql.txt)，然后再通过重定向将结果输出到文本文件中（log2.txt）。</p>
<pre class=" language-mysql"><code class="language-mysql">$ mysql -u root -proot < /data/sql.txt > /data/log2.txt</code></pre>
<p>即使看不到过程也没有问题。但是，在使用这种方法的情况下，就算 SQL 语句报错，我们也只能通过查看输出的文本文件得知。</p>
</blockquote>
<h4 id="使用-tee-命令将-SQL-语句的执行结果保存到文件中"><a href="#使用-tee-命令将-SQL-语句的执行结果保存到文件中" class="headerlink" title="使用 tee 命令将 SQL 语句的执行结果保存到文件中"></a>使用 tee 命令将 SQL 语句的执行结果保存到文件中</h4><p>在 MySQL 监视器上使用 tee 命令，可以与重定向一样将结果写入文件。如果在 MySQL 监视器上按照如下方式执行 tee 命令，执行结果就会保存在执行的文件中。</p>
<pre class=" language-mysql"><code class="language-mysql">$ tee 输出文件名称</code></pre>
<h4 id="将执行结果保存到文件中"><a href="#将执行结果保存到文件中" class="headerlink" title="将执行结果保存到文件中"></a>将执行结果保存到文件中</h4><p>当把执行结果导出到文件 log3.txt 时：</p>
<pre class=" language-mysql"><code class="language-mysql">$ tee /Users/asiama/log3.txt
Logging to file '/Users/asiama/log3.txt'</code></pre>
<p>这样就创建出了一个空的文本文件 log3.txt，以后输出结果不仅会显示在屏幕上，还会写入 log3.txt 中。</p>
<h4 id="停止向文件中输出执行结果"><a href="#停止向文件中输出执行结果" class="headerlink" title="停止向文件中输出执行结果"></a>停止向文件中输出执行结果</h4><pre class=" language-mysql"><code class="language-mysql">$ notee
Outfile disabled.</code></pre>
<h3 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a>备份和恢复数据库</h3><h4 id="备份和恢复的方法"><a href="#备份和恢复的方法" class="headerlink" title="备份和恢复的方法"></a>备份和恢复的方法</h4><p>我们可以将数据库的设置、表和列的定义、数据等数据库的所有信息作为文件导出。</p>
<ul>
<li>转储</li>
</ul>
<p>对数据库的所有内容执行导出的操作称为 转储（dump）。如果使用转储文件，就可以在其它服务器上创建内容相同的数据库，也可以备份以应对紧急情况的发生。</p>
<p>我们可以在命令提示符上执行 mysqldump 命令来转储 MySQL 数据库。</p>
<p>mysqldump 命令会将数据库的配置和数据本身作为 SQL 语句写出来，也就是通过 “CREATE TABLE …” 创建表，然后写出 “INSERT INTO …” 这样的 SQL 语句。</p>
<p>通过转储导出的信息是由 SQL 语句生成的文本。通过这些文本，我们可以读到数据库的所有信息，可以说 “转储输出就是数据库本身”。从安全层面考虑，我们需要谨慎对待这些信息。</p>
<ul>
<li>恢复</li>
</ul>
<p>把通过 mysqldump 命令导出的数据还原到数据库中的操作称为 <strong>恢复</strong>。恢复意味着从头创建数据库，其实就是将包含 SQL 语句集合的文本文件用 MySQL 命令进行重定向。</p>
<h4 id="使用-mysqldump-导出"><a href="#使用-mysqldump-导出" class="headerlink" title="使用 mysqldump 导出"></a>使用 mysqldump 导出</h4><pre class=" language-bash"><code class="language-bash">$ mysqldump -u 用户名 -p密码 数据库名 <span class="token operator">></span> 输出文件名称</code></pre>
<blockquote>
<p><strong>恢复作业失败的情况</strong>    如果在之后的操作中恢复作业失败了，试着在转储时加上 –default-character-set=utf8 之类的字符编码的选项，执行 <code>mysqldump -u root -proot db1 &gt; /Users/asiama/db1_out.txt --default-character-set=utf8</code>。</p>
</blockquote>
<h4 id="恢复转储文件"><a href="#恢复转储文件" class="headerlink" title="恢复转储文件"></a>恢复转储文件</h4><p>当恢复数据库时，我们必须提前准备一个用于填充的数据库。如果没有数据库，就需要提前创建一个。</p>
<pre class=" language-bash"><code class="language-bash">$ mysqladmin -u root -proot CREATE db2<span class="token punctuation">;</span>

$ mysql -u root -proot db2 <span class="token operator">&lt;</span> /Users/asiama/db1_out.txt</code></pre>
<h4 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h4><p>在大部分情况下，以上操作能顺利执行。不过，在使用 MySQL 的过程中，我们经常会收到字符编码问题的困扰。</p>
<p>我们可以执行字符编码进行转储或者恢复：</p>
<pre class=" language-mysql"><code class="language-mysql">$ mysqldump -u root -proot db1 > db3_out.txt --default-character-set=utf8
$ mysql -u root -p root db3 < db3_out.txt --default-character-set=utf8</code></pre>
<blockquote>
<p><strong>锁表</strong>    给表加锁来限制表的操作的 LOCK 命令</p>
<ul>
<li>锁表</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">LOCK TABLES 表名 锁的类型</code></pre>
<p>LOCK 命令通过给指定的表加上某种类型的锁来限制对表的操作。锁的类型主要有以下几种：</p>
<table>
<thead>
<tr>
<th>锁的类型</th>
<th>限制内容</th>
</tr>
</thead>
<tbody><tr>
<td>READ</td>
<td>所有客户端都只需允许执行 SELECT。只读锁</td>
</tr>
<tr>
<td>READ LOCAL</td>
<td>对于 InnoDB 以外的存储引擎，允许加锁以外的客户端仅执行非冲突性 INSERT 语句，但是不允许执行 UPDATE。如果是InnoDB存储引擎，则和 READ 相同。本地只读锁。</td>
</tr>
<tr>
<td>WRITE</td>
<td>没有加锁的客户端不能执行任何操作，拥有锁的客户端可以执行操作。</td>
</tr>
</tbody></table>
<p>给表 my_table 设置 READ 锁需要执行如下命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ LOCK TABLES my_table READ;</code></pre>
<p>释放锁：</p>
<pre class=" language-mysql"><code class="language-mysql"># 解锁当前所有表
$ UNLOCK TABLES;</code></pre>
</blockquote>
<h4 id="表的备份"><a href="#表的备份" class="headerlink" title="表的备份"></a>表的备份</h4><pre class=" language-bash"><code class="language-bash">$ mysqldump -u 用户名 -p密码 数据库名 表名 <span class="token operator">></span> 输出文件的名称</code></pre>
<p>恢复表和恢复数据库一样，不用指定表名，直接读取文件即可。如：</p>
<pre class=" language-bash"><code class="language-bash">$ mysql -u root -proot db3 <span class="token operator">&lt;</span> /Users/asiama/tb1_out.txt</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/posts/f609.html</url>
    <content><![CDATA[<p>函数式编程的核心概念如下：</p>
<ul>
<li>头等函数：把函数（一小段行为）当作值使用，可以用变量保存它，把它当作参数传递，或者当作其它函数的返回值。</li>
<li>不可变性：使用不可变对象，这保证了它们的状态在其创建之后不能再变化。</li>
<li>无副作用：使用的是纯函数。此类函数在输入相同时会产生同样的结果，并且不会修改其它对象的状态，也不会和外面的世界交互。</li>
</ul>
<p>优点：</p>
<ol>
<li>简洁</li>
</ol>
<p>函数式风格的代码比相应的命令式风格的代码更优雅、更简练，因为把函数当作值可以让你获得更强大的抽象能力，从而避免重复代码。假设你有两段类似的代码，实现相似的任务（例如，在集合中寻找一个匹配的元素），但具体细节略有不同（如何判断元素式匹配的）。可以轻易地将这段逻辑公共部分提取到一个函数中，并将其它不同的部分作为参数传递给它。这些参数本身也是函数，但你可以使用一种简洁的语法来表示这些匿名函数，它被称作lambda表达式。</p>
<ol start="2">
<li>多线程安全</li>
</ol>
<p>多线程程序中最大的错误来源之一就是，在没有采取适当同步机制的情况下，在不同的线程上修改同一份数据。如果你使用的是不可变数据结构和纯函数，就能保证这样不安全的修改根本不会发生，也就不需要考虑为其设计股灾的同步方案。</p>
<ol start="3">
<li>易测试性</li>
</ol>
<p>没有副作用的函数可以独立地进行测试，因为不需要写大量的设置代码来构造它们所依赖的整个环境。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建数据库</title>
    <url>/posts/cd0e.html</url>
    <content><![CDATA[<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre class=" language-mysql"><code class="language-mysql">CREATE DATABASE 数据库名;</code></pre>
<p>SQL 语句的命令需要使用半角字符输入，输入全角字符会发生错误。另外，MySQL 不区分大小写。</p>
<blockquote>
<p><strong>提示</strong>    在 Windows 和 macOS 的环境中不区分字符的大小写，但是在 Linux 环境中却区分大小写。也就是说，表 tb1 和 表 TB1 在 Windows 和 macOS 环境中会作为相同的表名处理，但是在 Linux 环境中会作为不同的表名处理。</p>
</blockquote>
<h3 id="确认数据库"><a href="#确认数据库" class="headerlink" title="确认数据库"></a>确认数据库</h3><pre class=" language-mysql"><code class="language-mysql">SHOW DATABASES;</code></pre>
<h3 id="指定使用的数据库"><a href="#指定使用的数据库" class="headerlink" title="指定使用的数据库"></a>指定使用的数据库</h3><pre class=" language-mysql"><code class="language-mysql">USE database_name;</code></pre>
<blockquote>
<p><strong>提示</strong>    我们可以使用 \u 来代替 use，使用 \u db1 命令执行数据库。</p>
</blockquote>
<h3 id="显示当前使用的数据库"><a href="#显示当前使用的数据库" class="headerlink" title="显示当前使用的数据库"></a>显示当前使用的数据库</h3><pre class=" language-mysql"><code class="language-mysql">SELECT DATABASES</code></pre>
<blockquote>
<p><strong>提示</strong>    我们可以直接指定数据库启动MySQL监视器。在这种情况下，可以像<code>mysql db1 -u root -proot</code> 这样，通过在命令提示符中指定数据库名来执行mysql命令。</p>
</blockquote>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE 表名（列名1 数据类型1，列名2 数据类型2 ...）</code></pre>
<h3 id="显示所有的表"><a href="#显示所有的表" class="headerlink" title="显示所有的表"></a>显示所有的表</h3><pre class=" language-mysql"><code class="language-mysql">SHOW TABLES;</code></pre>
<blockquote>
<p><strong>提示</strong>    在 MySQL 中输入字符到表中时，会因为各种原因出现字符乱码的情况。这时有一个方法可以解决这个问题，那就是执行字符编码创建表。</p>
<pre class=" language-mysql"><code class="language-mysql">CREATE TABLE tb1(emp_id VARCHAR(10), name VARCHAR(10), age INT) CHARSET=utf8mb4;</code></pre>
</blockquote>
<h3 id="访问其他数据库"><a href="#访问其他数据库" class="headerlink" title="访问其他数据库"></a>访问其他数据库</h3><p>在使用 <code>use</code> 选择数据库的情况下也能够操作其它数据库中的表。这是可以像 “数据库名.表名” 这样把 “数据库名” 和 “表名” 用 “.” 连接起来。</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT * FROM db2.table;</code></pre>
<h3 id="确认表的列结构"><a href="#确认表的列结构" class="headerlink" title="确认表的列结构"></a>确认表的列结构</h3><pre class=" language-mysql"><code class="language-mysql">DESC 表名;</code></pre>
<p>例如，查看 tb1 表的数据结构：</p>
<pre class=" language-bash"><code class="language-bash">$ DESC tb1<span class="token punctuation">;</span>
+-------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> Field <span class="token operator">|</span> Type         <span class="token operator">|</span> Null <span class="token operator">|</span> Key <span class="token operator">|</span> Default <span class="token operator">|</span> Extra <span class="token operator">|</span>
+-------+--------------+------+-----+---------+-------+
<span class="token operator">|</span> empid <span class="token operator">|</span> varchar<span class="token punctuation">(</span>10<span class="token punctuation">)</span>  <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> name  <span class="token operator">|</span> varchar<span class="token punctuation">(</span>10<span class="token punctuation">)</span>  <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">|</span> age   <span class="token operator">|</span> int          <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> NULL    <span class="token operator">|</span>       <span class="token operator">|</span>
+-------+--------------+------+-----+---------+-------+</code></pre>
<p>Null 表示“允许不输入任何值”，Default表示“如果什么值都不输入就用这个值”。Field表示列名，Type表示数据类型。</p>
<p>因为列name被设置成了VARCHAR(10)，所以我们无法输入多于10个字符的数据。但是在MySQL中，即使输入了多于指定字符数（这里是10个字符）的数据也不会报错，而是会忽略无法插入的字符（这里是指10个字符之后的数据），这一点需要注意。</p>
<blockquote>
<p>如果将SQL Modes设为STRICE_TRANS_TABLES时回报出Data to long for column ‘XXX’ at row XX的错误。</p>
</blockquote>
<h3 id="向表中插入多行记录"><a href="#向表中插入多行记录" class="headerlink" title="向表中插入多行记录"></a>向表中插入多行记录</h3><pre class=" language-mysql"><code class="language-mysql">INSERT INTO tb1 (emp_id, name, age) VALUES ('A101', '佐藤', 40), ('A102', '高桥', 28), ('A103', '中川', 20), ('A104', '渡边', 23), ('A105', '西泽', 35);</code></pre>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE tb1A SELECT * FROM tb1;</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收 Spring Bean</title>
    <url>/posts/581e.html</url>
    <content><![CDATA[<p>Bean垃圾回收（GC）</p>
<ul>
<li>关闭Spring 容器（应用上下文）</li>
<li>执行GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Disposable#destroy() : Employee 销毁中... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前对象 Employee 对象正在被回收..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略setter getter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanGarbageCollectionDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class 配置类</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanGarbageCollectionDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 强制出发 GC</span>
    System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    Disposable#destroy() : Employee 销毁中... 
    当前对象 Employee 对象正在被回收... */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>实例化Spring Bean</title>
    <url>/posts/b731.html</url>
    <content><![CDATA[<h3 id="常规的四种方式"><a href="#常规的四种方式" class="headerlink" title="常规的四种方式"></a>常规的四种方式</h3><h4 id="通过构造器"><a href="#通过构造器" class="headerlink" title="通过构造器"></a>通过构造器</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：com.asia.User@4dfa3a9d */</span></code></pre>
<p>如果添加私有（<code>private</code>）无参构造函数或添加带参构造函数时，IoC容器启动时，因无法调用到该类的公共无参构造函数，会导致IoC容器初始化失败，并抛出<code>NoSuchMethodException</code>，因为这是一个致命问题。类似的报错信息提示如下：</p>
<blockquote>
<p>Failed to instantiate [com.asia.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.asia.User.&lt;init&gt;()</p>
</blockquote>
<h4 id="通过静态工厂方法"><a href="#通过静态工厂方法" class="headerlink" title="通过静态工厂方法"></a>通过静态工厂方法</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
     <span class="token comment" spellcheck="true">&lt;!--    静态方法实例化 Bean--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user-by-static-method<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.User<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>createUser<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> User <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>
                <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>
                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
                <span class="token string">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user-by-static-method"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过Bean工厂方法"><a href="#通过Bean工厂方法" class="headerlink" title="通过Bean工厂方法"></a>通过Bean工厂方法</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!--    实例方法实例化 Bean--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user-by-instance-method<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>createUser<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.factory.DefaultFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/** 去掉了static */</span>
  <span class="token keyword">public</span> User <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span> <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span> <span class="token string">'}'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserFactory</span> <span class="token punctuation">{</span>
  <span class="token keyword">default</span> User <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFactory</span> <span class="token keyword">implements</span> <span class="token class-name">UserFactory</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user-by-instance-method"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过FactoryBean"><a href="#通过FactoryBean" class="headerlink" title="通过FactoryBean"></a>通过FactoryBean</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token comment" spellcheck="true">&lt;!--    FactoryBean实例化 Bean--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user-by-factory-bean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.factory.UserFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> User <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token keyword">return</span> User<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user-by-factory-bean"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="特殊的三种方式"><a href="#特殊的三种方式" class="headerlink" title="特殊的三种方式"></a>特殊的三种方式</h3><h4 id="通过ServiceLoaderFactoryBean"><a href="#通过ServiceLoaderFactoryBean" class="headerlink" title="通过ServiceLoaderFactoryBean"></a>通过ServiceLoaderFactoryBean</h4><ol>
<li>创建META-INF/Services文件夹</li>
<li>在这个文件夹下面创建一个文件，文件名是接口的全类名</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-16_09-25-59.png"></p>
<ol start="3">
<li>把这个接口的实现类逐一的写入这个文件中，不要写id，只需要类名</li>
</ol>
<pre><code>com.asia.factory.DefaultFactory</code></pre>
<p>使用方式一：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">demoServiceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demoServiceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ServiceLoader<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> serviceLoader <span class="token operator">=</span>
        ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>UserFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> iterator <span class="token operator">=</span> serviceLoader<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      UserFactory userFactory <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果 User{age=27, name='AsiaMa'} */</span></code></pre>
<p>使用方式二：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userFactoryServiceLoader<span class="token punctuation">"</span></span>
          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>serviceType<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.factory.UserFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>
            <span class="token string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    ServiceLoader<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> userFactoryServiceLoader <span class="token operator">=</span>
        beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userFactoryServiceLoader"</span><span class="token punctuation">,</span> ServiceLoader<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">displayServiceLoader</span><span class="token punctuation">(</span>userFactoryServiceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayServiceLoader</span><span class="token punctuation">(</span>ServiceLoader<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> serviceLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Iterator<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> iterator <span class="token operator">=</span> serviceLoader<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      UserFactory userFactory <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果 User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过AutowireCapableBeanFactory"><a href="#通过AutowireCapableBeanFactory" class="headerlink" title="通过AutowireCapableBeanFactory"></a>通过AutowireCapableBeanFactory</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    ApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>
            <span class="token string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 通过 Application 获取 AutowireCapableBeanFactory</span>
    AutowireCapableBeanFactory beanFactory <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getAutowireCapableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建 UserFactory 对象， 通过 AutowireCapableBeanFactory</span>
    UserFactory userFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">createBean</span><span class="token punctuation">(</span>DefaultFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果 User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过BeanDefinitionRegistry"><a href="#通过BeanDefinitionRegistry" class="headerlink" title="通过BeanDefinitionRegistry"></a>通过BeanDefinitionRegistry</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    GenericXmlApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericXmlApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 通过BeanDefinition注册API实现</span>
    <span class="token comment" spellcheck="true">// 命名Bean的注册方式</span>
    <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">,</span> <span class="token string">"asia-user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非命名Bean的注册方式</span>
    <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>
            <span class="token string">"User 类型的所有beans"</span> <span class="token operator">+</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanDefinitionBuilder beanDefinitionBuilder <span class="token operator">=</span>
            BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">addPropertyValue</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">addPropertyValue</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"AsiaMa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 判断如果BeanName参数存在时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 注册BeanDefinition</span>
      registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      BeanDefinitionReaderUtils<span class="token punctuation">.</span><span class="token function">registerWithGeneratedName</span><span class="token punctuation">(</span>
              beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User 类型的所有beans{
            asia-user=User{age=27, name='AsiaMa'}, 
            com.asia.User#0=User{age=27, name='AsiaMa'}} */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin常用作用域函数</title>
    <url>/posts/c396.html</url>
    <content><![CDATA[<h3 id="let-和-run"><a href="#let-和-run" class="headerlink" title="let 和 run"></a>let 和 run</h3><p>let 和 run 都会返回闭包的执行结果，区别在于let有闭包参数，而run没有闭包参数。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> letResult<span class="token operator">:</span> String <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> user<span class="token operator">:</span> User <span class="token operator">-></span>
        <span class="token string">"let:: <span class="token interpolation"><span class="token delimiter variable">${</span>user<span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span>
    <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">/** 
         简化写法
         val letResult: String = user.let {
        "let:: ${it.javaClass.simpleName}"
    } 
   */</span>

    <span class="token function">println</span><span class="token punctuation">(</span>letResult<span class="token punctuation">)</span>

    <span class="token keyword">val</span> runResult <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">run</span> <span class="token punctuation">{</span>
        <span class="token string">"run:: <span class="token interpolation"><span class="token delimiter variable">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span>runResult<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果：let:: User
                         run:: User */</span></code></pre>
<h3 id="also-和-apply"><a href="#also-和-apply" class="headerlink" title="also 和 apply"></a>also 和 apply</h3><p>also与apply都不返回闭包的执行结果，区别在于also有闭包参数，而apply没有闭包参数。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    user<span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"also::<span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    user<span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"apply::<span class="token interpolation"><span class="token delimiter variable">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 在这个例子中，also 和 apply 会继续返回user这个对象，因为我们可以这么使用</span>
        user<span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"also::<span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"apply::<span class="token interpolation"><span class="token delimiter variable">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Bob"</span>

    <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">/** 输出结果：User(name=Bob) */</span></code></pre>
<h3 id="takeIf-和-takeUnless"><a href="#takeIf-和-takeUnless" class="headerlink" title="takeIf 和 takeUnless"></a>takeIf 和 takeUnless</h3><p>takeIf 的闭包返回一个判断结果，为false时，takeIf函数会返回空。</p>
<p>takeUnless 与 takeIf 刚好相反，闭包的判断结果，为true时函数会返回空。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    user<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{</span>
        it<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为: <span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?:</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为空"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：姓名为: AsiaMa */</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    user<span class="token punctuation">.</span><span class="token function">takeUnless</span> <span class="token punctuation">{</span>
        it<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为: <span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?:</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为空"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：姓名为: AsiaMa */</span></code></pre>
<h3 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h3><p>重复执行当前闭包</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/**
输出结果：
    AsiaMa0
    AsiaMa1
    AsiaMa2
    AsiaMa3
    AsiaMa4
*/</span></code></pre>
<h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><p>with比较特殊，不是以扩展方法的形式存在，而是一个顶级函数。可用于对象的通用属性赋值。</p>
<pre class=" language-java"><code class="language-java">fun <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    val user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    <span class="token function">with</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Tom"</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>

  <span class="token comment" spellcheck="true">/** 与with相似    
    user.apply {
        this.name = "Rose"
    }
  */</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User(name=Tom) */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>复制、删除表和记录</title>
    <url>/posts/cdcc.html</url>
    <content><![CDATA[<h3 id="复制表的列结构和记录"><a href="#复制表的列结构和记录" class="headerlink" title="复制表的列结构和记录"></a>复制表的列结构和记录</h3><pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE 新表名 SELECT * FROM 元表名</code></pre>
<p>使用 “SELECT * FROM …” 的结果执行 CREATE TABLE。这样在创建表的同时也复制了记录。可以使用 WHERE 或者 LIMIT 来限定要提取的记录，还可以只对需要的记录进行复制。</p>
<p>但是这种方法不能复制 AUTO_INCREMENT 等属性。 AUTO_INCREMENT 等属性需要在复制后再进行设置。还可能存在不复制元表的索引等情况。所以在执行完复制操作后，请用 DESC 确认表的结构，然后再使用该表。</p>
<h3 id="仅复制表的列结构"><a href="#仅复制表的列结构" class="headerlink" title="仅复制表的列结构"></a>仅复制表的列结构</h3><p>在 CREATE TABLE 命令的表名后面加上 <strong>LIKE</strong> 指定复制的元表。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE 新表名 LIKE 元表名</code></pre>
<p>该方法也会复制 AUTO_INCREMENT 和 PRIMARY KEY 等列的属性。这是一种不复制记录，只复制列结构的方法。</p>
<h3 id="复制其它表的记录"><a href="#复制其它表的记录" class="headerlink" title="复制其它表的记录"></a>复制其它表的记录</h3><pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO 表名 SELECT * FROM 元表名</code></pre>
<h3 id="选择某一列进行复制"><a href="#选择某一列进行复制" class="headerlink" title="选择某一列进行复制"></a>选择某一列进行复制</h3><p>我们可以从元表中选择某一列的记录进行复制。例如下面的示例中就展示了如何向表 tb1_bkc 的姓名列 name 中插入表 tb1 的列 empid 的记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO tb1_bkc(name) SELECT empid FROM tb1;</code></pre>
<p>在这种情况下，因为列 empid 和 列name 的数据类型都是 VARCHAR(10)，所以命令的执行没有任何问题。但是，如果数据类型不一致，复制操作就可能会失败，这一点需要大家注意。</p>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre class=" language-mysql"><code class="language-mysql">$ DROP TABLE 表名;</code></pre>
<p>删除后，再也不能回到原来的状态了。在执行 DROP 的命令时一定要谨慎。</p>
<h3 id="当目标表存在时将其删除"><a href="#当目标表存在时将其删除" class="headerlink" title="当目标表存在时将其删除"></a>当目标表存在时将其删除</h3><pre class=" language-mysql"><code class="language-mysql">$ DROP TABLE IF EXISTS tb1;</code></pre>
<p>一般来说，在目标表不存在的情况下执行 DROP 命令会发生错误，但如果加上了 IF EXISTS，就能够抑制错误的发生。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre class=" language-mysql"><code class="language-mysql">$ DROP DATABASE 数据库名;</code></pre>
<p>执行上面的命令后，数据库就无法恢复到原来的状态了。包括表在内的所有信息都将消失，这一点需要特别注意。</p>
<h3 id="删除所有记录"><a href="#删除所有记录" class="headerlink" title="删除所有记录"></a>删除所有记录</h3><pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM 表名;</code></pre>
<blockquote>
<p><strong>不使用 MySQL 监视器操作 MySQL</strong></p>
<p>我们可以直接从命令提示符或终端来操作 MySQL。</p>
<ul>
<li>使用 mysqladmin 命令创建和删除数据库</li>
</ul>
<p>MySQL 里提供了一个名为 mysqladmin 的强大命令来创建数据库。我们可以执行 mysqladmin 命令创建数据库。这个命令不是 MySQL 监视器的命令，所以直接从命令提示符或终端输入。</p>
<pre class=" language-mysql"><code class="language-mysql"># 创建数据库
$ mysqladmin -u 用户名 -p密码 CREATE 数据库名
# 删除数据库
$ mysqladmin -u 用户名 -p密码 DROP 数据库名</code></pre>
<ul>
<li>使用 mysql 命令执行查询</li>
</ul>
<p>虽然只要使用 mysql 就能启动 MySQL 监视器，但是也可以不启动 MySQL 的情况下直接执行 SQL 语句。在这种情况下，需要加上 -e 选项，并且中 “” 将后面的命令括起来。注意不是用单引号（’’）。而使用双引号（””）把命令括起来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ mysql 数据库名 -u 用户名 -p密码 -e "命令"
# 例子
$mysql db1 -u root -p123456 -e "SELECT * FROM tb1"</code></pre>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>层次性依赖查找</title>
    <url>/posts/e798.html</url>
    <content><![CDATA[<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>superUser<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.domain.SuperUser<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">primary</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>北京<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.domain.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>金士顿快乐健康<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>objectFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>targetBeanName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperUser</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HierarchicalDependencyLookupDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册配置类</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>HierarchicalDependencyLookupDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// ConfigurableListableBeanFactory -> ConfigurableBeanFactory -> HierarchicalBeanFactory</span>
    ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 设置 Parent BeanFactory</span>
    DefaultListableBeanFactory parentBeanFactory <span class="token operator">=</span> <span class="token function">createBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    beanFactory<span class="token punctuation">.</span><span class="token function">setParentBeanFactory</span><span class="token punctuation">(</span>parentBeanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">displayLocalBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">displayLocalBean</span><span class="token punctuation">(</span>parentBeanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">displayContainsBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">displayContainsBean</span><span class="token punctuation">(</span>parentBeanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayContainsBean</span><span class="token punctuation">(</span>HierarchicalBeanFactory beanFactory<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>
        <span class="token string">"当前 BeanFactory 是否包含 bean [name : %s] : %s \n"</span><span class="token punctuation">,</span>
        beanName<span class="token punctuation">,</span> <span class="token function">containsBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">containsBean</span><span class="token punctuation">(</span>HierarchicalBeanFactory beanFactory<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory parentBeanFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token keyword">instanceof</span> <span class="token class-name">HierarchicalBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      HierarchicalBeanFactory parentHierarchicalBeanFactory <span class="token operator">=</span>
          <span class="token punctuation">(</span>HierarchicalBeanFactory<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token function">containsBean</span><span class="token punctuation">(</span>parentHierarchicalBeanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">containsLocalBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayLocalBean</span><span class="token punctuation">(</span>HierarchicalBeanFactory beanFactory<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>
        <span class="token string">"当前 BeanFactory 是否包含 Local bean [name : %s] : %s \n"</span><span class="token punctuation">,</span>
        beanName<span class="token punctuation">,</span> beanFactory<span class="token punctuation">.</span><span class="token function">containsLocalBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> DefaultListableBeanFactory <span class="token function">createBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    DefaultListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    XmlBeanDefinitionReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XmlBeanDefinitionReader</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// XML 配置文件 ClassPath 路径</span>
    String location <span class="token operator">=</span> <span class="token string">"classpath:/META-INF/dependency-lookup-context.xml"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 加载配置</span>
    reader<span class="token punctuation">.</span><span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> beanFactory<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    当前 BeanFactory 是否包含 Local bean [name : user] : false 
    当前 BeanFactory 是否包含 Local bean [name : user] : true 
    当前 BeanFactory 是否包含 bean [name : user] : true 
    当前 BeanFactory 是否包含 bean [name : user] : true */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟初始化 Spring Bean</title>
    <url>/posts/861c.html</url>
    <content><![CDATA[<h3 id="Bean延迟初始化-（Lazy-Initialization）"><a href="#Bean延迟初始化-（Lazy-Initialization）" class="headerlink" title="Bean延迟初始化 （Lazy Initialization）"></a>Bean延迟初始化 （Lazy Initialization）</h3><ul>
<li>XML配置：&lt;bean lazy-init=”true”&gt;</li>
<li>Java注解：@Lazy(true)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略 getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册Configuration Class (配置类)</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非延迟初始化在 Spring 应用上下文启动完成后，被初始化</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Spring 应用上下文已启动..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Employee employee <span class="token operator">=</span> annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token annotation punctuation">@Lazy</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    Spring 应用上下文已启动...
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    com.asia.Employee@19dc67c2 */</span>

<span class="token comment" spellcheck="true">//非延迟初始化 @Lazy(value = false)</span>
    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token annotation punctuation">@Lazy</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    Spring 应用上下文已启动...
    com.asia.Employee@19dc67c2 */</span></code></pre>
<p>其实延迟加载和非延迟加载在定义的时候，也就是Bean注册的时候是没有区别的，按照你的需要来注册，但是在依赖查找和依赖注入的时候，它的区别就体现出来了。非延迟查找是在上下文初始化完成之前，就已经初始化了；延迟加载必须在上下文初始化完成之后来进行加载。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>探讨复杂的 if-else 语句“优雅处理”的思路</title>
    <url>/posts/afc9.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际开发中，往往不是简单 if-else 结构，我们通常会不经意间写下如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// -------------------- 理想中的 if-else  --------------------</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isWeekend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"玩游戏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上班!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// -------------------- 现实中的 if-else  --------------------</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黄金会员 8折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> money <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白金会员 优惠50元，再打7折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> <span class="token punctuation">(</span>money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//省略 n 个 if-else ......</span></code></pre>
<p>毫不夸张的说，我们都写过类似的代码，回想起被 if-else 支配的恐惧，我们常常无所下手，甚至不了了之。</p>
<p>下面分享一下我遇到复杂的 if-else 语句“优雅处理”思路。如有不妥，欢迎大家一起交流学习。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>假设有这么一个需求：</p>
<p>一个电商系统，当用户消费满1000 金额，可以根据用户VIP等级，享受打折优惠。根据用户VIP等级，计算出用户最终的费用。</p>
<ul>
<li>普通会员 不打折</li>
<li>白银会员 优惠50元</li>
<li>黄金会员 8折</li>
<li>白金会员 优惠50元，再打7折</li>
</ul>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> result <span class="token operator">=</span> money<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黄金会员 8折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> money <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白金会员 优惠50元，再打7折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> <span class="token punctuation">(</span>money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> money<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>为了方便演示，代码上我进行了简单实现，但实际上 if - else 会进行复杂的逻辑计费。从功能上来说，基本完成，但是对于我这种有代码洁癖的人来说，代码质量上不忍直视。我们开始着手 优化一下我们的第一版代码吧。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>看到如上代码，聪明的朋友首先想到的是，这不是典型的策略模式吗？</p>
<p>你可真是个机灵鬼，我们先尝试用策略模式来优化一下代码吧。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>可能有的朋友还不清楚，什么是策略模式。策略模式是定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p>比如上述需求，有返利、有打折、有折上折等等。这些算法本身就是一种策略。并且这些算法可以相互替换的，比如今天我想让 白银会员优惠50，明天可以替换为 白银会员打9折。</p>
<p>说了那么多，不如编码来得实在。</p>
</blockquote>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 计费方法</span>
    <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 普通会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrdinaryStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 白银会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SilverStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 黄金会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GoldStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span><span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黄金会员 8折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 白金会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlatinumStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白金会员 优惠50元，再打7折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>我们定义来一个 Strategy 接口，并且定义 四个子类，实现接口。在对应的 compute方法 实现自身策略的计费逻辑。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> result <span class="token operator">=</span> money<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SilverStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GoldStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlatinumStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrdinaryStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>然后对应 getResult 方法，根据 type 替换为对应的 用户VIP 策略。这里代码上出现了重复的调用 compute ，我们可以尝试进一步优化</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Strategy strategy<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SilverStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GoldStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlatinumStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrdinaryStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们在这里把 money &lt; 1000 的情况提前 return。更关注于满1000逻辑 ,也可以减少不必要的缩进。</p>
<h3 id="深思"><a href="#深思" class="headerlink" title="深思"></a>深思</h3><p>我曾一度 以为 策略模式不过如此。以为代码优化到这已经可以了。</p>
<p>但是还有一个恐怖的事情，if-else 依然存在 ：）</p>
<p>我尝试翻阅了许多书籍，查看如何消除 策略模式中的 if-else</p>
<p>书中大部分的方法是，使用简单工厂 + 策略模式。把 if - else 切换为 switch 创建一个工厂方法而已。</p>
<p>但是这远远没有达到我想要的效果，打倒 if - else</p>
<p>直到某一天夜里，我大佬在群里分享一个 Java8 小技巧时，从此打开新世界。</p>
<h3 id="工厂-策略"><a href="#工厂-策略" class="headerlink" title="工厂 + 策略"></a>工厂 + 策略</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 返回 type</span>
    <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrdinaryStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 添加 type 返回</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SilverStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// type 返回</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//....省略剩下 Strategy</span></code></pre>
<p>我们先在 Strategy 新增一个 getType 方法，用来表示 该策略的 type 值。代码相对简单，这里就不过多介绍了</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyFactory</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Strategy<span class="token operator">></span> map<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">StrategyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        List<span class="token operator">&lt;</span>Strategy<span class="token operator">></span> strategies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OrdinaryStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SilverStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GoldStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PlatinumStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 看这里 看这里 看这里！</span>
        map <span class="token operator">=</span> strategies<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>Strategy<span class="token operator">:</span><span class="token operator">:</span>getType<span class="token punctuation">,</span> strategy <span class="token operator">-</span><span class="token operator">></span> strategy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* 等同上面
        map = new HashMap&lt;>();
        for (Strategy strategy : strategies) {
            map.put(strategy.getType(), strategy);
        }*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> StrategyFactory instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StrategyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> StrategyFactory <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Holder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Strategy <span class="token function">get</span><span class="token punctuation">(</span>Integer type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>静态内部类单例，单例模式实现的一种，不是本文重点，如不了解，可以自行 google</p>
<p>我们再着手创建一个 StrategyFactory 工厂类。StrategyFactory 这里我使用的是静态内部类单例，在构造方法的时候，初始化好 需要的 Strategy，并把 list 转化为 map。</p>
<p>这里 转化就是“灵魂”所在。</p>
<h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><p>我们先来看看 Java8 语法中的小技巧。通常情况下，我们遍历 List，手动put到 Map 中。</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>  before <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Strategy strategy <span class="token operator">:</span> strategies<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>strategy<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>  after Java8 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

map <span class="token operator">=</span> strategies<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>Strategy<span class="token operator">:</span><span class="token operator">:</span>getType<span class="token punctuation">,</span> strategy <span class="token operator">-</span><span class="token operator">></span> strategy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>toMap 第一个参数是一个Function，对应 Map 中的 key，第二个参数也是一个Function，strategy -&gt; strategy， 左边strategy 是遍历 strategies 中的每一个strategy，右边strategy则是 Map 对应 value 值。</p>
<p>若是不了解 Java8 语法的朋友，强烈建议看 《Java8 实战》，书中详细的介绍了 Lambda表达式、Stream等语法。</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Strategy strategy <span class="token operator">=</span> StrategyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>strategy <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"please input right type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>至此，通过一个工厂类，在我们在 getResult（）调用的时候，根据传入 type，即可获取到 对应 Strategy</p>
<p>再也没有可怕的 if-else 语句。</p>
<p>完结撒花撒花 : )</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续代码优化上，若是 Java 项目，可以尝试使用自定义注解，注解 Strategy 实现类。</p>
<p>这样可以简化原来需在工厂类 List 添加一个 Stratey 策略。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略</tag>
        <tag>工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>测试多线程上下文切换</title>
    <url>/posts/2067.html</url>
    <content><![CDATA[<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>即使是单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。时间片是 CPU 分配给各个线程的时间，因为时间片非常短，所以 CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。</p>
<p>CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下回切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<p>这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是便打开中英文词典，但是在放下英文技术书之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。</p>
<h3 id="多线程一定快吗"><a href="#多线程一定快吗" class="headerlink" title="多线程一定快吗"></a>多线程一定快吗</h3><p>下面的代码演示串行和并发执行并累计操作的时间，请分析：下面的代码并发执行一定比串行快吗？</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> count <span class="token operator">=</span> 1000001L<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token function">concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">serial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread t <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
              <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                a <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      b<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">double</span> time <span class="token operator">=</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1E6</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"concurrency: "</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">"ms, b = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">serial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      a <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      b<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">double</span> time <span class="token operator">=</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1E6</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"serial: "</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">"ms, b = "</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">", a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    concurrency: 68.555391ms, b = -1000001
    serial: 5.589674ms, b = -1000001, a = 5000005 */</span></code></pre>
<p>测试结果如下所示：</p>
<table>
<thead>
<tr>
<th>循环次数</th>
<th>串行执行耗时 /ms</th>
<th>并发执行耗时 /ms</th>
<th>并发比串行快多少</th>
</tr>
</thead>
<tbody><tr>
<td>10亿</td>
<td>724.332455ms</td>
<td>391.188627ms</td>
<td>约 1 倍</td>
</tr>
<tr>
<td>1亿</td>
<td>71.894395ms</td>
<td>87.138227ms</td>
<td>差不多</td>
</tr>
<tr>
<td>1千万</td>
<td>10.201172ms</td>
<td>48.001412ms</td>
<td>慢</td>
</tr>
<tr>
<td>1百万</td>
<td>5.589674ms</td>
<td>68.555391ms</td>
<td>慢</td>
</tr>
<tr>
<td>十万</td>
<td>1.783637ms</td>
<td>40.619798ms</td>
<td>慢</td>
</tr>
</tbody></table>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><p>减少上下文切换的方法有无锁并发编程、CAS 算法、使用最少线程和使用协程。</p>
<ul>
<li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS 算法。Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。</li>
<li>使用最少的线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处理等待状态。</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
<h3 id="减少上下文切换实战"><a href="#减少上下文切换实战" class="headerlink" title="减少上下文切换实战"></a>减少上下文切换实战</h3><p>下面将通过减少线上大量的 WAITING 的线程，来减少上下文切换次数。</p>
<p><strong>第一步</strong>：用 jstack 命令查看 dump 线程信息，看看 pid 为 37772 的进程里的线程都在做什么。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> -u admin /usr/bin/jstack 37772 <span class="token operator">></span> /Users/asiama/dump17</code></pre>
<p><strong>第二步</strong>：统计所有线程分别处于什么状态，发现 300 多个线程处理 WAITING (onobject-monitor) 状态</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> java.lang.Thread.State /Users/asiama/dump17 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span><span class="token variable">$3</span><span class="token variable">$4</span><span class="token variable">$5</span>}'</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c
    39 RUNNABLE
  21 TIMED_WAITING<span class="token punctuation">(</span>onobjectmonitor<span class="token punctuation">)</span>
   6 TIMED_WAITING<span class="token punctuation">(</span>parking<span class="token punctuation">)</span>
  51 TIMED_WAITING<span class="token punctuation">(</span>sleeping<span class="token punctuation">)</span>
 305 WAITING<span class="token punctuation">(</span>onobjectmonitor<span class="token punctuation">)</span>
   3 WAITING<span class="token punctuation">(</span>parking<span class="token punctuation">)</span></code></pre>
<p><strong>第三步</strong>：打开 dump 文件查看处于 WAITING (onobjectmonitor) 的线程在做什么。发现这些线程基本全是 JBOSS 的工作线程，在 await。说明 JBOSS 线程池里线程接收到的任务太少，大量线程都闲着。</p>
<p><strong>第四步</strong>：减少 JBOSS 的工作线程数，找到 JBOSS 的线程池配置信息，将 maxThreads 降到 100。</p>
<pre class=" language-xml"><code class="language-xml">&lt;maxThreads="250" maxHttpHeaderSize="8192" ... /></code></pre>
<p><strong>第五步</strong>：重启 JBOSS，再 dump 线程信息，然后统计 WAITING （onobjectmonitor）的线程，发现减少了 175  个。WAITING 线程少了，系统上下文切换的次数就会少，因为每一次从 WAITING 到 RUNNABLE 都会进行一次上下文的切换。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>熟练使用事务</title>
    <url>/posts/8c7e.html</url>
    <content><![CDATA[<h3 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h3><p>在学习事务之前，我们需要了解一下 MySQL 中的<strong>存储引擎</strong>。</p>
<p>MySQL 的功能大致分为两种。</p>
<p>一个是连接客户端和提前检查 SQL 语句内容的功能，即数据库处理的 “前台” 部分。另一个是根据前台部分指示，完成查询和文件操作等工作的功能，即 “后台” 部分。这个后台部分称为存储引擎。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-28_11-39-03.png" style="zoom:67%;">

<h4 id="存储引擎的种类"><a href="#存储引擎的种类" class="headerlink" title="存储引擎的种类"></a>存储引擎的种类</h4><p>MySQL 中预置了多个存储引擎，用户可以根据使用目的和个人喜好进行选择。另外每个表都可以单独执行存储引擎。</p>
<p>目前 MySQL 中可以使用的存储引擎主要有以下几张：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>以前版本中的默认存储引擎。虽然能够高速运行，但不支持事务和外键。</td>
</tr>
<tr>
<td>InnoDB</td>
<td>MySQL 5.5 或更高版本的默认存储引擎。是唯一一个支持事务的存储引擎。</td>
</tr>
<tr>
<td>BLACKHOME</td>
<td>写入的任何数据都会消失，查询始终返回空结果。主要用于复制。</td>
</tr>
<tr>
<td>MERGE</td>
<td>将多个 MyISAM 表作为一个表处理，也称为 MRG_MyISAM。</td>
</tr>
<tr>
<td>CSV</td>
<td>将数据的实体保存为CSV(逗号分隔) 格式的文本文件。该文件可以通过 Excel 等打开。</td>
</tr>
<tr>
<td>MEMORY</td>
<td>因为数据全部存储了内存中，所以处理速度非常快。主要作为从临时工作区和其它表中提取的数据的读取专用缓存使用。不支持事务。</td>
</tr>
<tr>
<td>ARCHIVE</td>
<td>虽然可以通过压缩来存储大量数据，但是仅支持 INSERT 和 SELECT。</td>
</tr>
</tbody></table>
<p>到 MySQL 5.4 为止的版本中，默认存储引擎是 MyISAM。虽然 MyISAM 比当时的 InnoDB 的处理速度快，但遗憾的是它不支持事务。因此，当时也出现了 “不使用事务的话就选 MyISAM，使用事务的话就选 InnoDB” 这样的使用方式。但现在 InnoDB 的处理速度也变的很快了，所以我们不需要考虑 MyISAM。</p>
<p>如果使用方法比较复杂，就需要对每一个存储引擎进行更为细致的调优，同时还有研究新的存储引擎。</p>
<h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><h4 id="确认存储引擎"><a href="#确认存储引擎" class="headerlink" title="确认存储引擎"></a>确认存储引擎</h4><pre class=" language-mysql"><code class="language-mysql">$ SHOW CREATE TABLE 表名;</code></pre>
<h4 id="显示当前可用的存储引擎"><a href="#显示当前可用的存储引擎" class="headerlink" title="显示当前可用的存储引擎"></a>显示当前可用的存储引擎</h4><pre class=" language-mysql"><code class="language-mysql">$ SHOW ENGINES \G</code></pre>
<h4 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h4><pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE 表名 ENGINE = MyISAM;</code></pre>
<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>将多个操作作为单个逻辑工作单元的处理的功能称为<strong>事务（transaction）</strong>。将事务开始之后的处理结果反映到数据库中的操作称为<strong>提交（commit）</strong>，不反映到数据库而是恢复为原来状态的操作称为<strong>回滚（rollback）</strong>。</p>
<h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><pre class=" language-mysql"><code class="language-mysql">$ START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)</code></pre>
<p>下面试着删除表 tb 中所有的记录</p>
<pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM tb;
Query OK, 12 rows affected (0.00 sec)</code></pre>
<p>因为没有加上 WHERE 等条件，所以表 tb 中的所有记录都会被删除。</p>
<p>此时表的一部分会加锁（lock）。因此，在其它会话中不能对该表执行 INSERT 等操作。假设这时我们再启动一个命令提示符，并在 MySQL 监视器上对表 tb 执行 INSERT。在这种情况下，只有在开启了事务的监视器执行了 “COMMIT;” 或 “ROLLBACK;”，才能进行其它的会话处理。</p>
<h4 id="确认表的内容"><a href="#确认表的内容" class="headerlink" title="确认表的内容"></a>确认表的内容</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb;
Empty set (0.00 sec)</code></pre>
<h4 id="回滚复原"><a href="#回滚复原" class="headerlink" title="回滚复原"></a>回滚复原</h4><pre class=" language-mysql"><code class="language-mysql">$ ROLLBACK;

$ SELECT * FROM tb;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A107  |    87 |     6 |
| A103  |    12 |     6 |
| A104  |    93 |     5 |
| A102  |   205 |     6 |
| A101  |   300 |     5 |
| A103  |    17 |     5 |
| A101  |   184 |     4 |
| A104  |   181 |     4 |
| A102  |    54 |     5 |
| A103  |   101 |     4 |
+-------+-------+-------+
10 rows in set (0.00 sec)</code></pre>
<p>在上面的示例中，如果执行 “COMMIT;”  代替 “ROLLBACK;”，删除记录的结果就会提交（反映）到数据库中， 所有的记录都会被永久删除。</p>
<blockquote>
<p><strong>提示</strong>    DROP 等命令是不能执行回滚操作的（无法复原）。这一点需要大家注意。</p>
</blockquote>
<h3 id="自动提交功能"><a href="#自动提交功能" class="headerlink" title="自动提交功能"></a>自动提交功能</h3><p>在 MySQL 中执行命令，处理通常会直接提交。也就是说，所有命令都会自动 COMMIT。特别是在 MySQL 5.5 之前默认使用的 MyISAM 中，由于没有事务这项功能，所有命令都会被提交。这种自动提交的功能，称为 “自动提交功能”。</p>
<p>在默认状态下，自动提价功能处于开启状态。但是，当存储引擎为 InnoDB 时，如果执行了 START TRANSACTION（或 BEGIN），在执行 COMMIT 命令之前就不会提交。多亏了这个功能，回滚操作（ROLLBACK） 才得以执行。</p>
<p>用户也可以强制将自动提交功能设置为关闭。如果关闭了自动提交功能，即使执行 SQL 语句也不会自动提交，必须通过 COMMIT 进行提交，或者通过 ROLLBACK 进行复原。</p>
<h4 id="关闭自动提交功能"><a href="#关闭自动提交功能" class="headerlink" title="关闭自动提交功能"></a>关闭自动提交功能</h4><pre class=" language-mysql"><code class="language-mysql">$ SET AUTOCOMMIT = 0;</code></pre>
<p>执行下面命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO tb VALUES('test', 555, 555);
Query OK, 1 row affected (0.00 sec)

$ SELECT * FROM tb;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A107  |    87 |     6 |
| A103  |    12 |     6 |
| A104  |    93 |     5 |
| A102  |   205 |     6 |
| A101  |   300 |     5 |
| A103  |    17 |     5 |
| A101  |   184 |     4 |
| A104  |   181 |     4 |
| A102  |    54 |     5 |
| A103  |   101 |     4 |
| test  |   555 |   555 |
+-------+-------+-------+
11 rows in set (0.00 sec)</code></pre>
<p>接下来进行 ROLLBACK，刚刚 INSERT 的记录就不会显示出来了。</p>
<pre class=" language-mysql"><code class="language-mysql">mysql> ROLLBACK;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM tb;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A107  |    87 |     6 |
| A103  |    12 |     6 |
| A104  |    93 |     5 |
| A102  |   205 |     6 |
| A101  |   300 |     5 |
| A103  |    17 |     5 |
| A101  |   184 |     4 |
| A104  |   181 |     4 |
| A102  |    54 |     5 |
| A103  |   101 |     4 |
+-------+-------+-------+
10 rows in set (0.00 sec)</code></pre>
<p>可以看到数据没有自动提交。要想提交实际修改的数据，必须执行 “COMMIT”。</p>
<h4 id="启动已关闭的自动提交功能"><a href="#启动已关闭的自动提交功能" class="headerlink" title="启动已关闭的自动提交功能"></a>启动已关闭的自动提交功能</h4><pre class=" language-mysql"><code class="language-mysql">$ SET AUTOCOMMIT = 1;</code></pre>
<blockquote>
<p><strong>如何确认当前自动提交功能的模式</strong>    我们可以通过 SELECT @@AUTOCOMMIT 确认当前自动提价功能的模式。如果是开启状态，则显示为 “1”；如果是关闭状态，则显示为 “0”。</p>
</blockquote>
<h4 id="事务的使用范围"><a href="#事务的使用范围" class="headerlink" title="事务的使用范围"></a>事务的使用范围</h4><p>启用事务之后，并不是所有操作都可以通过回滚复原。例如，下面这些命令就会被自动提交。</p>
<ul>
<li>DROP DATABSE</li>
<li>DROP TABLE</li>
<li>DROP VIEW</li>
<li>ALTER TABLE</li>
</ul>
<p>即使开启了事务也有不能复原的情况，这一点需要注意。</p>
<blockquote>
<p><strong>提示</strong>    如果没有提交事务就退出 MySQL 监视器，修改的内容就会作废。也就是说，如果在未提交事务的情况下关闭连接，事务将自动回滚。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>熟练使用视图</title>
    <url>/posts/76dd.html</url>
    <content><![CDATA[<h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><h4 id="视图的真面目"><a href="#视图的真面目" class="headerlink" title="视图的真面目"></a>视图的真面目</h4><p>前面我们学习了多种使用 SELECT 提取纪录的方法。将 SELECT 的结果像表一样保留下来的虚表就是视图。</p>
<p>视图不是表。因此，视图中并没有保存记录或者列中的数据。也会说，视图是一种信息，用于查询记录。</p>
<h4 id="视图的用途"><a href="#视图的用途" class="headerlink" title="视图的用途"></a>视图的用途</h4><p>视图虽然看起来像表，但它没有实体，只是一种信息。视图的便利之处在于，用户可以按照想要的条件收集某表中某列的数据。</p>
<p>之前那种通过设置条件从表中提取记录的做法非常麻烦。如果相同的提出操作以视图的方式执行，就可以将视图作为符合用户个人喜好的表来使用。</p>
<p>从用户的角度来看，视图和表使用上并没有区别。和表一样，视图也可以进行 SELECT 和 UPDATE。如果更新视图的记录，基表的记录也会更新。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/2021-01-27_19-05-07.png" style="zoom:87%;">

<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><pre class=" language-mysql"><code class="language-mysql">$ CREATE VIEW 视图名 AS SELECT 列名 FROM 表名 WHERE 条件;</code></pre>
<p>上面的语句表示 “对 SELECT 的记录 CREATE VIEW（视图）”。不要忘记在 SELECT 的前面加上 AS。</p>
<p>上述语句中的 “ WHERE 条件”，实际上也可以 换成 ORDER BY、LIMIT 和 JOIN 等。总之，要在某些条件下选择列，创建虚拟的表。也就是将前面执行的许多 SELECT 结果通过 CREATE VIEW … AS 创建为视图。</p>
<p>员工信息表 tb1 由员工号（empid）、姓名（name）和年龄（age）组成。试着创建没有员工号、只包含姓名和年龄这两个列的视图。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE VIEW v1 
          AS
  SELECT name, age 
          FROM tb1;

$ SELECT * FROM v1;
+--------+------+
| name   | age  |
+--------+------+
| 佐腾   |   40 |
| 高桥   |   28 |
| 中川   |   20 |
| 渡边   |   23 |
| 西泽   |   35 |
+--------+------+
5 rows in set (0.01 sec)</code></pre>
<p>这次我们只从一个表中提取了列，实际上也可以使用多个表，通过设置条件来提取想要的内容。</p>
<h4 id="通过视图更新列的值"><a href="#通过视图更新列的值" class="headerlink" title="通过视图更新列的值"></a>通过视图更新列的值</h4><p>视图只显示了基表的一部分。因此，如果更新了基表的值，收集并显示基表值的视图的值也会更新。</p>
<p>那么，如果更新了视图的值，基表的值又会怎样呢？实际上，视图不仅是基表的一部分，它也是指向基表数据的窗口。因此，如果更新视图的值，基表的值也会随之更新。</p>
<p>我们来试着更新一下视图 v1 的记录，看看视图的记录更新是否反映到了基表中。</p>
<pre class=" language-mysql"><code class="language-mysql">$ UPDATE v1 SET name = '主任·佐腾' WHERE name = '佐腾';

$ SELECT * FROM v1;
+----------------+------+
| name           | age  |
+----------------+------+
| 主任·佐腾      |   40 |
| 高桥           |   28 |
| 中川           |   20 |
| 渡边           |   23 |
| 西泽           |   35 |
+----------------+------+
5 rows in set (0.00 sec)

$ SELECt * FROM tb1;
+-------+----------------+------+
| empid | name           | age  |
+-------+----------------+------+
| A101  | 主任·佐腾      |   40 |
| A102  | 高桥           |   28 |
| A103  | 中川           |   20 |
| A104  | 渡边           |   23 |
| A105  | 西泽           |   35 |
+-------+----------------+------+
5 rows in set (0.00 sec)</code></pre>
<p>看来基表 tb1 的值也更新了。由此我们可以得知，如果更新视图的值，其基表的记录也会随之更新。</p>
<h3 id="设置条件创建视图"><a href="#设置条件创建视图" class="headerlink" title="设置条件创建视图"></a>设置条件创建视图</h3><p>我们将从两个表中提取纪录并通过 WHERE 设置条件来创建视图。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE VIEW v2 
            AS 
    SELECT tb.empid, tb1.name, tb.sales 
            FROM tb 
    JOIN tb1 
            USING(empid) 
    WHERE tb.sales >= 100;

$ SELECT * FROM v2;
+-------+----------------+-------+
| empid | name           | sales |
+-------+----------------+-------+
| A103  | 中川           |   101 |
| A104  | 渡边           |   181 |
| A101  | 主任·佐腾      |   184 |
| A101  | 主任·佐腾      |   300 |
| A102  | 高桥           |   205 |
+-------+----------------+-------+
5 rows in set (0.01 sec)</code></pre>
<p>执行下面的命令</p>
<pre class=" language-mysql"><code class="language-mysql">$ UPDATE tb SET sales = 777 WHERE sales = 54;

$ SELECT * FROM v2;
+-------+----------------+-------+
| empid | name           | sales |
+-------+----------------+-------+
| A103  | 中川           |   101 |
| A102  | 高桥           |   777 |
| A104  | 渡边           |   181 |
| A101  | 主任·佐腾      |   184 |
| A101  | 主任·佐腾      |   300 |
| A102  | 高桥           |   205 |
+-------+----------------+-------+
6 rows in set (0.00 sec)</code></pre>
<p>可以看到视图 v2 的值也更新了。也就是说，在符合视图设置条件的情况下，如果基表更新，视图中的记录也会随之更新。设置了条件的视图始终会显示与条件相匹配的记录。</p>
<h4 id="确认视图"><a href="#确认视图" class="headerlink" title="确认视图"></a>确认视图</h4><pre class=" language-mysql"><code class="language-mysql">$ SHOW TABLE;</code></pre>
<p>视图会与表交织在一起显示出来。</p>
<p>和表一样，列结构可以通过 DESC 显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ DESC v2;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| empid | varchar(10)  | YES  |     | NULL    |       |
| name  | varchar(100) | YES  |     | NULL    |       |
| sales | int          | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.01 sec)</code></pre>
<p>显示视图的详细信息：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SHOW CREATE VIEW 视图名;</code></pre>
<h3 id="限制通过视图写入"><a href="#限制通过视图写入" class="headerlink" title="限制通过视图写入"></a>限制通过视图写入</h3><p>视图是用户从基表上随意收集的列。换句话说，作为视图可见的部分大多是基表中的一部分内容。对视图执行 INSERT 操作，就意味着只能向表中的一部分内容中插入数据。</p>
<p>前面介绍的有点啰嗦，用一句话概括就是对视图执行 INSERT 操作是有限制的。例如，在使用了 UNION、JOIN、子查询的视图中，不能执行 INSERT 。如果只是从一个表中提取了列，那么执行 INSERT 是没有任何问题的。</p>
<p>插入方法和向表中插入数据的方法相同。</p>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO v1 VALUES('临时工·石田', 18);
Query OK, 1 row affected (0.00 sec)

$ INSERT INTO v2 VALUES(null, 'AsiaMa', 28);
ERROR 1394 (HY000): Can not insert into join view 'db1.v2' without fields list

$ SELECT * FROM v1;
+-------------------+------+
| name              | age  |
+-------------------+------+
| 主任·佐腾         |   40 |
| 高桥              |   28 |
| 中川              |   20 |
| 渡边              |   23 |
| 西泽              |   35 |
| 临时工·石田       |   18 |
+-------------------+------+
6 rows in set (0.00 sec)</code></pre>
<p>姓名和年龄被完整地插入到了视图 v1 中。那么，视图 v1 的基表 tb1 会变成什么样呢？</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb1;
+-------+-------------------+------+
| empid | name              | age  |
+-------+-------------------+------+
| A101  | 主任·佐腾         |   40 |
| A102  | 高桥              |   28 |
| A103  | 中川              |   20 |
| A104  | 渡边              |   23 |
| A105  | 西泽              |   35 |
| NULL  | 临时工·石田       |   18 |
+-------+-------------------+------+
6 rows in set (0.00 sec)</code></pre>
<p>看来 “临时表·石田” 和 “18” 这两个数据都 INSERT 成功了。另外，对于在视图 v1 中没有被定义的列 empid，因为没有插入数据，所以输入了 NULL。</p>
<h4 id="设置了条件的基表中会发生什么变化"><a href="#设置了条件的基表中会发生什么变化" class="headerlink" title="设置了条件的基表中会发生什么变化"></a>设置了条件的基表中会发生什么变化</h4><p>如果在设置了条件的视图中插入违反条件的数据，基表会发生什么变化呢？</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE VIEW v3 
            AS 
    SELECT empid, sales 
            FROM tb 
    WHERE sales >= 100;

$ SELECT * FROM v3;
+-------+-------+
| empid | sales |
+-------+-------+
| A103  |   101 |
| A104  |   181 |
| A101  |   184 |
| A101  |   300 |
| A102  |   205 |
+-------+-------+
5 rows in set (0.01 sec)</code></pre>
<ul>
<li>插入不符合视图条件的记录</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO v3 VALUES('恶意刁难', 50);
Query OK, 1 row affected (0.01 sec)

$ SELECT * FROM v3;
+-------+-------+
| empid | sales |
+-------+-------+
| A103  |   101 |
| A104  |   181 |
| A101  |   184 |
| A101  |   300 |
| A102  |   205 |
+-------+-------+
5 rows in set (0.00 sec)</code></pre>
<p>视图 v3 看不到刚才插入的值，那么基表 tb 会变成什么样呢？</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb;
+--------------+-------+-------+
| empid        | sales | month |
+--------------+-------+-------+
| A103         |   101 |     4 |
| A102         |    54 |     5 |
| A104         |   181 |     4 |
| A101         |   184 |     4 |
| A103         |    17 |     5 |
| A101         |   300 |     5 |
| A102         |   205 |     6 |
| A104         |    93 |     5 |
| A103         |    12 |     6 |
| A107         |    87 |     6 |
| 恶意刁难     |    50 |  NULL |
+--------------+-------+-------+
11 rows in set (0.00 sec)</code></pre>
<p>基表 tb 中竟然插入了这个值！在默认情况下，WHERE 条件会被忽略，数据会 INSERT 到基表中。</p>
<h4 id="当与视图的条件不匹配时报错"><a href="#当与视图的条件不匹配时报错" class="headerlink" title="当与视图的条件不匹配时报错"></a>当与视图的条件不匹配时报错</h4><p>当通过视图 INSERT 记录时，即使与 WHERE 条件不匹配，数据也会直接输入到基表中。这是否意味着总是可以输入与 WHERE 条件不符的记录呢？</p>
<p>但是，对于有条件限制的视图，无视条件输入记录有时会带来一定的麻烦。另外，从视图中输入的记录无法在改视图中确认也是一件很麻烦的事。</p>
<p>为了应对这些情况，我们可以将视图设置成 “不接受与条件不匹配的记录”。为了防止输入与 WHERE 条件不匹配的记录，我们可以使用 CREATE VIEW 创建视图时，加上 WITH CHECK OPERON。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE VIEW v4 
            AS 
    SELECT empid, sales 
            FROM tb 
    WHERE sales >= 100
            WITH CHECK OPTION;

$ INSERT INTO v4 VALUES('恶意刁难', 50);
ERROR 1369 (HY000): CHECK OPTION failed 'db1.v4'</code></pre>
<p>这样就无法输入不符合条件的记录了。</p>
<h3 id="替换、修改和删除视图"><a href="#替换、修改和删除视图" class="headerlink" title="替换、修改和删除视图"></a>替换、修改和删除视图</h3><p>当执行 CREATE VIEW 时，如果已经有同名的视图存在，该命令报错。在这种情况下，可以像 “CREATE OR REPLACE VIEW …” 这样，加上 OR REPLACE 替换视图。也就是说，删除已经存在的同名的视图，创建新的视图。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE OR REPLACE VIEW v1 AS SELECT NOW();
</code></pre>
<h4 id="修改视图结构"><a href="#修改视图结构" class="headerlink" title="修改视图结构"></a>修改视图结构</h4><pre class=" language-mysql"><code class="language-mysql">$ ALTER VIEW 视图名 AS SELECT 列名 FROM 表名;</code></pre>
<p>与使用 “CREATE VIEW … AS SELECT” 创建视图的方法基本相同。</p>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><pre class=" language-mysql"><code class="language-mysql">$ DROP VIEW 视图名;</code></pre>
<p>如果视图不存在，该命令就会报错。可以执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql"># 目标视图不存在，只是不执行操作而已
$ DROP VIEW IF EXISTS v1;</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>熟练使用存储过程</title>
    <url>/posts/5d64.html</url>
    <content><![CDATA[<h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><p>将多个 SQL 语句组合成一个只需要使用命令 “CALL xx” 就能执行的集合，该集合就称为 <strong>存储过程（stored procedure）</strong>。“存储（store）表示保存，“过程” 表示步骤。也就是说，存储过程是将一系列步骤归纳并存储起来的集合。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_21-42-17.png" style="zoom:50%;">

<p>由于可以自动执行许多实现准备好的命令，所以处理效率很高。但是，在存储了重要数据的数据库中，执行没有经过充分验证的存储过程是非常危险的，这一点需要牢记。</p>
<p>存储过程乍一看让人觉得难以理解，但只要学会了它的使用方法，用起来就非常方便。</p>
<h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><p>当创建存储过程时，我们需要像下面这样执行 CREATE PROCEDURE 命令。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE PROCEDURE 存储过程名
    BEGIN
        SQL 语句1
        SQL 语句2
    END</code></pre>
<p>从 BEGIN 到 END 为止的内容是存储过程的主体。</p>
<p>在开头加上 BEGIN，在结尾加上 END，这么做可以明确表示 “这这里到这里是存储过程的命令”。</p>
<p>因为存储过程的内容是 “普通的 SQL 语句”，所以需要在命令的末尾添加分隔符 “;”。主体部分像下面这样：</p>
<pre class=" language-mysql"><code class="language-mysql">BEGIN
SELECT * FROM tb;
SELECT * FROM tb1;
END</code></pre>
<h4 id="修改分隔符的设置"><a href="#修改分隔符的设置" class="headerlink" title="修改分隔符的设置"></a>修改分隔符的设置</h4><pre class=" language-mysql"><code class="language-mysql">$ delimiter //</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ delimiter //
$ CREATE PROCEDURE pr1()
    BEGIN
    SELECT * FROM tb;
    SELECT * FROM tb1;
    END
    //
$ delimiter ;</code></pre>
<h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><pre class=" language-mysql"><code class="language-mysql">$ CALL pr1();
+-------+-------------------+------+
| empid | name              | age  |
+-------+-------------------+------+
| A101  | 主任·佐腾         |   40 |
| A102  | 高桥              |   28 |
| A103  | 中川              |   20 |
| A104  | 渡边              |   23 |
| A105  | 西泽              |   35 |
| NULL  | 临时工·石田       |   18 |
+-------+-------------------+------+
6 rows in set (0.01 sec)

+--------------+-------+-------+
| empid        | sales | month |
+--------------+-------+-------+
| A103         |   101 |     4 |
| A102         |    54 |     5 |
| A104         |   181 |     4 |
| A101         |   184 |     4 |
| A103         |    17 |     5 |
| A101         |   300 |     5 |
| A102         |   205 |     6 |
| A104         |    93 |     5 |
| A103         |    12 |     6 |
| A107         |    87 |     6 |
| 恶意刁难     |    50 |  NULL |
| 恶意刁难     |    50 |  NULL |
+--------------+-------+-------+
12 rows in set (0.01 sec)

Query OK, 0 rows affected (0.01 sec)</code></pre>
<h4 id="创建只显示大于等于指定值的记录的存储过程"><a href="#创建只显示大于等于指定值的记录的存储过程" class="headerlink" title="创建只显示大于等于指定值的记录的存储过程"></a>创建只显示大于等于指定值的记录的存储过程</h4><pre class=" language-mysql"><code class="language-mysql">$ CREATE PROCEDURE 存储过程名 (参数名 数据类型);</code></pre>
<p>这里，我们来创建一个 “显示销售额大于等于指定值的记录” 的基本存储过程。</p>
<p>例如，当向存储过程 pr 中指定整数类型参数 d 时，存储过程就可以编写 PROCEDURE pr(d INT)。参数 d 在 SQL 语句中的编写方式与数值相同。</p>
<ul>
<li>显示表 tb 中 sales 大于等于参数 d 的记录</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE sales >= d;</code></pre>
<p>下面试着创建存储过程 pr2。如果指定整数类型的参数 d 的值执行该存储过程，表 tb 中销售额大于等于 d 的记录就会显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ delimiter //
$ CREATE PROCEDURE pr2(d INT)
    BEGIN
    SELECT * FROM tb WHERE sales >= d
    END
    //
$ delimiter ;</code></pre>
<p>下面我们试着把数值 200 指定为参数来执行存储过程 pr2。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CALL pr2(200);
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A101  |   300 |     5 |
| A102  |   205 |     6 |
+-------+-------+-------+
2 rows in set (0.01 sec)

Query OK, 0 rows affected (0.01 sec)</code></pre>
<blockquote>
<p><strong>在参数中加上 IN 的例子</strong></p>
<p>在参数的前面加上 IN 也会得到相同的结果 （IN d INT）。相反，如果想将处理结果传给参数，则需要加上 OUT。</p>
<pre class=" language-mysql"><code class="language-mysql">$ delimiter //
$ CREATE PROCEDURE pr2(IN d INT)
    BEGIN
    SELECT * FROM tb WHERE sales >= d
    END
    //
$ delimiter ;</code></pre>
</blockquote>
<h3 id="显示、删除存储过程"><a href="#显示、删除存储过程" class="headerlink" title="显示、删除存储过程"></a>显示、删除存储过程</h3><pre class=" language-mysql"><code class="language-mysql">$ SHOW CREATE PROCEDURE 存储过程名;

$ SHOW CREATE PROCEDURE pr2;
+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+
| Procedure | sql_mode                                                                                                              | Create Procedure                                                                              | character_set_client | collation_connection | Database Collation |
+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+
| pr2       | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION | CREATE DEFINER=`root`@`%` PROCEDURE `pr2`(d INT)
BEGIN
SELECT * FROM tb WHERE sales >= d;
END | utf8mb4              | utf8mb4_0900_ai_ci   | utf8mb4_0900_ai_ci |
+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+
1 row in set (0.00 sec)</code></pre>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><pre class=" language-mysql"><code class="language-mysql">$ DROP PROCEDURE 存储过程名;</code></pre>
<h3 id="什么是存储函数"><a href="#什么是存储函数" class="headerlink" title="什么是存储函数"></a>什么是存储函数</h3><p><strong>存储函数（stored function）</strong> 的思考方式和操作方法与存储过程基本相同。与存储过程唯一不同的一点是，存储函数在执行后会返回一个值。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_22-18-32.png" style="zoom:67%;">

<p>正如它的名字所表达的那样，存储函数可以作为函数工作。MySQL 中有许多函数，但使用存储函数可以创建自定义的函数。所以存储函数也称为<strong>用户自定义函数</strong>。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE FUNCTION 存储函数名(参数 数据类型) RETURNS 返回值的数据类型
    BEGIN
            SQL 语句 ...
            RETURN 返回值·表达式
  END</code></pre>
<p>和存储过程一样，我们可以在 （）内指定参数。即使没有指定参数，也必须加上（）。例如，当创建了名为 fu 的存储函数时，fu() 本身将返回存储函数中 RETURN xx 的 xx 部分。</p>
<h3 id="使用存储函数"><a href="#使用存储函数" class="headerlink" title="使用存储函数"></a>使用存储函数</h3><p>存储函数有可能对复制 和 数据的恢复产生影响。因此，参数 log_bin_trust_function_creators 的初始值被设置为 0，这样就不能使用存储函数了。要想使用存储函数，就需要执行下面的操作修改此设置。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SET GLOBAL log_bin_trust_function_creators = 1;
# 确认设置是否已正确修改
$ SHOW VARIABLES LIKE 'log_bin_trust_function_creators';</code></pre>
<p>如果 log_bin_trust_function_creators 被设置成了 ON，就可以使用存储函数。另外使用存储函数还需要相应的权限。大家使用的 root 用户已经包含了这个权限（Super 权限），但是普通用户就需要额外添加权限了。</p>
<h4 id="使用存储函数计算标准体重"><a href="#使用存储函数计算标准体重" class="headerlink" title="使用存储函数计算标准体重"></a>使用存储函数计算标准体重</h4><ul>
<li>标准体重 = 身高(cm) x 身高(cm) x 22/10000</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ delimiter //
$ CREATE FUNCTION fu1(height INT) RETURNS DOUBLE
    BEGIN
    RETURN height * height * 22/10000; #这里一定要有分号
    END
    //
$ delimiter ;</code></pre>
<p>执行下面的命令</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT fu1(174);
+----------+
| fu1(174) |
+----------+
|  66.6072 |
+----------+
1 row in set (0.00 sec)</code></pre>
<h4 id="返回记录平均值的存储函数"><a href="#返回记录平均值的存储函数" class="headerlink" title="返回记录平均值的存储函数"></a>返回记录平均值的存储函数</h4><pre class=" language-mysql"><code class="language-mysql">$ CREATE FUNCTION fu2() RETURNS DOUBLE
    BEGIN
    DECLARE r DOUBLE;
    SELECT AVG(sales) INTO r FROM tb;
    RETURN r;
    END</code></pre>
<p>平均值需要通过 SELECT AVG 来计算。这个值必须赋给变量。我们可以把变量理解为 “保管值的箱子”。要想使用变量，就需要通过 DECLARE 定义变量。</p>
<pre class=" language-mysql"><code class="language-mysql">$ DECLARE 变量名 变量类型</code></pre>
<p>我们把变量名设置成了 r 。平均值会输入到变量 r 中。为了能够处理小数部分，我们数据类型指定为 DOUBLE 类型。下面的 SQL 语句用于从表 tb 中提取列 sales 的平均值。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT AVG(sales) FROM tb;</code></pre>
<p>把 AVG(sales) 赋给 DECLARE 中定义的变量 r 时需要使用 INTO。于是 SQL 语句就变成了</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT AVG(sales) INTO r FROM tb;</code></pre>
<p>这样，平均值就输入了变量 r 中。我们可以使用 RETURN 让这个平均值作为存储函数的值返回。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT fu2();
+---------------+
| fu2()         |
+---------------+
| 111.166666666 |
+---------------+
1 row in set (0.01 sec)</code></pre>
<h3 id="显示和删除存储函数"><a href="#显示和删除存储函数" class="headerlink" title="显示和删除存储函数"></a>显示和删除存储函数</h3><pre class=" language-mysql"><code class="language-mysql"># 删除存储函数
$ DROP FUNCTION 存储函数名;
# 显示存储函数
$ SHOW CREATE FUNCTION 存储函数名;</code></pre>
<h3 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h3><p><strong>触发器( trigger )</strong> 是一种对表执行某种操作后会出发执行其它命令的机制。</p>
<p>当执行 INSERT、UPDATE 和 DELETE 等命令时，作为触发器提前设置好的操作也会被执行。例如，创建一个触发器，当某表的记录发生更新时，就以此为契机将更新的内容记录到另一个表中。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-28_09-33-39.png" style="zoom:50%;">

<p>触发器也常作为处理的记录或者处理失败时的备份使用。</p>
<p>触发器是一个非常强大的功能，只听过文字介绍很难了解到这个功能有哪些优点。我们先创建一个触发器来体验一下。</p>
<p>这里我们来创建一个 “如果删除了表中的记录，被删除的记录就会复制到其它表中” 的触发器。也就是说对表 tb1 执行 “DELETE FROM tb1 …; ” 命令，被删除的记录就会全部插入到表 tb1_from 中。这样一来，我们就可以随时恢复已删除的记录了。</p>
<p>请事先创建一个空表 tb1_from 用于插入表 tb1 中删除的记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE tb1_from LIKE tb1;</code></pre>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>触发器会对表执行 INSERT、UPDATE 和 DELETE 等命令之前（Before）或之后（After）被调用和执行。</p>
<h4 id="触发器被触发的时机"><a href="#触发器被触发的时机" class="headerlink" title="触发器被触发的时机"></a>触发器被触发的时机</h4><table>
<thead>
<tr>
<th>BEFORE</th>
<th>在对表进行处理之前触发</th>
</tr>
</thead>
<tbody><tr>
<td>AFTER</td>
<td>在对表进行处理之后触发</td>
</tr>
</tbody></table>
<p>另外，对表进行处理之前的列值和对表进行处理之后的列值，可以向下面这样通过 “OLD.列名” “NEW.列名” 获得。</p>
<table>
<thead>
<tr>
<th>OLD.列名</th>
<th>对表进行处理之前的列值</th>
</tr>
</thead>
<tbody><tr>
<td>NEW.列名</td>
<td>对表进行处理之后的列值</td>
</tr>
</tbody></table>
<p>也就是说，执行 INSERT、UPDATE 和 DELETE 命令之前的列值可以通过 “OLD.列名” 获得，执行这些命令之后的列值可以通过 “NEW.列名” 获得。</p>
<p>但是，根据命令的不同，有的列值可以取出来，有的列值不能取出来。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>执行前（OLD.列名）使用BEFORE</th>
<th>执行后（NEW.列名）使用AFTER</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>DELETE</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>UPDATE</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<h4 id="创建触发器-1"><a href="#创建触发器-1" class="headerlink" title="创建触发器"></a>创建触发器</h4><pre class=" language-mysql"><code class="language-mysql">$ CREATE TRIGGER 触发器名 BEFORE (或者 AFTER) DELETE 等命令
    ON 表名 FOR EACH ROW
    BEGIN
            使用更新前(OLD.列名) 或者更新后(NEW.列名) 的处理
    END</code></pre>
<p>在触发器主体的描述中，各个命令的末尾要加上分号 “;”。</p>
<pre class=" language-mysql"><code class="language-mysql">$ delimiter //
$ CREATE TRIGGER tr1 BEFORE DELETE ON tb1 FOR EACH ROW
    BEGIN
    INSERT INTO tb1_from VALUES(OLD.empid, OLD.name, OLD.age);
    END
    //
$ delimiter ;</code></pre>
<p>触发器创建成功了。现在，表 tb1 删除的记录应该能够插入到表 tb1_form 中了。不管是 1 条记录还是 2 条记录，触发器都会进行处理，所以我们干脆把所有记录都删掉。</p>
<pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM tb1;

$ SELECT * FROM tb1_from;
+-------+-------------------+------+
| empid | name              | age  |
+-------+-------------------+------+
| A101  | 主任·佐腾         |   40 |
| A102  | 高桥              |   28 |
| A103  | 中川              |   20 |
| A104  | 渡边              |   23 |
| A105  | 西泽              |   35 |
| NULL  | 临时工·石田       |   18 |
+-------+-------------------+------+
6 rows in set (0.00 sec)</code></pre>
<p>和我们预想的一样，删除的记录插入带了表 tb1_from 中了。</p>
<h4 id="触发器的内容"><a href="#触发器的内容" class="headerlink" title="触发器的内容"></a>触发器的内容</h4><pre class=" language-mysql"><code class="language-mysql">CREATE TRIGGER tr1 BEFORE DELETE ON tb1 FOR EACH ROW
BEGIN
    INSERT INTO tb1_from VALUES(OLD.empid, OLD.name, OLD.age);
END</code></pre>
<p>首先为表 tb1 的 DELETE 命令设置触发器 tr1。因为要对删除之前 (BEFORE) 的值进行 INSERT，所以 CREATE TRIGGER 的部分需要编写成下面这样：</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TRIGGER tr1 BEFORE DELETE ON tb1 FOR EACH ROW;</code></pre>
<p>提出删除前（BEFORE）的列值（OLD.列名），并将其插入表 tb1_from 中。表 tb1_from 由列 empid、列 name 和 列 age 组成，所以删除前的列值分别为 OLD.empid、OLD.name 和 OLD.age。</p>
<p>因为要使用 INSERT 命令将这些列值插入到表 tb1_from 中，所以触发器需要描述成下面这样：</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO tb1_from VALUES(OLD.empid, OLD.name, OLD.age);</code></pre>
<p>该触发器的主体部分用 BEGIN 和 END 括了起来。</p>
<h3 id="确认和删除触发器"><a href="#确认和删除触发器" class="headerlink" title="确认和删除触发器"></a>确认和删除触发器</h3><p>触发器是自动启动的。为了避免无意间执行相关处理，我们需要在管理上多加注意。必须对当前设置的触发器及其内容有充分的了解。</p>
<p>我们可以使用 SHOW TRIGGERS 命令确认当前设置的触发器。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SHOW TRIGGERS;</code></pre>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><pre class=" language-mysql"><code class="language-mysql">$ DROP TRIGGER 触发器名;</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑数据</title>
    <url>/posts/3065.html</url>
    <content><![CDATA[<h3 id="瞬间更新列中所有的记录"><a href="#瞬间更新列中所有的记录" class="headerlink" title="瞬间更新列中所有的记录"></a>瞬间更新列中所有的记录</h3><p>首先是修改记录的方法。修改记录时需要使用 UPDATE 命令。</p>
<pre class=" language-mysql"><code class="language-mysql">UPDATE 表名 SET 列名 = 设置的值;</code></pre>
<p>上面的命令会给指定的列设置值。如果执行这个命令，不管有几千条还是几万条记录，列中的所有记录都会被瞬间替换掉。 UPDATE 命令通常在通过 WHERE 设置条件之后，以特定的记录为对象执行。</p>
<p>现在销售信息表 tb 中只有员工号 empid、销售额 sales 和 月份 month 这 3 个列，我们再添加一个数据类型为 VARCHAR(100) 的列 remark 来表示 “备注”。使用 UPDATE 命令将列 remark 的所有记录更新为 “无特殊记录”，然后显示所有记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb ADD remark VARCHAR(100);
$ UPDATE tb SET remark = '无特殊记录';
$ SELECT * FROM tb;</code></pre>
<blockquote>
<p><strong>防止意外执行 UPDATE 和 DELETE</strong>    当我们在工作中使用 MySQL 时，虽然有时候需要一次性更新列的所有内容，但这只是偶尔的事情。如果不慎将所有的列都更新成相同的值就麻烦了。所以为了防止这种情况发生，在启动 MySQL 监视器的时候可以加上 –safe-updates 选项。在使用此选项的情况下，如果列上没有 WHERE 条件就无法执行 UPDATE 或 DELETE。</p>
</blockquote>
<h3 id="只修改符合条件的记录"><a href="#只修改符合条件的记录" class="headerlink" title="只修改符合条件的记录"></a>只修改符合条件的记录</h3><p>很多时候我们只修改符合 WHERE 条件的记录。具体的命令如下所示：</p>
<pre class=" language-mysql"><code class="language-mysql">UPDATE 表名 SET 列名 = 设置的值 WHERE 条件;</code></pre>
<p>当然，我们也可以使用 ORDER BY、LIMIT 来设置条件。</p>
<p>我们以列 sales 大于等于100的记录为对象，向备注（remark） 中输入 “优秀”。</p>
<pre class=" language-mysql"><code class="language-mysql">$ UPDATE tb SET remark = '优秀' WHERE sales >= 100;</code></pre>
<h4 id="将销售额最低的-3-条记录的备注修改为加油"><a href="#将销售额最低的-3-条记录的备注修改为加油" class="headerlink" title="将销售额最低的 3 条记录的备注修改为加油"></a>将销售额最低的 3 条记录的备注修改为加油</h4><pre class=" language-mysql"><code class="language-mysql">$ UPDATE tb SET remark = '加油' ORDER BY sales LIMIT 3;</code></pre>
<p>删除 remark 列，恢复成原来的表。</p>
<pre class=" language-mysql"><code class="language-mysql">$ ALTER TABLE tb DROP remark;</code></pre>
<h3 id="复制符合条件的记录"><a href="#复制符合条件的记录" class="headerlink" title="复制符合条件的记录"></a>复制符合条件的记录</h3><p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE tb_A101 SELECT * FROM tb WHERE empid LIKE 'A101';
$ SELECT * FROM tb_A101;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A101  |   184 |     4 |
| A101  |   300 |     5 |
+-------+-------+-------+
2 rows in set (0.00 sec)</code></pre>
<p>如果要将记录插入到已存在的表中：</p>
<pre class=" language-mysql"><code class="language-mysql">$ INSERT INTO 已存在的表 SELECT * FROM tb WHERE empid LIKE 'A101';</code></pre>
<h4 id="排序后复制"><a href="#排序后复制" class="headerlink" title="排序后复制"></a>排序后复制</h4><p>“只复制值最小的3条记录” ，“复制从第 5 条到第 10 条的记录” 这种按照列值的顺序复制记录的方法。使用 ORDER BY 排序，然后使用 LIMIT 和 OFFSET 指定要复制的记录数和开始复制记录的位置。</p>
<p>复制表 tb 的列结构以及按照列 sales 的值从高到低的顺序复制排在第 2 名到第 5 名的 4 条记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE tb_2to5 SELECT * FROM tb ORDER BY sales DESC LIMIT 4 OFFSET 1;</code></pre>
<h3 id="删除符合条件的记录"><a href="#删除符合条件的记录" class="headerlink" title="删除符合条件的记录"></a>删除符合条件的记录</h3><p>删除所有记录的方法是：</p>
<pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM 表名;</code></pre>
<h4 id="删除指定的记录"><a href="#删除指定的记录" class="headerlink" title="删除指定的记录"></a>删除指定的记录</h4><pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM 表名 WHERE 条件;</code></pre>
<p>删除 tb1 中列 age 的值小于 30 的记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM tb1 WHERE age < 30;</code></pre>
<h4 id="排序后删除"><a href="#排序后删除" class="headerlink" title="排序后删除"></a>排序后删除</h4><p>删除列 sales 中值最大的 4 条记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ DELETE FROM tb1 ORDER BY sales LIMIT 4;</code></pre>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>提取表 t_stock 的列 c 中除距今 5 年前以外的值的记录并创建 t_stock_new;</p>
<pre class=" language-mysql"><code class="language-mysql"># 5年前的时间    NOW() - INTERVAL 5 YEAR 
$ SELECT NOW() - INTERVAL 5 YEAR;
+-------------------------+
| NOW() - INTERVAL 5 YEAR |
+-------------------------+
| 2016-01-26 20:53:51     |
+-------------------------+
1 row in set (0.00 sec)

$ CREATE TABLE t_stock_new SELECT * FROM t_stock WHERE c > NOW() - INTERVAL 5 YEAR;</code></pre>
<blockquote>
<p>请记住 INTERVAL XX YEAR 这个便利的用法。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义中缀表达式</title>
    <url>/posts/8a52.html</url>
    <content><![CDATA[<p>一个函数只有用与两个角色类似的对象时才将其声明为中缀函数。</p>
<p>推荐示例：and、to、zip        反例：add</p>
<p>如果一个方法会改动其接受者，那么不要声明为中缀形式。</p>
<p>定义自己的中缀表达式：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">sealed</span> <span class="token keyword">class</span> CompareResult <span class="token punctuation">{</span>
    <span class="token keyword">object</span> LESS <span class="token operator">:</span> <span class="token function">CompareResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"小于"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">object</span> MORE <span class="token operator">:</span> <span class="token function">CompareResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"大于"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">object</span> EQUAL <span class="token operator">:</span> <span class="token function">CompareResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"等于"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

infix <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">vs</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> CompareResult <span class="token operator">=</span>
    <span class="token keyword">when</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span> <span class="token operator">-</span> num <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
            CompareResult<span class="token punctuation">.</span>MORE
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span> <span class="token operator">-</span> num <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
            CompareResult<span class="token punctuation">.</span>LESS
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
            CompareResult<span class="token punctuation">.</span>EQUAL
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token number">5</span> vs <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：小于 */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin自定义操作符</title>
    <url>/posts/8051.html</url>
    <content><![CDATA[<h3 id="自定义Convert操作符"><a href="#自定义Convert操作符" class="headerlink" title="自定义Convert操作符"></a>自定义Convert操作符</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">myOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">myOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list<span class="token operator">:</span> List<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
    list<span class="token punctuation">.</span><span class="token function">covert</span> <span class="token punctuation">{</span>
        it <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> E<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">covert</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> E<span class="token punctuation">)</span><span class="token operator">:</span> Iterable<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> T <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">action</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> list
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：23456 */</span></code></pre>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>在最近的这个项目中，需要导出Excel，产品经理希望导出的时候在每一行的行首都增加一个行号，从1开始，这个时候自定义集合操作符就派上用场了。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// rowIndex 导出excel时使用</span>
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> rowIndex<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> u1 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"AsiaMa"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> u2 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Xiu"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> u3 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Ghost"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> u4 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Lost"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> userList <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span>u1<span class="token punctuation">,</span> u2<span class="token punctuation">,</span> u3<span class="token punctuation">,</span> u4<span class="token punctuation">)</span>
    userList<span class="token punctuation">.</span><span class="token function">covert</span> <span class="token punctuation">{</span>
        it
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">inline</span> <span class="token keyword">fun</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">covert</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> <span class="token operator">-></span> User<span class="token punctuation">)</span><span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">,</span> item<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">withIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 设置行号</span>
        <span class="token function">action</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">.</span>rowIndex <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">action</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 
    输出结果：
        User(rowIndex=1, name=AsiaMa, age=23)
        User(rowIndex=2, name=Xiu, age=30)
        User(rowIndex=3, name=Ghost, age=11)
        User(rowIndex=4, name=Lost, age=16) 
*/</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第一天</title>
    <url>/posts/56b.html</url>
    <content><![CDATA[<h2 id="五种基本句型"><a href="#五种基本句型" class="headerlink" title="五种基本句型"></a>五种基本句型</h2><p>主语：动作的发起者，位于句首。</p>
<p>谓语：核心部分，一定是动词，紧跟在主语之后。</p>
<p>宾语：动作的承受者。</p>
<p>连续动词：不能组成一个完整的意思，没有实际意义，一般是be动词。</p>
<p>表语：对主语的修饰、描述。</p>
<p>宾语补语：对宾语的修饰、描述。</p>
<h3 id="主-连系动词-表语"><a href="#主-连系动词-表语" class="headerlink" title="主+连系动词+表语"></a>主+连系动词+表语</h3><ul>
<li>I am cold.</li>
<li>The food is delicious.</li>
<li>We are friends.</li>
<li>Make is a nice person.</li>
</ul>
<h3 id="主-谓"><a href="#主-谓" class="headerlink" title="主+谓"></a>主+谓</h3><ul>
<li>He died.</li>
<li>He smiled.</li>
<li>He cried.</li>
</ul>
<h3 id="主-谓-宾"><a href="#主-谓-宾" class="headerlink" title="主+谓+宾"></a>主+谓+宾</h3><ul>
<li>I visited him.</li>
<li>He killed a bear.</li>
<li>We love her.</li>
</ul>
<h3 id="主-谓-双宾"><a href="#主-谓-双宾" class="headerlink" title="主+谓+双宾"></a>主+谓+双宾</h3><ul>
<li>My father bought me a car.</li>
<li>Mary give me an apple.</li>
<li>He wrote her a letter.</li>
</ul>
<h3 id="主-谓-宾-宾语补语"><a href="#主-谓-宾-宾语补语" class="headerlink" title="主+谓+宾+宾语补语"></a>主+谓+宾+宾语补语</h3><ul>
<li>They named him Jamie.</li>
<li>She makes me laugh.</li>
<li>I painted the wall white.</li>
<li>She pushed the door open.</li>
<li>He asked me to call Tom.</li>
<li>I wish you to be happy.</li>
</ul>
<h2 id="人称代词"><a href="#人称代词" class="headerlink" title="人称代词"></a>人称代词</h2><h3 id="主格"><a href="#主格" class="headerlink" title="主格"></a>主格</h3><table>
<thead>
<tr>
<th></th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody><tr>
<td>第一人称</td>
<td>i</td>
<td>we</td>
</tr>
<tr>
<td>第二人称</td>
<td>you</td>
<td>you</td>
</tr>
<tr>
<td>第三人称</td>
<td>he/she/it</td>
<td>they</td>
</tr>
</tbody></table>
<h3 id="宾格"><a href="#宾格" class="headerlink" title="宾格"></a>宾格</h3><table>
<thead>
<tr>
<th></th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody><tr>
<td>第一人称</td>
<td>me</td>
<td>us</td>
</tr>
<tr>
<td>第二人称</td>
<td>you</td>
<td>you</td>
</tr>
<tr>
<td>第三人称</td>
<td>him/her/it</td>
<td>them</td>
</tr>
</tbody></table>
<h2 id="定语和状语"><a href="#定语和状语" class="headerlink" title="定语和状语"></a>定语和状语</h2><p>定语：主要增加修饰名词的细节。对名词起修饰限定作用，主要是形容词。</p>
<ul>
<li>She is a beautiful girl.</li>
<li>She is a tall and thin server-year-old girl.</li>
</ul>
<p>状语：主要增加动词的细节。表示方式，程度，时间，地点，原因，目的…可以修饰动词，形容词和副词。</p>
<ul>
<li>He woke up at midnight.（时间状语）</li>
<li>Tim studied at home.（地点状语）</li>
<li>She talk loudy.（方式状语）</li>
<li>He walks in a funny way.</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第三天</title>
    <url>/posts/9968.html</url>
    <content><![CDATA[<h3 id="动名词作主语"><a href="#动名词作主语" class="headerlink" title="动名词作主语"></a>动名词作主语</h3><ul>
<li>Eating an apple a day keeps you healthy.</li>
<li>Running five miles is the first thing he does in the morning.</li>
</ul>
<h3 id="不定式作主语"><a href="#不定式作主语" class="headerlink" title="不定式作主语"></a>不定式作主语</h3><ul>
<li>To study abroad is my greatest desire.</li>
<li>To travel around the world is my plan for this year.</li>
</ul>
<p>动名词作主语不讨论这件事做或没做。不定式做主语，这件事情还没有做。</p>
<p>动词要做主语，不能用原词。可以用动名词，也可以用不定式。如果是不定式，这个动作要没做才可以。</p>
<blockquote>
<p>不定式和动名词作主语时，常出现主语过长的情况，可以用代词it代替，作形式主语放在句首，而把真正的主语，即不定式或动名词短语放在句尾。动名词移至句尾时，常改为不定式。</p>
</blockquote>
<p>Collecting stamps is one of his hobbies.</p>
<p><code>It</code> is one of his hobbies <code>to collect stamps</code>.</p>
<p>Eating an apple a day keeps you healthy.</p>
<p><code>It</code> keeps you healthy <code>to eat an appale</code>.</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>hear from 收到….的信</p>
<p>hear sb do sth 听见某人做某事 </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第二天</title>
    <url>/posts/9511.html</url>
    <content><![CDATA[<h3 id="为什么会有五种句型"><a href="#为什么会有五种句型" class="headerlink" title="为什么会有五种句型"></a>为什么会有五种句型</h3><p>这个句子有没有动词，没有动作就一般是主系表。如果有一个动作，我们把这个动作视为核心动词「谓语动词」。根据这个动词的种类不一样，这个动作涉及到别的对象呢，还是自己就能完成。涉及到别人是涉及到一个对象还是两个对象呢？这样子会划分为四种不同的类型。</p>
<p>定状语：状语增加动作的细节。定语增加名词的细节。动作是什么，怎么做出来的，在哪里做的，目的是什么。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>She bought a new bag.        <code>she</code> 主语    <code>bought</code> 谓语     <code>a new bag</code> 宾语；名词词组，冠词+形容词+名词=名词。</p>
<p>I am happy.         <code>i</code> 主语     <code>am</code> 连系动词     <code>happy</code> 表语</p>
<p>We love music.        <code>we</code> 主语     <code>love</code>谓语     <code>music</code> 宾语</p>
<p>We love swimming.         <code>we</code>主语     <code>love</code>谓语     <code>swimming</code>宾语</p>
<p>We love eating hotpot.         <code>we</code> 主语     <code>love</code>谓语     <code> eating hotpot</code>宾语（吃火锅视为一件事情）</p>
<p>He made me sad.         <code>He</code>主语     <code>made</code>谓语     <code>me</code>宾语    <code>sad</code>宾补</p>
<p>They invited me to dance.        <code>they</code>主语    <code>invited</code>谓语    <code>me</code>宾语    <code>to dance</code>宾补</p>
<p>My brother passed me the salt.    <code>my brother</code>主语    <code>passed</code>谓语    <code>me</code>宾语     <code>the salt</code>宾语</p>
<p>He sighed deeply.    <code>He</code> 主语    <code>sighed</code>谓语     <code>deeply</code>状语  叹气是不及物动词，涉及不到别人的动作。</p>
<p>He asked me to help him.    <code>He</code>主语    <code>asked</code>谓语    <code>me</code>宾语    <code>to help him</code>宾补</p>
<p>I worry about him.    <code>i</code>主语    <code>worry about</code>谓语    <code>him</code>宾语</p>
<p>He is looking at you.    <code>he</code>主语    <code>is looking at</code>谓语    <code>you</code>宾语</p>
<p>Playing basketball is my biggest time.    <code>playing basketball</code>主语    <code>is</code>系动词    <code>my biggest time</code>表语</p>
<p>He told me a joke.    <code>he</code>主语    <code>told</code>谓语    <code>me</code>宾语    <code>a joke</code>宾语</p>
<h3 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h3><p>动作的发出者，或者描述的对象。一般在开头。</p>
<ol>
<li>名词<ul>
<li>Pineapple is a kind of tropical fruit. <code>a kind of tropica</code>定语，意群。</li>
<li>Success requires persistence.</li>
<li>Monday is a workday.</li>
<li>A good night’s sleep is the best rest.</li>
</ul>
</li>
<li>代词</li>
<li>动名词</li>
<li>不定式</li>
<li>主语从句</li>
</ol>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ol>
<li>Hotpot  [ˈhɒtpɒt]    火锅</li>
<li>Invited  [ɪnˈvaɪtɪd]  邀请</li>
<li>Pepper [ˈpepər]  胡椒粉</li>
<li>Shaker  [ˈʃeɪkər] 振动器；混和器；调酒器</li>
<li>sighed  叹息</li>
<li>Pastime  [ˈpæstaɪm]  娱乐，消遣</li>
<li>Persistence   [pərˈsɪstəns]  坚持不懈；毅力 </li>
<li>Pineapple  [ˈpaɪnæpl]  菠萝</li>
<li>tropical  [ˈtrɑːpɪkl]  热带的</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第五天</title>
    <url>/posts/3517.html</url>
    <content><![CDATA[<h3 id="名词作宾语"><a href="#名词作宾语" class="headerlink" title="名词作宾语"></a>名词作宾语</h3><p>When you’re the bos s, you can make up your own rules.</p>
<p>She loves her Snow White costume.</p>
<p>她喜欢她的白雪公主戏服。</p>
<h3 id="代词作宾语"><a href="#代词作宾语" class="headerlink" title="代词作宾语"></a>代词作宾语</h3><p>I didn’t notice him.</p>
<p>Thomas brags about this every single day.</p>
<p>I forgive you.</p>
<h3 id="动名词作宾语"><a href="#动名词作宾语" class="headerlink" title="动名词作宾语"></a>动名词作宾语</h3><p>I hate riding bicycle.</p>
<p>I can’t imagine going on a date with him.</p>
<h3 id="不定式作宾语"><a href="#不定式作宾语" class="headerlink" title="不定式作宾语"></a>不定式作宾语</h3><p>I want to see him now.</p>
<p>I like to go swimming on a hot day like this.</p>
<h3 id="it-作形式宾语"><a href="#it-作形式宾语" class="headerlink" title="it 作形式宾语"></a>it 作形式宾语</h3><p>She found it difficult to convince him.</p>
<p>He made it a rule to do an hour’s work in the garden every day.</p>
<h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><ul>
<li>that</li>
</ul>
<p>I think that we should cooperate.</p>
<p>They feel that it’s impossible to win the game.</p>
<ul>
<li>whether</li>
</ul>
<p>I wonder whether he can do it.</p>
<p>I don’t know whether the typhoon will come.</p>
<ul>
<li>特殊疑问词</li>
</ul>
<p>I don’t believe what he said.</p>
<p>I forget where he lives.</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>forbid [fərˈbɪd]] 禁止</p>
<p>ban [bæn] 禁止</p>
<p>dessert [dɪˈzɜːrt] 餐后甜点</p>
<p>costume [ˈkɑːstuːm] 服装</p>
<p>cooperate [koʊˈɑːpəreɪt] 合作</p>
<p>typhoon [aɪˈfuːn] 台风</p>
<p>act [ækt] 行动</p>
<p>argue [ˈɑːrɡjuː] 争论</p>
<p>Competent [ˈkɑːmpɪtənt] 胜任</p>
<p>brags about 吹牛</p>
<p>going on date with sb 与某人约会</p>
<p>take it for granted 理所当然的</p>
<blockquote>
<p>the + 形容词 = 名词</p>
<p>The rick should help the poor.</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第四天</title>
    <url>/posts/f7a9.html</url>
    <content><![CDATA[<h3 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h3><h4 id="that-陈述句"><a href="#that-陈述句" class="headerlink" title="that + 陈述句"></a>that + 陈述句</h4><ul>
<li>练习1</li>
</ul>
<p><code>He doesn't believe me.</code></p>
<p><code>It hurts my feeling.</code></p>
<p>That he doesn’t believe me hurts my feeling.</p>
<p>It hurts my feeling that he doesn’t believe me.</p>
<ul>
<li>练习2</li>
</ul>
<p><code>All the Chinese students are good at math.</code></p>
<p><code>It is a stereotype.</code></p>
<p>That all the Chinese students are good at math is a stereotype.</p>
<p>It is a stereotype that all the Chinese students are good at math.</p>
<h4 id="whether-一般疑问句"><a href="#whether-一般疑问句" class="headerlink" title="whether + 一般疑问句"></a>whether + 一般疑问句</h4><ul>
<li>练习1</li>
</ul>
<p><code>Is he married?</code></p>
<p><code>It is not our business.</code></p>
<p>Whether he is married is not our business.</p>
<ul>
<li>练习2</li>
</ul>
<p><code>Should i apologize?</code></p>
<p><code>This question keeps me awake at night.</code></p>
<p>Whether i should apologize keeps me awake at night.</p>
<ul>
<li>练习3</li>
</ul>
<p><code>Can he do it?</code></p>
<p><code>It is uncertain.</code></p>
<p>Whether he can do these is uncertain.</p>
<ul>
<li>练习4</li>
</ul>
<p><code>Does he like it?</code></p>
<p><code>It is unknown to us.</code></p>
<p>Where he like it is unknown us.</p>
<blockquote>
<p>Whether 后面还可以加不定式，做主语。</p>
<p>Whether to respond is not decided.</p>
<p>Whether to impeach the president is under debate.</p>
</blockquote>
<h4 id="特殊疑问句（调整为陈述句语序）"><a href="#特殊疑问句（调整为陈述句语序）" class="headerlink" title="特殊疑问句（调整为陈述句语序）"></a>特殊疑问句（调整为陈述句语序）</h4><ul>
<li>特殊疑问词引导的特殊疑问句，改为陈述句语序。</li>
</ul>
<p>What i want is a new dress.</p>
<p>我想要一个新裙子。</p>
<p>Why he left is not important.</p>
<p>他为什么离开不重要。</p>
<ul>
<li>特殊疑问词 + to do</li>
</ul>
<p>What to eat for dinner doesn’t matter.</p>
<p>晚饭吃什么不重要。</p>
<p>Where to go is still under discussion.</p>
<p>去哪里还在讨论中。</p>
<blockquote>
<p>主语从句往往过长，放到句尾，而用it做形式主语放在句首。</p>
<p>What to say is not important. It is the way talk that matters.</p>
<p>How to solve real problem is not taught in school. It’s learned from experience.</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>stereotype [ˈsteriətaɪp] 陈腔烂调，老套；成见</p>
<p>occur [əˈkɜːr] 出现；发生</p>
<p>wonder [ˈwʌndər] 惊讶；奇迹</p>
<p>miracle [ˈmɪrəkl] 奇迹</p>
<p>survive  [sərˈvaɪv] 幸存</p>
<p>arrest [əˈrest] 逮捕</p>
<p>impeach [ɪmˈpiːtʃ] 弹劾</p>
<p>respond [rɪˈspɑːnd] 回答；做出反应</p>
<p>president [ˈprezɪdənt] 总统</p>
<p>debate [dɪˈbeɪt] 讨论</p>
<p>car crash 车祸</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>设置Redis中的key过期时间</title>
    <url>/posts/ae5.html</url>
    <content><![CDATA[<h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><p>在实际的开发中经常会遇到一些有时效的数据，比如现实优惠活动、缓存或验证码等，过了一定的时间就需要删除这些数据。在关系数据库中一般需要额外一个字段来记录到期时间，然后定期检测删除过期数据。而在 Redis 中可以使用 <code>EXPIRE</code> 命令来设置一个键的过期时间，到时间后，Redis 会自动删除它。</p>
<p><code>EXPIRE</code> 命令的使用方法为 <code>EXPIRE key seconds</code>，其中 seconds 参数表示键的过期时间，单位是秒。</p>
<p>如果想让 session:29e3d 键在 15 分钟后删除：</p>
<pre class=" language-bash"><code class="language-bash">$ SET session:29e3d uid1314
OK
$ EXPIRE session:29e3d 900
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>EXPIRE 命令返回 1 表示设置成功，返回0 则表示键不存在或设置失败。</p>
<p>如果想知道一个键还有多久的时间会被删除，可以使用 TTL 命令。返回值是键的剩余时间（单位是秒）:</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK
$ EXPIRE foo 20
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 15
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2</code></pre>
<p>可见随着时间的不同，<code>foo</code> 键的过期时间逐渐减少，20秒后 <code>foo</code> 键会被删除。当键不存在时，<code>TTL</code> 命令会返回 -2。</p>
<p>没有为键设置过期时间（即永久存在，这是建立一个键后的默认情况），<code>TTL</code> 命令会返回 -1。</p>
<p>如果想取消键的过期时间设置（即将键恢复成永久的），则可以使用 <code>PRESIST</code> 命令。如果过期时间被成功清除则返回 1；否则返回 0（因为键不存在或键本来就是永久的）。</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK
$ EXPIRE foo 20
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ PERSIST foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1</code></pre>
<p>除了 PERSIST 命令外，使用 SET 或 GETSET 命令为键值赋值也会同时清除键的过期时间。其它只对键值进行操作的命令（如 INCR、LPUSH、HSET、ZERM）均不会影响键的过期时间。</p>
<p><code>EXPIRE</code> 命令的 <code>seconds</code> 参数必须是整数，所以最小单位是 1 秒。如果想要更精确的控制键的过期时间应该使用 <code>PEXPIRE</code> 命令，<code>PEXPIRE</code> 命令与 <code>EXPIRE</code> 的唯一区别是前者的时间单位是毫秒，即 <code>PEXPIRE key 1000</code> 与 <code>EXPIRE key 1</code> 等价。对应地可以使用 PTTL 命令以毫秒为单位返回键的剩余时间。</p>
<blockquote>
<p>如果使用 <code>WATCH</code> 命令监测了一个拥有过期时间的键，该键到期自动删除并不会被 <code>WATCH</code> 命令认为该键被改变。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>实现访问频率限制</li>
</ol>
<p>为了减轻服务器的压力，需要限制每个用户（以IP计）一段时间的最大访问量。与时间有关的操作很容易想到 <code>EXPIRE</code> 命令。</p>
<p>例如要限制每分钟每个用户最多只能访问100个页面，思路是对每个用户使用一个名为 <code>rate.limiting:用户IP</code> 字符串类型键，每次用户访问则使用 <code>INCR</code> 命令来递增该键的键值，如果递增后的值是 1（第一次访问页面）,则同时还要设置该键的过期时间为 1 分钟。这样每次用户访问页面时都能读取该键的键值，如果超过 100 就表明该用户的访问频率超过了限制，需要提示用户稍后访问。该键每分钟会被自动删除，所以下一分钟用户的访问次数又会重新计算，也就达到了限制访问频率的目的。</p>
<ol start="2">
<li>实现缓存</li>
</ol>
<p>为了提高网站的负载能力，常常需要将一些访问频率较高但是对 CPU 或 IO 资源消耗较大的操作的结果缓存起来，并希望让这些缓存过一段时间自动过期。</p>
<blockquote>
<p>当服务器内存有限时，如果大量地使用缓存键且过期时间设置得过长就会导致 Redis 占满内存；另一方面如果为了防止 Redis 占用内存过大而将缓存键得过期时间设置得太短，就可能导致缓存命中率过低并且大量内存白白地闲置。</p>
<p>实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制 Redis 能够使用的最大内存，并让 Redis 按照一定的规则淘汰不需要的缓存键，这种方式只在 Redis 用作缓存系统时非常实用。</p>
<p>具体的设置方法为：修改配置文件的 <code>maxmemory</code> 参数，限制 Redis 最大可用内存大小（单位是字节）,当超出了这个限制时，Redis会依据 <code>maxmemory-policy</code> 参数指定的策略来删除不需要的键，直到 Redis 占用的内存小于指定内存。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>使用 LRU 算法删除一个键（只对设置了过期时间的键）</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>使用 LRU 算法删除一个键</td>
</tr>
<tr>
<td>volatile-random</td>
<td>随机删除一个键（只对设置了过期时间的键）</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>随机删除一个键</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>删除过期时间最近的一个键</td>
</tr>
<tr>
<td>noeviction</td>
<td>不删除键，只返回错误</td>
</tr>
</tbody></table>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>通过外部单体对象来注册 Spring Bean</title>
    <url>/posts/de54.html</url>
    <content><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 省略setter getter</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonBeanRegistrationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建一个外部 Employee 对象</span>
    Employee employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册外部的单例对象</span>
    beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"employee"</span><span class="token punctuation">,</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 通过依赖查找的方式来获取 Employee</span>
    Employee employeeByLookup <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"employee"</span><span class="token punctuation">,</span> Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"employee == employeeLookup : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>employee <span class="token operator">==</span> employeeByLookup<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>销毁 Spring Bean</title>
    <url>/posts/bd02.html</url>
    <content><![CDATA[<h3 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@PreDestroy</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PreDestroy : Employee 销毁中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    @PreDestroy : Employee 销毁中... */</span></code></pre>
<h3 id="自定义销毁方法"><a href="#自定义销毁方法" class="headerlink" title="自定义销毁方法"></a>自定义销毁方法</h3><ul>
<li>xml 配置：&lt;bean destroy=”destroy” …/&gt;</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initEmployee<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doDestroy<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre>
<ul>
<li>Java注解：@Bean(destroy=”destroy”)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token annotation punctuation">@PreDestroy</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PreDestroy : Employee 销毁中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义销毁方法 doDestroy : Employee 销毁中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册Configuration Class (配置类)</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非延迟初始化在 Spring 应用上下文启动完成后，被初始化</span>
    Employee employee <span class="token operator">=</span> annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">"doDestroy"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    @PreDestroy : Employee 销毁中...
    自定义销毁方法 doDestroy : Employee 销毁中 */</span></code></pre>
<ul>
<li>Java API: AbstractBeanDefinition#setDestroyMethodName(String)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    AbstractBeanDefinition beanDefinition <span class="token operator">=</span>
        BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setInitMethodName</span><span class="token punctuation">(</span><span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setDestroyMethodName</span><span class="token punctuation">(</span><span class="token string">"doDestroy"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>
            <span class="token string">"myEmployee"</span><span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="实现DisposableBean接口的-destroy-方法"><a href="#实现DisposableBean接口的-destroy-方法" class="headerlink" title="实现DisposableBean接口的 destroy() 方法"></a>实现DisposableBean接口的 destroy() 方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@PreDestroy</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PreDestroy : Employee 销毁中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Disposable#destroy() : Employee 销毁中... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义销毁方法 doDestroy : Employee 销毁中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册Configuration Class (配置类)</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非延迟初始化在 Spring 应用上下文启动完成后，被初始化</span>
    Employee employee <span class="token operator">=</span> annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">"doDestroy"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    @PreDestroy : Employee 销毁中...
    Disposable#destroy() : Employee 销毁中... 
    自定义销毁方法 doDestroy : Employee 销毁中 */</span></code></pre>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>@PreDestroy ——&gt; DisposableBean ——&gt; 自定义销毁方法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin集合常用操作符</title>
    <url>/posts/fb3b.html</url>
    <content><![CDATA[<h3 id="元素操作类"><a href="#元素操作类" class="headerlink" title="元素操作类"></a>元素操作类</h3><p>contanis        ——     判断是否有指定元素</p>
<p>elementAt     ——     返回对应的元素，越界会抛出IndexOutOfBoundsException</p>
<p>firstOrNull     ——     返回符合条件的第一个元素，没有返回null</p>
<p>lastOrNull     ——     返回符合条件的最后一个元素，没有返回null</p>
<p>indexOf         ——     返回指定元素的下标，没有返回-1</p>
<p>singleOrNull ——     返回符合条件的单个元素，如果没有符合或超过一个，返回null</p>
<h3 id="判断类"><a href="#判断类" class="headerlink" title="判断类"></a>判断类</h3><p>any        ——     判断集合中是否有满足条件的元素</p>
<p>all          ——     判断集合中的元素是否都满足条件</p>
<p>none     ——     判断集合中是否都不满足条件，是则返回true</p>
<p>count    ——     查询集合中满足条件的元素个数 </p>
<h3 id="过滤类"><a href="#过滤类" class="headerlink" title="过滤类"></a>过滤类</h3><p>filter                    ——     过滤出所有满足条件的元素</p>
<p>filterNot             ——     过滤出所有不满足条件的元素</p>
<p>filterNotNull      ——     过滤NULL</p>
<p>take                     ——     返回前n个元素</p>
<h3 id="转换类"><a href="#转换类" class="headerlink" title="转换类"></a>转换类</h3><p>map                     ——     转换成另一个集合</p>
<p>mapIndexed      ——     除了转换成另一个集合，还可以拿到Index(下标)</p>
<p>mapNotNull       ——     执行转换钱过滤掉为NULL的元素</p>
<p>flatMap               ——     自定义逻辑合并两个集合</p>
<p>groupBy              ——     按照某个条件分组，返回Map</p>
<h3 id="排序类"><a href="#排序类" class="headerlink" title="排序类"></a>排序类</h3><p>reversed                     ——     反序</p>
<p>sorted                         ——     升序</p>
<p>sortedBy                     ——    自定义排序</p>
<p>sortedDescending     ——     降序</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/posts/d0dd.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>如果是一个小型项目，使用一台 Redis 服务器就已经足够了，然而现实中的项目通常需要若干台Redis 服务器的支持。</p>
<ul>
<li>从结构上，单个 Redis 服务器会发生单点故障，同时一台服务器需要承受所有的请求负载。这就需要为数据生成多个副本并分配在不同的服务器上；</li>
<li>从容量上，单个 Redis 服务器的内存非常容易成为存储瓶颈，所以需要进行数据分片。</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>通过持久化功能，Redis 保证了即使在服务器重启的情况下也不会损失数据（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署不同的服务器上，这样即使有一台服务器出现故障，其它服务器依然可以继续提供服务。为此，Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。<strong>主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据</strong>。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15911611190540_.pic_hd.jpg"></p>
<p>在 Redis 中使用复制功能非常容易，只需要在从数据库的文件中加入：</p>
<pre class=" language-shell"><code class="language-shell">slaveof 主数据地址 主数据库端口</code></pre>
<p>主数据库无需任何配置。</p>
<p>为了能够更直观地展示复制的流程，下面将实现一个最简化的复制系统。我们要在一台服务器上启动两个 Redis 实例，监听不同端口，其中一个作为主数据库，另一个作为从数据库。首先我们不加任何参数来启动一个 Redis 实例作为主数据库：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 该实例默认监听 6379 端口</span>
$ redis-server</code></pre>
<p>然后加上 <code>slaveof</code> 参数启动另一个 Redis 实例作为从数据库，并让其监听 6380 端口：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># masterauth是连接 redis-server 所需要的密码</span>
redis-server --port 6380 --slaveof 127.0.0.1 6379 --masterauth 123456 --daemonize <span class="token function">yes</span></code></pre>
<p> 此时在主数据库中的任何数据变化都会自动同步到从数据库中。</p>
<p>我们打开 redis-cli 实例 A 并连接到主数据库：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -p 6379</code></pre>
<p>再打开 redis-cli 实例 B 并连接到从数据库：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -p 6380</code></pre>
<p>这时我们使用 INFO 命令来分别在实例 A 和实例 B 中获取 Replication 节的相关信息：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:1
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6380,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>504,lag<span class="token operator">=</span>0</code></pre>
<p>可以看到实例 A 的角色是 master，即主数据库，同时已连接的从数据库（上面输出中的 connected_slaves）的个数为 1。</p>
<p>同样在实例 B 中获取相应的信息为：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> info replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6379</code></pre>
<p>这里可以看到，实例 B 的 role 是 slave，即从数据库，同时主数据库的地址为 127.0.0.1，端口 6379。</p>
<p>在实例 A 中使用 SET 命令设置一个键的值：</p>
<pre class=" language-bash"><code class="language-bash">master redis A <span class="token operator">></span> SET foo bar
OK</code></pre>
<p>此时在实例 B 中就可以获得该值了：</p>
<pre class=" language-bash"><code class="language-bash">slave redis B <span class="token operator">></span> GET foo
<span class="token string">"bar"</span></code></pre>
<p>默认情况下，从数据库是只读的，如果直接修改从数据库的数据会出现错误：</p>
<pre class=" language-bash"><code class="language-bash">slave redis B <span class="token operator">></span> <span class="token keyword">set</span> foo hi
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> READONLY You can't <span class="token function">write</span> against a <span class="token function">read</span> only replica.</code></pre>
<p>可以通过<strong>设置从数据库的配置文件中的 <code>slave-read-only</code> 为 <code>no</code> 以使从数据库可写</strong>，但是因为对<strong>从数据库的任何更改都不会同步给任何其它数据库</strong>，并且一旦主数据库中更新了对应的数据就会覆盖从数据库中的改动，所以通常的场景下设置从数据库可写，以免导致易被忽略的潜在应用逻辑错误。</p>
<p>配置多台从数据库的方法也一样，在所有的从数据库配置文件中加上 <code>slaveof</code> 参数指向同一个主数据库即可。</p>
<p> 除了通过配置文件或命令行参数设置 <code>slaveof</code> 参数，还可以在运行时使用 <code>SLAVEOF</code> 命令修改：</p>
<pre class=" language-bash"><code class="language-bash">$ SLAVEOF 127.0.0.1 6379</code></pre>
<p>如果该数据库已经是其它主数据库的从数据库了，<code>SLAVEOF</code> 命令会停止和原来数据库的同步转而和新数据库同步。此外对于从数据库来说，还可以使用 <code>SLAVEOF NO ONE</code> 命令来使当前数据库通知接受其它数据库的同步并转换为主数据库。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当一个从数据库启动后，会向主数据库发送 <code>SYNC</code> 命令。同时主数据库接收到 <code>SYNC</code> 命令后会开始在后台保存快照（即 RDB 持久化的过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis 会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存命令。以上过程称为复制初始化。复制初始化结束后，主数据库每当收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致。</p>
<p> 当主从数据库之间的连接断开重连后，Redis 2.6 以及之前的版本会重新进行复制初始化（即主数据库重新保存快照并传送给从数据库），即使从数据库仅有几条命令没有收到，主数据库也必须要将数据库里的所有数据重新传送给从数据库。这使得主从数据库断开重连后的数据恢复过程效率很低下，在网络环境不好的时候这一问题尤其明显。Redis 2.8 版的一个重要改进就是断线重连能够支持有条件的增量数据传输，当从数据库重新连接上从数据库后，主数据库只需要将断线期间执行的命令传送给从数据库，从而大大提高 Redis 复制的实用性。</p>
<p>下面将从具体协议角度详细介绍复制初始化的过程。由于 Redis 服务器使用 TCP 协议通信，所以我们可以使用 telnet 工具伪装成一个从数据库来与主数据库通信。首先在命令行中连接主数据库（默认端口 6379， 假设目前没有任何从数据库连接）：</p>
<pre class=" language-bash"><code class="language-bash">$ telnet 127.0.0.1 6379
Trying 127.0.0.1<span class="token punctuation">..</span>.
Connected to 127.0.0.1.
Escape character is <span class="token string">'^]'</span><span class="token keyword">.</span></code></pre>
<p>然后作为从数据库，我们先要发送 PING 命令确定主数据库是否可以连接：</p>
<pre class=" language-bash"><code class="language-bash">PING
+PONG</code></pre>
<p>主数据库会回复 +PONG。如果没有收到主数据的回复，则向用户提示错误。如果主数据库需要密码才能连接，我们还有发送 AUTH 命令验证：</p>
<pre class=" language-bash"><code class="language-bash">AUTH 123456
+OK</code></pre>
<p>而后向主数据库发送 <code>REPLCONF</code> 命令说明自己的端口号（这里随便选择了一个）：</p>
<pre class=" language-bash"><code class="language-bash">REPLCONF listening-port 6381
+OK</code></pre>
<p>这时就可以开始同步的过程了：向主数据库发送 SYNC 命令开始同步，此时主数据库发送回快照文件和缓存的命令。目前主数据库中只有一个 foo 键，所以收到的内容如下（快照文件是二进制格式）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15921611196132_.pic_hd.jpg"></p>
<p>从数据库会将收到的内容写入到硬盘上的临时文件中，当写入完成后从数据库会用该临时文件替换 RDB 快照文件（RDB 快照文件的位置就是持久化时配置的位置，由 <code>dir</code> 和 <code>dbfilename</code> 两个参数确定），之后的操作就和 RDB 持久化时启动回复的过程一样了。需要注意的是在同步的过程中，从数据库并不会阻塞，而是继续可以处理客户端发来的命令。默认情况下，从数据库会用同步前的数据对命令进行响应。可以配置参数：</p>
<pre class=" language-shell"><code class="language-shell">replica-serve-stale-data no</code></pre>
<p>来使从数据库在同步完成前对所有命令（除了 INFO 和 SLAVEOF） 都返回错误：“SYNC with master in progress”。</p>
<p>复制初始化阶段结束后，主数据库执行的任何会导致数据变化的命令都会异步地传送给从数据库，这一过程为复制同步阶段。同步地内容和 Redis 通信协议一样，比如我们在主数据中执行 ：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo hi</code></pre>
<p>通过 telnet 我们收到了</p>
<pre class=" language-bash"><code class="language-bash">SELECT
<span class="token variable">$1</span>
0
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$2</span>
hi
*1</code></pre>
<p>复制同步阶段会贯穿整个主从同步过程地始终，直到主从关系终止为止。</p>
<p>在复制的过程中，快照无论在主数据库还是从数据库中都起了很大的作用，只要执行复制就会进行快照，即使我们关闭了 RDB 方式的持久化（通过删除所有 save 参数。）Redis 2.8.18 之后支持了无硬盘复制。</p>
<blockquote>
<p><strong>乐观复制</strong>    Redis 采用了乐观复制（optimistic replication） 的复制策略，容忍在一定时间内主从数据库的内容是不同的，但是两者的数据会最终同步。具体来说，Redis 在主从数据库之间复制数据的过程本身是异步的，这意味着，主数据库执行完客户端请求的命令后会立即将命令在主数据库的执行结果返回给客户端，并异步地将命令同步给从数据库库，而不会等待从数据库接收到该命令后在返回给客户端。这一特性保证了启用复制后主数据库地性能不会受到影响，但另一方面也会产生一个主从数据库数据不一致地时间窗口，当主数据执行了一条写命令后，主数据地数据已经发生了变动，然而在主数据库将命令传送给从数据库之前，如果两个数据库之间的网络连接断开了，此时二者之间的数据就会是不一致的。从这个角度来看，主数据库是无法得知某个命令最终同步给了多少个从数据库的，不过 Redis 提供了两个配置选项来限制只有当数据至少同步给指定数量的从数据库时，主数据库才是可写的：</p>
<pre class=" language-bash"><code class="language-bash">min-replicas-to-write 3
min-replicas-max-lag 10</code></pre>
<p>上面的配置中，<code>min-replicas-to-write</code> 表示只有当 3 个 或 3 个以上的从数据库连接到主数据库时，主数据库才是可写的，否则返回错误，例如：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOREPLICAS Not enough good slaves to write.</code></pre>
<p><code>min-replicas-max-lag</code> 表示允许从数据库最长失去连接的时间（单位秒），如果从数据库最后与主数据库联系（即发送 <code>REPLCONF ACK</code> 命令）的时间小于这个值，则认为从数据库还在保持与主数据库的连接。举个例子，按上面的配置，主数据库假设与3个从数据库相连，其中一个从数据库上一次与主数据库联系是 9 秒前，这是主数据库可以正常接受写入，一旦 1 秒过后这台从数据库依旧没有活动，则主数据则认为目前连接的从数据库只有两个，从而拒绝写入。这一特性默认是关闭的，在分布式系统中，打开并合理配置该选项后可以降低主从架构中因为网络分区导致的数据不一致问题。</p>
</blockquote>
<h4 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h4><p>从数据库库不仅可以接受主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15931611198795_.pic_hd.jpg"></p>
<p>数据库 A 的数据会同步到 B 和 C 中，而 B 中的数据会同步到 D 和 E 中。向 B 中写入数据不会同步到 A 或 C 中，只会同步到 D 和 E 中。</p>
<h4 id="读写分离一致性"><a href="#读写分离一致性" class="headerlink" title="读写分离一致性"></a>读写分离一致性</h4><p>通过复制可以实现读写分离，以提高服务器的负载能力。在常见的场景中（如电子商务网站），读的频率大于写，当单机的 Redis 无法应付大量的读请求时（尤其是较耗资源的请求，如 SORT 命令等）可以通过复制功能建立多个从数据库节点，主数据库只进行写操作，而从数据库负责读操作。这种一主多从的结构很适合读多写少的场景，而当单个的主数据库不能满足需求时，就需要使用 Redis 3.0 推出的集群功能。</p>
<h4 id="从数据库持久化"><a href="#从数据库持久化" class="headerlink" title="从数据库持久化"></a>从数据库持久化</h4><p>另一个相对耗时的操作是持久化，为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃重启后，主数据库会自动将数据同步过来，所以无需担心数据丢失。</p>
<p>然而当主数据库崩溃时，情况就稍显复杂了。手动通过从数据库数据回复主数据库数据时，需要严格按照一下两步进行。</p>
<ul>
<li>在从数据库中使用 <code>SLAVEOF NO ONE</code> 命令将从数据提升成主数据库继续服务。</li>
<li>启动之前崩溃的主数据库，然后使用 <code>SLAVEOF</code> 命令将其设置成新的主数据库的从数据库，即可将数据同步回来。</li>
</ul>
<blockquote>
<p><strong>注意</strong>    当开启复制且主数据库关闭持久化功能时，一定不要使用 <code>Supervisor</code> 以及类似的进程管理工具令主数据库崩溃后自动重启。同样当主数据库所在的服务器因故关闭时，也要避免直接重新启动。这是因为当主数据库重新启动后，因为没有开启持久化功能，所以数据库中所有数据都被清空，这时从数据库依然会从主数据库中接受数据，使得所有从数据库也被清空，导致从数据库的持久化失去意义。</p>
</blockquote>
<p>无论哪种情况，手工维护从数据库或主数据库的重启以及数据恢复都相对麻烦，好在 Redis 提供了一种自动化哨兵来实现这一过程，避免了手动维护的麻烦和容易出错的问题。</p>
<h4 id="无硬盘复制"><a href="#无硬盘复制" class="headerlink" title="无硬盘复制"></a>无硬盘复制</h4><p>Redis 复制的工作原理是基于 RDB 方式的持久化实现的，即主数据库端在后台保存 RDB 快照，从数据库端则接收并载入快照文件。这样的实现优点是可以显著地简化逻辑，复用已有的代码，但是缺点也很明显。</p>
<ul>
<li>当主数据库禁用 RDB 快照时（即删除了所有地配置文件中地 save 语句），如果执行了复制初始化操作，Redis 依然会生成 RDB 快照，所以下次启动后主数据库会以快照恢复数据。因为复制发生的时间不能确定，这使得恢复的数据可能是任何时间点的。</li>
<li>因为复制初始化时需要在硬盘中创建 RDB 快照文件，所以如果硬盘性能很慢（如网络硬盘）时这一过程会对性能产生影响。举例来说，当使用 Redis 做缓存系统时，因为不需要持久化，所以服务器的硬盘读写速度可能较差。但是当该缓存系统使用一主多从的集权架构时，每次和从数据库同步，Redis 都会执行一次快照，同时对硬盘进行读写，导致性能降低。</li>
</ul>
<p>因此从 2.8.28 版本开始，Redis 引入了无硬盘复制选项，开启该选项时，Redis 在与从数据库进行复制初始化时，将不会将快照内容存储到硬盘上，而是直接通过网络发送给数据库，避免了硬盘的性能瓶颈。可以在配置文件中使用如下配置来开启该功能：</p>
<pre class=" language-bash"><code class="language-bash">repl-diskless-sync <span class="token boolean">true</span></code></pre>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>在介绍复制的原理时提到当主从数据库连接断开后，从数据库会发送 SYNC 命令来重新进行一次完整复制操作。这样即使断开期间数据库的变化很小（甚至没有），也需要将数据库中的所有数据重新快照并传送一次。在正常的网络应用环境中，这种实现方式显然不太理想。Redis 2.8 版相对 2.6 版的最重要更新至一就是实现了主从断线重连的情况下的增量复制。</p>
<p>增量复制时基于如下 3 点实现的。</p>
<ul>
<li>从数据库会存储主数据库的运行 ID（run id）。每个 Redis 运行实例均会拥有一个唯一的运行 ID，每当实例重启后，就会自动生成一个新的运行 ID。</li>
<li>在复制同步阶段，主数据库每将一个命令 传送给从数据库时，都会同时把该命令存放到一个积压队列（backlog）中，并记录下当前积压队列中存放的命令的偏移量范围。</li>
<li>同时，从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量。</li>
</ul>
<p>这 3 点是实现增量复制的基础。当主从连接准备就绪后，从数据库会发送一条 SYNC 命令来告诉主数据库可以把所有数据同步过来了。而 2.8 版本之后，不在发送 SYNC 命令，取而代之的是发送 PSYNC 命令，格式为：</p>
<pre class=" language-bash"><code class="language-bash">$ PSYNC 主数据的运行id 断开前最新的命令偏移量</code></pre>
<p>主数据库收到 PSYNC 命令后，会执行以下判断来决定此次重连是否可以执行增量复制。</p>
<ul>
<li>首先主数据库会判断从数据库传送来的运行 ID 是否和自己的运行 ID 相同。这一步骤的意义在于确保从数据库库之前确实是和自己同步的，以免从数据库拿到错误的数据（比如主数据库在短线期间重启过，会造成数据的不一致）。</li>
<li>然后判断从数据库库最后同步成功的命令偏移量是否在积压队列中，如果在则可以执行增量复制，并将积压队列中相应的命令发送给从数据库。<ul>
<li>如果此次重连不满足增量复制的条件，主数据库会进行一次全部同步。</li>
<li>大部分情况下，增量复制的过程对开发者来说是完全透明的，开发者不需要关心增量复制的具体细节。</li>
</ul>
</li>
</ul>
<p>积压队列在本质上是一个固定长度的循环队列，默认情况下积压队列的大小为 1MB，可以通过配置文件的 <code>repl-backlog-size</code>参数来调整：</p>
<pre class=" language-bash"><code class="language-bash">$ repl-backlog-size 1mb</code></pre>
<p>很容易理解的是，积压队列越大，其允许的主从数据库断线的时间就越长。根据主从数据库之间的网络状态，设置一个合理的积压队列很重要。因为积压队列存储的内容是命令本身，如 <code>SET foo bar</code>，所以估算计算队列的大小只需要估计主从数据库断线的时间中主数据库可能执行的命令大小即可。</p>
<p>与积压队列相关的另一个配置选项是 <code>repl-backlog-ttl</code>，即当所有从数据库与主数据库断开连接后，经过多久时间可以释放挤压队列的内存空间。默认时间是 1 小时。</p>
<pre class=" language-bash"><code class="language-bash">$ repl-backlog-ttl 3600</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用数据类型</title>
    <url>/posts/f08d.html</url>
    <content><![CDATA[<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串类型是 Redis 中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。你可以用其存储用户的邮箱、JSON化的对象甚至是一张图片。一个字符串类型键允许村塾的数据的最大容量是521MB。</p>
<ol>
<li>赋值与取值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SET key value
$ GET key</code></pre>
<ol start="2">
<li>递增数字</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ INCR num</code></pre>
<p>字符串类型可以存储任何形式的字符串，当存储的字符串是整数形式时，Redis 提供了一个实用的命令 INCR，其作用是让当前键值递增，并返回递增后的值。</p>
<pre class=" language-bash"><code class="language-bash">$ INCR num
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ INCR num
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p>当要操作的键不存在时，会默认值为 0 ，所以第一次递增后的结果是 1。当键值不是整数时 Redis 会提示错误。</p>
<ol start="3">
<li>增加指定的整数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ INCRBY key increment</code></pre>
<p>与 <code>INCR</code> 命令基本一样，只不过可以通过 <code>increment</code> 参数指定一次增加的数值。如：</p>
<pre class=" language-bash"><code class="language-bash">$ INCRBY bar 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ INCRBY bar 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5</code></pre>
<ol start="4">
<li>减少指定的整数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ DECR key
$ DECRBY key increment</code></pre>
<ol start="5">
<li>增加指定的浮点数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ INCRBYFLOAT key increment</code></pre>
<p>类似 <code>INCRBY</code> 命令，差别是可以递增一个双精度浮点数。</p>
<pre class=" language-bash"><code class="language-bash">$ INCRBYFLOAT foo 2.7
<span class="token string">"2.7"</span>
$ INCRBYFLOAT foo 5E+4
<span class="token string">"50002.69999999999999929"</span></code></pre>
<ol start="6">
<li>向尾部追加值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ APPEND key value</code></pre>
<p><code>APPEND</code> 作用是向键值的末尾追加 value。如果键不存在则该键的值为 value，即相当于 SET key value。返回值是追加后字符串的长度。如：</p>
<pre class=" language-bash"><code class="language-bash">$ SET key hello
OK
$ APPEND key <span class="token string">" world!"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 12</code></pre>
<p>此时 key 的值是“hello world!”。APPEND 命令的第二个参数加了双引号，原因是该参数包含空格，在 redis-cli 中需要输入双引号以示区别。</p>
<ol start="7">
<li>获取字符串长度</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ STRLEN key</code></pre>
<ol start="8">
<li>同时获得/设置多个键值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ MGET key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ MSET key value <span class="token punctuation">[</span>key value <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>散列类型（hash）的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其它数据类型。换句话说，散列类型不能嵌套其它的数据类型。一个散列类型键可以包含至多<code>2的32次方-1</code>个字段。</p>
<blockquote>
<p>提示    除了散列类型，Redis 的其它数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。</p>
</blockquote>
<ol>
<li>赋值与取值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HSET key field value
$ HGET key field
$ HMSET key field value <span class="token punctuation">[</span>field value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ HMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ HGETALL key</code></pre>
<p><code>HSET</code> 命令用来给字段赋值，而 <code>HGET</code> 命令用来获得字段的值。</p>
<pre class=" language-bash"><code class="language-bash">$ HSET car price 500
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ HSET car name BMW
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ HGET car name
<span class="token string">"BMW"</span></code></pre>
<p><code>HSET</code>  命令的方便之处在于不区分插入和更新操作，这意味着修改数据时不用实现判断字段是否存在来决定要执行的是插入操作（update） 还是更新操作（insert）。当执行的是插入操作时（即之前字段不存在） <code>HSET</code>命令会返回 1 ，当执行的是更新操作时（即之前字段已经存在） <code>HSET</code> 命令会返回 0 。</p>
<p>如果想获取键中所有字段和字段值却不知道键中有哪些字段时，应该使用 HGETALL 命令。</p>
<pre class=" language-bash"><code class="language-bash">$ HGETALL car
1<span class="token punctuation">)</span> <span class="token string">"price"</span>
2<span class="token punctuation">)</span> <span class="token string">"500"</span>
3<span class="token punctuation">)</span> <span class="token string">"name"</span>
4<span class="token punctuation">)</span> <span class="token string">"BMW"</span></code></pre>
<p>返回的结果是字段和字段值组成的列表，不是很直观。</p>
<ol start="2">
<li>判断字段是否存在</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HEXISTS key field</code></pre>
<p>存在返回 1 ，否则返回 0 。</p>
<ol start="3">
<li>当字段不存在时赋值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HSETNX key field value</code></pre>
<p><code>HSETNX</code> 命令与  <code>HSET</code> 命令类似，区别在于如果字段已经存在，<code>HSETNX</code> 命令将不执行任何操作。<code>HSETNX</code> 命令是原子操作。</p>
<ol start="4">
<li>增加数字</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HINCRBY key field increment</code></pre>
<p>与字符串类型命令<code>INCRBY</code>, <code>HINCRBY</code> 命令与之类似，可以是字段值增加指定的整数。散列类型没有 <code>HINCR</code> 命令，但是可以通过 <code>HINCRBY key field 1</code> 来实现。</p>
<pre class=" language-bash"><code class="language-bash">$ HINCRBY person score 60
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 60</code></pre>
<p>之前 person 键不存在， <code>HINCRBY</code> 命令会自动建立该键并默认 score 字段在执行命令前的值为 “0”。命令的返回值是增值后的字段值。</p>
<ol start="5">
<li>删除字段</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HDEL key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>HDEL</code> 命令可以删除一个或多个字段。返回值是被删除的字段个数。</p>
<pre class=" language-bash"><code class="language-bash">$ HDEL car price
<span class="token punctuation">(</span>integer 1<span class="token punctuation">)</span></code></pre>
<ol start="6">
<li>只获取字段名或字段值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HKEYS key
$ KVALS key</code></pre>
<ol start="7">
<li>获取字段数量</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HLEN key</code></pre>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表类型（List）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。</p>
<p>列表类型的内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度是 O(1)，获取越接近两端的元素速度就越快。这种特性使列表类型能非常快速地完成关系数据库难以应付的场景：如社交网站的新鲜事，我们关心的只是最新的内容，使用列表类型存储，即使新鲜事的总数达到几千万个，获取其中最新的100条数据也是极快的。</p>
<p>与散列类型键最多能容纳的字段数量相同，一个列表类型键最多能容纳<code>2的32次方-1</code>个元素。</p>
<ol>
<li>向列表两端添加元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ RPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>LPUSH</code> 命令用来向列表左边增加元素，返回值表示增加元素后列表的长度。</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH numbers 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>这时 numbers 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15121611018139_.pic_hd.jpg"></p>
<p><code>LPUSH</code> 命令还支持同时增加多个元素：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH numbers 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre>
<p><code>LPUSH</code> 会先向列表左边加入 “2”，然后再加入 “3”，所以此时 numbers 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15131611018159_.pic_hd.jpg"></p>
<p>向列表右边增加元素的话则使用 <code>RPUSH</code> 命令，其用法和 <code>LPUSH</code> 命令一样：</p>
<pre class=" language-bash"><code class="language-bash">$ RPUSH numbers 0 -1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5</code></pre>
<p>此时 numbers 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15141611018309_.pic_hd.jpg"></p>
<ol start="2">
<li>从列表两端弹出元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LPOP key
$ RPOP key</code></pre>
<p><code>LPOP</code> 命令可以从列表左边弹出一个元素。 <code>LPOP</code> 命令执行两步操作：第一步是将列表左边的元素从列表中移除，第二步是返回被移除元素的值。</p>
<pre class=" language-bash"><code class="language-bash">$ LPOP numbers
<span class="token string">"3"</span>
$ RPOP numbers
<span class="token string">"-1"</span></code></pre>
<p>此时 number 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15171611018928_.pic_hd.jpg"></p>
<p>结合上面提到的 4 个命令可以使用列表类型来模拟栈和队列的操作：如果想把列表当成栈，则搭配使用 **<code>LPUSH</code> 和 <code>RPOP</code> **或 **<code>RPUSH</code> 和 <code>LPOP</code>**。</p>
<ol start="3">
<li>获取列表中元素的个数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">LLEN key</code></pre>
<p>当键不存在时 <code>LLEN</code> 会返回 0。</p>
<pre class=" language-bash"><code class="language-bash">$ LLEN numbers
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre>
<p><code>LLEN</code> 命令的功能类似 SQL 语句 <code>SELECT COUNT(*) FROM table_name</code>，但是 LLEN 的时间复杂度为 O(1)，使用时 Redis 会直接读取现成的值，而不像部分关系数据库（如使用 InnoDB 存储引擎的 MySQL 表）那样需要遍历一遍数据表来统计条目数量。</p>
<ol start="4">
<li>获得列表片段</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LRANGE key start stop</code></pre>
<p><code>LRANGE</code> 命令是列表类型最常用的命令之一，它能够获得列表中的某一片段。<code>LRANGE</code> 命令将返回索引从 start 到 top 之间的所有元素 （包含两端的元素）。Redis 的列表起始索引为 0：</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers 0 2
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span></code></pre>
<p><code>LRANGE</code> 命令也支持负索引，表示从右边开始计算序数，如 “-1” 表示最右边第一个元素，“-2” 表示最右边第二个元素，依次类推：</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers -2 -1</code></pre>
<p>显然，<code>LRANGE numbers 0 -1</code> 可以获取列表中的所有元素。另外一些特殊情况如下：</p>
<ul>
<li>如果 start 的索引位置比 stop 的索引位置靠后，则会返回空列表。</li>
<li>如果 stop 大于实际的索引范围，则会返回到列表最右边的元素。</li>
</ul>
<ol start="5">
<li>删除列表中指定的值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LREM key count value</code></pre>
<p><code>LREM</code> 命令会删除列表中前 count 个值为 value 的元素，返回值是实际删除的元素个数。根据 count 值的不同，<code>LREM</code> 命令的执行方式会略有差异。</p>
<ul>
<li><p>当 count &gt; 0 时，<code>LREM</code> 命令会从列表左边开始删除前 count 个值为 value 的元素。</p>
</li>
<li><p>当 count &lt; 0 时，<code>LREM</code> 命令会从列表右边开始删除前 count 个值为 value 的元素。</p>
</li>
<li><p>当 count = 0 时，<code>LREM</code> 命令会删除所有值为 value 的元素。</p>
</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ RPUSH numbers 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2,"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span>
4<span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token comment" spellcheck="true"># 从右边开始删除第一个值为 “2” 的元素</span>
$ LREM numbers -1 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span></code></pre>
<ol start="6">
<li>获得/设置指定索引的元素值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LINDEX key index
$ LSET key index value</code></pre>
<p>如果要将列表类型当作数组来用，<code>LINDEX</code> 命令是必不可少的。<code>LINDEX</code> 命令用来返回指定索引的元素，索引从 0 开始。如：</p>
<pre class=" language-bash"><code class="language-bash">$ LINDEX numbers 2
<span class="token string">"0"</span></code></pre>
<p>如果 index 是负数则表示从右边开始计算的索引，最右边元素的索引是 -1。例如：</p>
<pre class=" language-bash"><code class="language-bash">$ LINDEX numbers -1
<span class="token string">"0"</span></code></pre>
<p><code>LSET</code> 是一个通过索引操作列表的命令，它会将索引为 index 的元素赋值为 value。如：</p>
<pre class=" language-bash"><code class="language-bash">$ LSET numbers 1 7
OK
$ LINDEX numbers 1
<span class="token string">"7"</span></code></pre>
<ol start="8">
<li>只保留列表指定片段</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LTRIM key start end</code></pre>
<p><code>LTRIM</code> 命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和 <code>LRANGE</code> 命令相同。就像这样:</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2,"</span>
2<span class="token punctuation">)</span> <span class="token string">"7"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span>
$ LTRIM numbers 0 1
OK
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"7"</span></code></pre>
<p><code>LTRIM</code> 命令常和 <code>LPUSH</code> 命令一起使用来限制列表中元素的数量，比如记录日志时，我们希望只保留最近的 100 条日志，则每次接入新元素时调用一次 LTRIM 命令即可：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH logs <span class="token variable">$newLOg</span>
$ LTRIM log 0 99</code></pre>
<ol start="9">
<li>向列表中插入元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LINSET key BEFORE<span class="token operator">|</span>AFTER pivot value</code></pre>
<p><code>LINSERT</code> 命令首先会在列表中从左到右查找值为 pivot 的元素，然后根据第二个参数是 BEFORE 还是 AFTER 来决定将 value 插入到该元素的前面还是后面。</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"7"</span>
$ LINSERT numbers BEFORT 2 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"7"</span></code></pre>
<ol start="10">
<li>将元素从一个列表转到另一个列表</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ RPOPLPUSH <span class="token function">source</span> destination</code></pre>
<p><code>RPOPLPUSH</code> 是个很有意思的命令，从名字就可以看出它的功能：先执行 <code>RPOP</code> 命令再执行 <code>LPUSH</code> 命令。<code>RPOPLPUSH</code> 命令会先从 source 列表类型键的右边弹出一个元素，然后将其加入到 destination 列表类型键的左边，并返回这个元素的值，这个过程是原子的。</p>
<blockquote>
<p>当 source 和 destination 相同时， RPOPLPUSH 命令会不断地将对尾的元素移到队首。借助这个特性我们可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用 RPOPLPUSH 命令循环取出一个网址来测试可用性。这里使用 RPOPLPUSH 命令的好处在于程序执行过程中仍然可以不断地向网址列表中加入新网址，而且整个系统容易扩展，允许多个客户端同时处理队列。</p>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>一个集合类型（set）键可以存储至多 <code>2的31次方-1</code> 个字符串。集合类型和列表类型有相似之处，但很容易将它们区分开来：</p>
<table>
<thead>
<tr>
<th></th>
<th>集合类型</th>
<th>列表类型</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>至多 <code>2的31次方-1</code> 个字符串</td>
<td>至多 <code>2的31次方-1</code> 个字符串</td>
</tr>
<tr>
<td>有序性</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>唯一性</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在 Redis 内部是使用值为空的散列表（hash table） 实现的，所以这些操作的时间复杂度都是 O(1)。最方便的是多个集合类型键之间还可以进行并集、交集和差集运算。</p>
<ol>
<li>增加/删除元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>SADD</code> 命令用来向集合中增加一个或多个元素，如果键不存在则会自动创建。因为在一个集合中不能有相同的元素，所以如果要加入的元素已经存在与集合中就会忽略这个元素。本命令的返回值是成功加入的元素数量（忽略的元素不计算在内）。</p>
<pre class=" language-bash"><code class="language-bash">$ SADD letters a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ SASS letters a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p><code>SREM</code> 命令用来从集合中删除一个或多个元素，并返回删除成功的个数：</p>
<pre class=" language-bash"><code class="language-bash">$ SREM letters c d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<ol start="2">
<li>获得集合中的所有元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SMEMBERS key</code></pre>
<ol start="3">
<li>判断元素是否在集合中</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SISMEMBER key member</code></pre>
<p>当值存在时，<code>SISMEMBER</code> 命令返回 1，当值不存在或键不存在时返回 0。</p>
<pre class=" language-bash"><code class="language-bash">$ SISMEMBER letters a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<ol start="4">
<li>集合间运算</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SDIEF key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<ul>
<li><code>SDIFF</code> 命令用来对多个集合执行差集运算。代表所有属于A且不属于B的元素构成的集合。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ SADD setA 1 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ SADD setB 2 3 4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ SDIFF setA setB
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
$ SDIFF setB setA
1<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<p><code>SDIFF</code> 命令支持同时传入多个键：</p>
<pre class=" language-bash"><code class="language-bash">$ SADD setC 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ SDIFF setA setB setC
1<span class="token punctuation">)</span> <span class="token string">"1"</span></code></pre>
<p>计算顺序是先计算 <code>setA - setB</code> ，再计算与 <code>setC</code> 的差集。</p>
<ul>
<li><code>SINTER</code> 命令是用来对多个集合执行交集运算。 代表所有属于 A 且 属于 B 的元素构成的集合。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ SINTER setA setB
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p><code>SINTER</code> 命令同样支持同时传入多个键：</p>
<pre class=" language-bash"><code class="language-bash">$ SINTER setA setB setC
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<ul>
<li><code>SUNION</code> 命令用来对多个集合执行并集运算。代表所有属于 A 或 属于 B 的元素构成的集合。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ SUNION setA setB
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<p><code>SUNION</code> 命令同样支持同时传入多个键：</p>
<pre class=" language-bash"><code class="language-bash">$ SUNION setA setB setC
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<ol start="5">
<li>获得集合中元素个数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SCARD key</code></pre>
<ol start="6">
<li>进行集合运算并将结果存储</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>SDIFFSTORE</code> 命令和 <code>SDIFF</code> 命令功能一样，唯一的区别就是前者不会直接返回运算结果，而是将结果存储在 destination 键中。</p>
<p><code>SDIFFSTORE</code> 命令通常用与需要进行多步集合运算的场景中，如需要先计算差集再将结果和其他键计算交集。</p>
<p><code>SINTERSTORE</code> 和 <code>SUNIONSTORE </code> 命令与之类似。</p>
<ol start="7">
<li>随机获得集合中的元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span></code></pre>
<p><code>SRANDMEMBER</code> 命令用来随机获取集合中的一个元素，还可以传递 count 参数来一次随机获得多个元素。根据 count 的正负不同，具体表现也不同。</p>
<ul>
<li>当 count 为整数时，<code>SRANDCOUNT</code> 会随机从集合里获得 count 个不重复元素。如果 count 的值大于集合中元素的个数，则 <code>SRANDCOUNT</code> 会返回集合中的全部元素。</li>
<li>当 count 为负数时，<code>SRANDCOUNT</code> 会随机从集合里获得 count 个元素，这些元素可能相同。</li>
</ul>
<ol start="8">
<li>从集合中弹出一个元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SPOP key</code></pre>
<p>由于集合是无序的，所以 <code>SPOP</code> 命令会从集合中随机选择一个元素弹出。</p>
<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前 N 个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中的每个元素都是不同的，但是它们的分数却可以相同。</p>
<p>有序集合类型在某些方面和列表类型有些相似。</p>
<ul>
<li>二者都是有序的。</li>
<li>二者都可以获得某一范围的元素。</li>
</ul>
<p>但是二者有着很大的区别，这使得他们的应用场景也是不同的。</p>
<ul>
<li>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。</li>
<li>有序集合类型是使用散列表和跳表（Skip list）实现的，所以即使读取位于中间部分的数据，速度也很快。（时间复杂度是 O(log(N)) ）。</li>
<li>列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。</li>
<li>有序集合类型要比列表类型更耗费内存。</li>
</ul>
<ol>
<li>增加元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZADD key score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>ZADD</code> 命令用来向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。<code>ZADD</code> 命令的返回值是新加入到集合中的元素的个数（不包含之前已经存在的元素）。</p>
<p>假设我们用有序集合模拟计分板，现在要记录 Tom、Peter 和 David 三名运动员的分数（分别是 89 分、67分 和 100 分）：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD scoreboard 89 Tom 67 Peter 100 David
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre>
<p>这是我们发现 Peter 的分数录入有误，实际分数应该是 76 分，可以用 <code>ZADD</code> 命令修改 Peter 的分数：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD scoreboard 76 Peter
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>分数不仅可以是整数，还支持双精度浮点数：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD testboard 5E+3 a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ ZADD testboard 1.6 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ ZADD testboard +inf c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ ZADD testboard -inf d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>其中 <code>+inf</code> 和 <code>- inf</code> 分别表示正无穷和负无穷。</p>
<ol start="2">
<li>获得元素的分数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZSCORE key member</code></pre>
<ol start="3">
<li>获得排名在某个范围的元素列表</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>
$ ZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span></code></pre>
<p><code>ZRANGE</code> 命令会按照元素分数从小到大的顺序返回索引从 start 到 stop 之间的所有元素（包含两端的元素）。<code>ZRANGE</code> 命令与 <code>LRANGE</code> 命令十分相似，如果索引都是从 0 开始，负数代表从后向前查找（-1 表示最后一个元素）。</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGE scoreboard 0 2
1<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
2<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
3<span class="token punctuation">)</span> <span class="token string">"David"</span>
$ ZRANGE scoreboard 1 -1
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
2<span class="token punctuation">)</span> <span class="token string">"David"</span></code></pre>
<p>如果需要同时获得元素的分数的话，可以在 <code>ZRANGE</code> 命令尾部加上  <code>WITHSCORES</code> 参数：</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGE scoreboard 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
2<span class="token punctuation">)</span> <span class="token string">"76"</span>
3<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
4<span class="token punctuation">)</span> <span class="token string">"89"</span>
5<span class="token punctuation">)</span> <span class="token string">"David"</span>
6<span class="token punctuation">)</span> <span class="token string">"100"</span></code></pre>
<p><code>ZRANGE</code> 命令的时间复杂读为 O(log n+m)。其中 n 为有序集合的基数，m 为返回的元素个数。</p>
<p>如果两个元素的分数相同，Redis 会按照字典顺序（即 “0” &lt; “9” &lt; “A” &lt; “Z” &lt; “a” &lt; ‘“z” 这样的顺序）来进行排列。</p>
<p>如果元素的值是中文，则排序取决于中文的编码方式。如使用 UTF-8 编码：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD chineseName 0 亚洲 0 非洲 0 欧洲 0 南美洲
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
$ ZRANGE chineseName 0 -1
1<span class="token punctuation">)</span> <span class="token string">"\xe4\xba\x9a\xe6\xb4\xb2"</span>
2<span class="token punctuation">)</span> <span class="token string">"\xe5\x8d\x97\xe7\xbe\x8e\xe6\xb4\xb2"</span>
3<span class="token punctuation">)</span> <span class="token string">"\xe6\xac\xa7\xe6\xb4\xb2"</span>
4<span class="token punctuation">)</span> <span class="token string">"\xe9\x9d\x9e\xe6\xb4\xb2"</span></code></pre>
<p>可见此时 Redis 依然按照字典顺序排列这些元素。</p>
<p><code>ZREVRANGE</code> 命令和 <code>ZRANGE</code> 的唯一不同在于 <code>ZREVRANGE</code> 命令是按照元素分数从大到小的顺序给出结果的。</p>
<ol start="4">
<li>获得指定分数范围的元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span></code></pre>
<p>该命令按照元素分数从小到大的顺序返回分数在 min 和 max 之间（包含 min 和 max）的元素：</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE scoreboard 80 100
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
2<span class="token punctuation">)</span> <span class="token string">"David"</span></code></pre>
<p>如果希望的分数范围不包含端点值，可以在分数前加上<code>"("</code>符号。</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSOCRE socreboard 80 <span class="token punctuation">(</span>100
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span></code></pre>
<p>min 和 max 还支持无穷大，同 <code>ZADD</code> 命令一样，<code>-inf</code> 和 <code>+inf</code> 分别表示负无穷和正无穷。</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE scoreboard <span class="token punctuation">(</span>80 +inf
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
2<span class="token punctuation">)</span> <span class="token string">"David"</span></code></pre>
<p>WITHSCORES 参数的用户与 ZRANGE 命令一样。LIMIT offset count 与 SQL 中的用法基本相同。</p>
<p>为了便于演示，我们先向 scoreboard 键中再增加些元素：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD scoreboard 56 Jerry 92 Wendy 67 Yvonne
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
<span class="token comment" spellcheck="true"># 现在 scoreboard 键中的所有元素</span>
$ ZRANGE scoreboard 0 -1 WITHSCORES
 1<span class="token punctuation">)</span> <span class="token string">"Jerry"</span>
 2<span class="token punctuation">)</span> <span class="token string">"56"</span>
 3<span class="token punctuation">)</span> <span class="token string">"Yvonne"</span>
 4<span class="token punctuation">)</span> <span class="token string">"67"</span>
 5<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
 6<span class="token punctuation">)</span> <span class="token string">"76"</span>
 7<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
 8<span class="token punctuation">)</span> <span class="token string">"89"</span>
 9<span class="token punctuation">)</span> <span class="token string">"Wendy"</span>
10<span class="token punctuation">)</span> <span class="token string">"92"</span>
11<span class="token punctuation">)</span> <span class="token string">"David"</span>
12<span class="token punctuation">)</span> <span class="token string">"100"</span></code></pre>
<p>想获得分数高于 60 分的从第二个人开始的 3 个人：</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE scoreboard 60 +inf Limit 1 3
1<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
2<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
3<span class="token punctuation">)</span> <span class="token string">"Wendy"</span></code></pre>
<ol start="5">
<li>增加某个元素的分数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">ZINCRBY key increment member</code></pre>
<p><code>ZINCRBY</code> 命令可以增加一个元素的分数，返回值是更改后的分数。</p>
<pre class=" language-bash"><code class="language-bash">$ ZINCRBY scoreboard 4 Jerry
<span class="token string">"60"</span></code></pre>
<p>increment 也可以是个负数表示减分：</p>
<pre class=" language-bash"><code class="language-bash">$ ZINCRBY scoreboard -4 Jerry
<span class="token string">"56"</span></code></pre>
<p>如果指定的元素不存在，Redis 再执行命令前会先建立它并将它的分数赋为 0 再执行操作。</p>
<ol start="6">
<li>获得集合中元素的数量</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZCARD key</code></pre>
<ol start="7">
<li>获得指定分数范围内的元素个数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZCOUNT key min max</code></pre>
<ol start="8">
<li>删除一个或多个元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>ZREM 命令的返回值的成功删除的元素数量</p>
<pre class=" language-bash"><code class="language-bash">$ ZREM scoreboard Wendy
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<ol start="9">
<li>按照排名范围删除元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZREMRANGEBYRANK key start stop</code></pre>
<p>ZREMRANGEBYRANK 命令按照元素分数从小到大的顺序（即索引 0 表示最小的值），删除处在指定排名范围内的所有元素，并返回删除的元素数量。如：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
$ ZREMRANGEBYRANK testRem 0 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ ZRANGE testRem 0 -1
1<span class="token punctuation">)</span> <span class="token string">"d"</span>
2<span class="token punctuation">)</span> <span class="token string">"e"</span>
3<span class="token punctuation">)</span> <span class="token string">"f"</span></code></pre>
<ol start="10">
<li>按照分数范围删除元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZREMRANGEBYSCORE key min max</code></pre>
<p><code>ZREMRANGEBYSCORE</code> 命令会删除指定分数范围内的所有元素，返回值的删除的元素数量。</p>
<ol start="11">
<li>获得元素的排名</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZRANK key member
$ ZREVRANK key member</code></pre>
<p><code>ZRANK</code> 命令会按照元素分数从小到大的顺序获得指定元素的排名（从 0 开始，即分数最小的元素排名为 0）。</p>
<p><code>ZREVRANK</code> 命令则相反（分数最大的元素排名为 0 )。</p>
<ol start="12">
<li>计算有序集合的交集</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>WEIGHTS weight <span class="token punctuation">[</span>weight <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AGGREGATE SUM<span class="token operator">|</span>MIN<span class="token operator">|</span>MAX<span class="token punctuation">]</span></code></pre>
<p><code>ZINTERSTORE</code> 命令用来计算多个有序集合的交集并将结果存储在 destination 键中（同样以有序类型集合存储），返回值为 destination 键中的元素个数。<code>numkeys</code>必须 等于参与集合的个数。</p>
<p>destination 键中元素的分数是由 <code>AGGREGATE</code> 参数决定的。</p>
<ul>
<li>当 <code>AGGREGATE</code> 是 <code>SUM</code> 时（也就是默认值），destination 键中元素的分数是每个参与计算的集合中改元素分数的和。例如：</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ ZADD sortedSets1 1 a 2 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZADD sortedSets2 10 a 20 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"11"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"22"</span></code></pre>
<ul>
<li>当 <code>AGGREGATE</code> 是 <code>MIN</code> 时，destination 键中元素的分数是每个参与计算的集合中该元素分数的最小值。例如：</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MIN
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$  ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"2"</span></code></pre>
<ul>
<li>当 <code>AGGREGATE</code> 是 <code>MAX</code> 是，destination 键中元素的分数是每个参与计算的集合中该元素分数的最大值。例如：</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MAX
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"10"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"20"</span></code></pre>
<p><code>ZINTERSTORE</code> 命令还能够通过 <code>WEIGHTS</code> 参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。例如：</p>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 WEIGHTS 1 0.1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<p>另外还有一个命令与 <code>ZINTERSTORE </code>命令的用法一样，名为 <code>ZUNIONSTORE</code>，它的作用是计算集合间的并集，这里不再赘述。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵</title>
    <url>/posts/c807.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在一个典型的一主多从的Redis系统中，从数据库在整个系统中起到了数据冗余备份和读写分离的作用。当主数据库遇到异常中断服务后，开发者可以通过手动的方式选择一个从数据库来升级为主数据库，以使得系统能够继续提供服务。然而整个过程相对麻烦且需要人工介入，难以实现自动化。</p>
<p>为此，Redis 2.8 中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。</p>
<h4 id="什么是哨兵"><a href="#什么是哨兵" class="headerlink" title="什么是哨兵"></a>什么是哨兵</h4><p>顾名思义，哨兵的作用就是监控 Redis 系统的运行状况。它的功能包括以下两个。</p>
<ul>
<li>监控主数据库和从数据库是否正常运行。</li>
<li>主数据库出现故障时自动将从数据库转换为主数据库。</li>
</ul>
<p>哨兵是一个独立的进程，使用哨兵的一个典型架构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15971611207217_.pic_hd.jpg"></p>
<p>在一个一主多从的 Redis 系统中，可以使用多个哨兵进行监控任务以保证系统足够稳健。注意，此时不仅哨兵会同时监控主数据库和从数据库，哨兵之间也会互相监控。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15981611207382_.pic_hd.jpg"></p>
<h3 id="马上上手"><a href="#马上上手" class="headerlink" title="马上上手"></a>马上上手</h3><p>在理解哨兵的原理前，我们首先实际使用一下哨兵，来了解哨兵是如何工作的。首先建立起 3 个 Redis 实例，其中包括一个主数据库和两个从数据库。主数据库的端口为 6379，两个从数据库的端口分别为 6380 和 6381。我们使用 Redis 命令行客户端来获取复制状态，以保证复制配置正确。</p>
<p>首先是主数据库：</p>
<pre class=" language-bash"><code class="language-bash">redis 6379<span class="token operator">></span> info replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6380,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>56,lag<span class="token operator">=</span>0
slave1:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>56,lag<span class="token operator">=</span>0</code></pre>
<p>可见其连接了两个从数据库，配置正确。然后用同样的方法查看两个从数据库的配置：</p>
<pre class=" language-bash"><code class="language-bash">redis 6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1

redis 6381<span class="token operator">></span> info replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6379</code></pre>
<p>当出现的信息如上时，即证明一主而从配置已经成功了。</p>
<p>接下来开始配置哨兵。建立一个配置文件，如 <code>sentinel.conf</code>，内容为：</p>
<pre class=" language-shell"><code class="language-shell">sentinel monitor mymaster 127.0.0.1 6379 1</code></pre>
<p>其中 <code>mymaster</code> 表示要监视的主数据库名字，可以自己定义一个。这个名字必须仅由大小写字母、数字 和 “.-_”这3个字符组成。后两个参数表示主数据库的地址和端口号，这里我们要监控的主数据库 6379。最后的 1 表示最低通过票数，后面会介绍。接下来启动 sentinel 进程，并将上述配置文件的路径传递给哨兵：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-sentinel /path/to/sentinel.conf</code></pre>
<p> 需要注意的是，配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</p>
<p>启动哨兵后，哨兵输出一下内容：</p>
<pre class=" language-bash"><code class="language-bash">3839:X 21 Jan 2021 01:02:39.668 <span class="token comment" spellcheck="true"># Sentinel ID is 34e43f99b8460c86a0061c0e3325c5a5d94602b2</span>
3839:X 21 Jan 2021 01:02:39.668 <span class="token comment" spellcheck="true"># +monitor master mymaster 127.0.0.1 6379 quorum 1</span>
3839:X 21 Jan 2021 01:02:39.669 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
3839:X 21 Jan 2021 01:02:39.670 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</code></pre>
<p>其中 +slave 表示新发现了从数据库，可见哨兵成功地发现了两个从数据库。现在哨兵已经在监控 3 个 Redis 实例了，这时我们将主数据库关闭（即运行在 639 端口上的 Redis 实例，杀死进程或使用 SHUTDOWN 命令）,等待指定时间后（可以配置，默认为 30 秒），哨兵会输出一下内容：</p>
<pre class=" language-shell"><code class="language-shell">3839:X 21 Jan 2021 01:10:29.111 # +sdown master mymaster 127.0.0.1 6379
3839:X 21 Jan 2021 01:10:29.111 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1</code></pre>
<p>其中 <code>+sdown</code> 表示哨兵主观认为主数据库停止服务了，而 <code>+odown</code> 则表示哨兵客观认为主数据库停止服务了，关于客观和主管的区别后文会详细介绍。此时哨兵开始执行故障恢复，即挑选一个从数据库，将其升格为主数据库。同时输出以下内容：</p>
<pre class=" language-shell"><code class="language-shell">3839:X 21 Jan 2021 01:10:29.111 # +try-failover master mymaster 127.0.0.1 6379
...
3839:X 21 Jan 2021 01:10:30.561 # +failover-end master mymaster 127.0.0.1 6379
3839:X 21 Jan 2021 01:10:30.561 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380</code></pre>
<p><code>+try-failover</code> 表示哨兵开始进行故障恢复，<code>+failover-end</code> 表示哨兵完成故障恢复，期间设计的内容比较复杂，包括领头哨兵的选举、备选从数据库的选择等。<code>+switch-master</code> 表示主数据库从 6379 端口迁移到 6380 端口，即 6380 端口的从数据库被升格为主数据库，同时两个 <code>+slave</code> 则列出了2个新的从数据库，端口分别为 6381 和 6379。</p>
<pre class=" language-shell"><code class="language-shell">3839:X 21 Jan 2021 01:10:30.561 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380
3839:X 21 Jan 2021 01:10:30.561 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380
3839:X 21 Jan 2021 01:11:00.587 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</code></pre>
<p>其中 6379 就是之前停止服务的主数据库，可见哨兵并没有彻底清除停止服务的实例的信息，这时因为停止服务的实例有可能会在之后的某个时间恢复服务，这时哨兵会让其重新加入进来，所以当实例停止服务后，哨兵会更新该实例的信息，使得当其重新重新加入后可以按照当时信息继续对外提供服务。此例中 6379 端口的主数据库实例停止服务了，而 6380 端口的从数据已经升格为主数据库，当 6379 端口的实例恢复服务后，会转变成 6380 端口实例的从数据库来运行，所以哨兵将 6379 端口实例的信息改成了 6380 端口实例的从数据库。</p>
<p>故障恢复完成后，可以使用 Redis 命令行客户端重新检查 6380 和 6381 两个端口上的实例的复制信息：</p>
<pre class=" language-bash"><code class="language-bash">redis 6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:1
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>59364,lag<span class="token operator">=</span>1

redis 6381<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6380</code></pre>
<p>可以看到 6380 端口上的实例已经确实升格为主数据库了，同时 6381 端口上的实例是其从数据库。整个故障恢复过程就此完成。</p>
<p>那么此时我们将 6379 端口上的实例重新启动，会发生什么情况呢？首先哨兵会监控到这一变化，并输出：</p>
<pre class=" language-bash"><code class="language-bash">3839:X 21 Jan 2021 01:37:10.815 <span class="token comment" spellcheck="true"># -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span>
3839:X 21 Jan 2021 01:37:20.745 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</code></pre>
<p><code>sdown</code> 表示实例 6379 已经恢复服务了（与 <code>+sdown</code> 相反），同时 <code>+convert-to-slave</code> 表示将 6379 端口的实例设置为 6380 端口实例的从数据库。这时使用 Redis 命令行客户端查看 6379 端口实例的复制信息为：</p>
<pre class=" language-bash"><code class="language-bash">redis 6379<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6380</code></pre>
<p>同时 6380 端口实例的复制信息为：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>153516,lag<span class="token operator">=</span>1
slave1:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6379,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>153516,lag<span class="token operator">=</span>0</code></pre>
<p>正如预期一样，6380 端口实例的从数据库变味了两个，6379 成功恢复服务。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>一个哨兵进程启动时会读取配置文件的内容，通过如下的配置找出需要监控的主数据库：</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor master-name ip redis-port quorum</code></pre>
<p>其中 master-name 是一个由大小写字母、数字和 “.-_” 组成的主数据库的名字，因为考虑到故障恢复后当前监控的系统的主数据库的地址和端口会产生变化，所以哨兵提供了命令可以通过主数据库的名字获取当前系统的主数据库地址和端口号。</p>
<p><code>ip</code> 表示当前系统中主数据库的地址，而 <code>redis-port</code> 则表示端口号。</p>
<p><code>quorum</code> 用来表示执行故障恢复操作前至少需要几个哨兵节点同意。一个哨兵节点可以同时监控多个 Redis 主从系统，只需要提供多个 <code>sentinel monitor</code> 配置即可，例如：</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor mymaster 127.0.0.0.1 6379 2
sentinel monitor othermaster 192.168.1.1 6380 4</code></pre>
<p>同时多个哨兵节点也可以同时监控一个 Redis 主从系统，从而形成网状结构。</p>
<p>配置文件中还可以定义其它监控相关的参数，每个配置选项都包含主数据库的名字使得监控不同主数据库时可以使用不同的配置参数。例如：</p>
<pre class=" language-bash"><code class="language-bash">sentinel down-after-milliseconds mymaster 60000
sentinel down-after-milliseconds othermaster 10000</code></pre>
<p>上面的两行配置分别配置了 <code>mymaster</code> 和 <code>othermaster</code> 的 down-after-milliseconds 选项分别为 60000 和 10000。</p>
<p>哨兵启动后，会与要监控的主数据库建立两条连接，这两个连接的建立方式与普通的 Redis 客户端无异。其中一条连接用来订阅该主数据库的 <code>_sentinel_:hello</code> 频道以获取其它同样监控该数据库的哨兵节点信息，另外哨兵也需要定期向主数据发送 INO 等命令来获取主数据库本身的信息。因为当客户端进入订阅模式时就不能再执行其它命令了，所以这时哨兵会使用另外一条连接来发送这些命令。</p>
<p>和主数据库的连接建立完成后，哨兵会定时执行下面 3 个操作：</p>
<ol>
<li>每 10 秒哨兵会向主数据库和从数据库发送 INFO 命令。</li>
<li>每 2 秒哨兵会向主数据库和从数据库的 <code>_sentinel_:hello</code> 频道发送自己的信息。</li>
<li>每 1 秒会向主数据库、从数据库和其它哨兵节点发送 PING 命令。</li>
</ol>
<p>这 3 个操作贯穿哨兵进程的整个生命周期中，非常重要，可以说了解了这 3 个操作的意义就能够了解哨兵工作原理的一般内容了。下面分别详细介绍。</p>
<p>首先，发送 INFO 命令使得哨兵可以获得当前数据库的相关信息（包括运行 ID 、复制信息等）从而实现新节点的自动发现。前面说配置哨兵监控 Redis 主从系统时只需要指定主数据库的信息即可，因为哨兵正是借助 INFO 命令来获取所有复制该主数据库的从数据库信息的。启动后，哨兵向主数据库发送 INFO 命令，通过解析返回结果来得知从数据库列表，而后对每个从数据库同样建立两个连接，两个连接的作用和刚刚介绍的与主数据库建立的两个连接完全一致。在此之后，哨兵会每 10 秒定时向已知的所有主从数据库发送 INFO 命令来获取信息并进行相应的更新操作，比如对新增的从数据库建立连接并加入监控列表，对主从数据库的角色变化（由故障恢复操作引起）进行信息更新等。</p>
<p>接下来哨兵向主从数据库的<code>_sentinel_:hello</code> 频道发送消息来与同样监控该数据库的哨兵分享自己的信息。发送的消息内容为：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>哨兵的地址<span class="token operator">></span>，<span class="token operator">&lt;</span>哨兵的端口<span class="token operator">></span>，<span class="token operator">&lt;</span>哨兵的运行ID<span class="token operator">></span>，<span class="token operator">&lt;</span>哨兵的配置版本<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的名字<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的地址<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的端口<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的配置版本<span class="token operator">></span></code></pre>
<p>可以看到消息包括哨兵的基本信息，以及其监控的主数据库的信息。刚刚介绍过，哨兵会订阅每个监控的数据库<code>_sentinel_:hello</code> 频道，所以当其它哨兵收到消息后，会判断发消息的哨兵是不是新发现的哨兵。如果是则将其加入已发现的哨兵列表中并创建一个到其的连接（与数据库不同，哨兵与哨兵之间只会创建一条连接用来发送 PING 命令，而不需要创建另外一条连接来订阅频道，因为哨兵只需要订阅数据库的频道即可实现自动发现其它哨兵）。同时哨兵会判断信息中主数据库的配置版本，如果该版本比当前记录的主数据库的版本高，则更新主数据库中的数据。</p>
<p>实现了自动发现从数据库和其它哨兵节点后，哨兵要做的就是定时监控这些数据库和节点有没有停止服务。这是通过每隔一定时间向这些节点发送 PING 命令实现的。时间间隔与 <code>down-after-milliseconds</code> 选项有关，当  <code>down-after-milliseconds</code>  的值小于 1 秒时，哨兵会每隔  <code>down-after-milliseconds</code>  指定的时间发送一次 PING 命令，当  <code>down-after-milliseconds</code> 的值大于 1 秒时，哨兵会每隔 1 秒发送一次 PING 命令。例如：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 每隔 1 秒发送一次 PING 命令</span>
sentinel down-after-milliseconds mymaster 60000
<span class="token comment" spellcheck="true"># 每隔 600 毫秒发送一次 PING 命令</span>
sentinel down-after-milliseconds othermaster 500</code></pre>
<p>当超过 <code>down-after-milliseconds</code> 选项指定时间后，如果被 PING 的数据库或节点仍然未进行回复，则哨兵认为其<strong>主观下线（subjectively down）</strong>。主观下线表示从当前的哨兵进程看来，该节点已经下线。如果该节点是主数据库，则哨兵会进一步判断是否需要对其进行故障恢复：哨兵发送 <code>SENTINEL is-master-down-by-addr</code> 命令询问其它哨兵节点以了解它们是否也认为该主数据库主观下线，如果达到指定数量时，哨兵会认为其<strong>客观下线（objectively down）</strong>，并选举领头的哨兵节点对主从系统发起故障恢复。这个指定数量即为前文介绍的 quorum 参数。例如，下面的配置：</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor mymaster 127.0.0.1 6379 2</code></pre>
<p>该配置表示只有当至少两个 Sentinel 节点（包括当前节点）认为该主数据库主观下线时，当前哨兵节点才会认为该主数据库客观下线。进行接下来的选举领头哨兵步骤。</p>
<p>虽然当前哨兵节点发现了主数据库客观下线，需要故障恢复，但是故障恢复需要由领头的哨兵来完成，这样可以保证同一时间只有一个哨兵节点来执行故障恢复。选举领头哨兵的过程使用了 Raft 算法，具体过程如下：</p>
<ol>
<li>发现主数据库客观下线的哨兵节点（下面称作 A）向每个哨兵节点发送命令，要求对方选自己为领头哨兵。</li>
<li>如果目标哨兵节点没有选过其它人，则会同意将 A 设置成领头哨兵。</li>
<li>如果 A 发现有超过半数且超过 quorum 参数值的哨兵节点同意选自己成为领头哨兵，则 A 成功成为领头哨兵。</li>
<li>当有多个哨兵节点同时参选领头哨兵，则会出现没有任何节点当选的可能。此时每个参选节点将等待一个随机时间重新发起参数请求，进行下一轮选举，直到选举成功。</li>
</ol>
<p>因为要成为领头哨兵必须有超过半数的哨兵节点支持，所以每次选举最多只会选出一个领头哨兵。选出领头哨兵后，领头哨兵将会开始对主数据库进行故障恢复。故障恢复的过程相对简单，具体如下：</p>
<p>首先领头哨兵将从停止服务的主数据库的从数据库中挑选一个来充当新的主数据库。挑选的依据如下：</p>
<ol>
<li>所有在线的从数据库中，选择优先级别最高的从数据库。优先级可以通过 <code>slave-priority</code> 选项来设置。</li>
<li>如果有多个最高优先级的从数据库，则复制的命令偏移量越大（即复制越完成）越优先，</li>
<li>如果以上条件都一样，则选择运行 ID 较小的从数据库。</li>
</ol>
<p>选出一个从数据库后，领头哨兵将向从数据库发送 <code>SLAVE NO ONE</code> 命令使其升格为主数据库。而后领头哨兵向其它从数据库发送 <code>SLAVEOF</code> 命令来使其成为新主数据库的从数据库。最后一步则是更新内部的记录，将已经停止服务的旧的主数据库更新为新的主数据库的从数据库，使得当其恢复服务时自动以从数据库的身份继续服务。</p>
<h3 id="哨兵的部署"><a href="#哨兵的部署" class="headerlink" title="哨兵的部署"></a>哨兵的部署</h3><p>哨兵以独立进程的方式对一个主从系统进行监控，监控效果的好坏与否取决于哨兵的视角是否有代表性。如果一个主从系统中配置的哨兵较少，哨兵对整个系统的判断的可靠性就会降低。极端情况下，当只有一个哨兵时，哨兵本身就很有可能发生单点故障。整体来讲，相对稳妥的哨兵部署方案是使得哨兵的视角尽可能地与每个节点的视角一致，即：</p>
<ul>
<li>为每个节点（无论是主数据库还是从数据库）部署一个哨兵</li>
<li>使每个哨兵与其对应的节点的网络环境相同或相近</li>
</ul>
<p>这样的部署方案可以保证哨兵的视角拥有较高的代表性和可靠性。举一个例子：当网络分区后，如果哨兵认为某个分区是主要分区，即意味着从每个节点观察，该分区均为主分区。</p>
<p>同时设置 quorum 的值为 <code>N / 2 + 1</code> (其中 N 为哨兵节点数量)，这样使得只有大部分哨兵节点同意后才会进行故障恢复。</p>
<p>当系统中的节点较多时，考虑到每个哨兵都会和系统中的所有节点建立连接，为每个节点分配一个哨兵会产生较多连接，尤其当进行客户端分片时使用多个哨兵节点监控多个主数据库会因为 Redis 不支持连接复用而产生大量冗余连接，同时如果 Redis  节点负载较高，会在一定程度上影响其对哨兵的回复和同机的哨兵与其它节点的通信。所以配置哨兵时还需根据实际的生产环境进行选择。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群</title>
    <url>/posts/119d.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>即使使用哨兵，此时的 Redis 集群的每个数据库依然存有集群中的所有数据，从而导致集群的总数据存储量受限于可用存储内存最小的数据库节点，形成木桶效应。由于 Redis 中的所有数据都是基于内存存储，这一问题尤为突出了，尤其是当使用 Redis 做持久化存储服务使用时。</p>
<p>对 Redis 进行水平扩容，在旧版 Redis 中通常使用客户端分片来解决这个问题，即启动多个 Redis 数据库节点，由客户端决定每个键交由哪个数据库节点存储，下次客户端读取改键时直接到该节点读取。这样可以实现将整个数据库分布存储在 N 个数据库节点中，每个节点只存放总数据量的 1/N。但对于需要扩容的场景来说，在客户端分片后，如果想增加更多的节点，就需要对数据进行手工迁移，同时在迁移的过程中为了保证数据的一致性，还需要将集群暂时下线，相对比较复杂。</p>
<p>考虑到 Redis 实例非常轻量的特点，可以采用预分片技术（<code>presharding</code>）来一定程度上避免此问题，具体来说是在节点部署初期，就提前考虑日后的存储规模，建立足够多的实例（如 128 个节点），初期时数据很少，所以每个节点存储的数据也非常少，但由于节点轻量的特性，数据之外的内存开销并不大，这使得只需要很少的服务器即可运行这些实例。日后存储规模扩大后，所要做的不过是将某些实例迁移到其它服务器上去，而不需要对所有数据进行重新分片并进行集权下线和数据迁移了。</p>
<p>无论如何，客户端分片终归是有非常多的缺点，比如维护成本高，增加、移除节点较繁琐等。Redis 3.0 版的一大特性就是支持集群（Cluster）功能。集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。另外集群支持几乎所有的单机实例支持的命令，对于涉及多键的命令（如 MGET），如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外集群还有一个限制是只能使用默认的 0 号数据库，如果执行 SELECT 切换数据库则会提示错误。</p>
<p>哨兵与集群是两个独立的功能，但从特性来看哨兵可以视为集群的子集，当不需要数据分片或者已经在客户端进行分片的场景下哨兵就足够使用了，但如果需要进行水平扩容，则集权是一个非常好的选择。</p>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p>使用集群，只需要将每个数据库节点的 <code>cluster-enabled</code> 配置选项打开即可。每个集群中至少需要三个主数据库才能正常运行。</p>
<p>为了演示集群的应用场景以及故障恢复等操作，这里以配置一个 3 主 3 从的集群系统为例。首先建立启动 6 个 Redis 实例，需要注意的是配置文件中应该打开 <code>cluster-enabled</code>。 一个示例配置为：</p>
<pre class=" language-shell"><code class="language-shell">port 6380
cluster-enabled yes</code></pre>
<p>其中 port 参数修改成实际的端口即可。这里假设 6 个实例的端口分别是 6380、6381、6382、6383、6384 和 6385。集群会将当前节点记录的集群状态持久化地存储在指定地文件中，这个文件默认为当前工作目录下的 <code>nodes.conf</code> 文件。每个节点对应的文件必须不同，否则会造成启动失败：</p>
<pre class=" language-bash"><code class="language-bash">Sorry, the cluster configuration <span class="token function">file</span> nodes.conf is already used by a different Redis Cluster node. Please <span class="token function">make</span> sure that different nodes use different cluster configuration files.</code></pre>
<p>所以启动节点时要注意最后为每个节点使用不同的工作目录，或者通过 <code>cluster-config-file</code> 选项修改持久化文件的名称：</p>
<pre class=" language-bash"><code class="language-bash">cluster-config-file nodes.conf</code></pre>
<p>每个节点启动后都会输出类似下面的内容：</p>
<pre class=" language-bash"><code class="language-bash">No cluster configuration found, I'm ef81cf4da7040c9d93bc85cfd358ed3886080fb4</code></pre>
<p>其中 <code>ef81cf4da7040c9d93bc85cfd358ed3886080fb4</code> 表示该节点的运行 ID，运行 ID 是节点在集群中的唯一标识；同一个运行 ID ，可能地址和端口是不同的。</p>
<p>启动后，可以使用 Redis 命令行客户端连接任意一个节点使用 INFO 命令来判断集群是否正常启用了：</p>
<pre class=" language-bash"><code class="language-bash">$ INFO cluster
<span class="token comment" spellcheck="true"># Cluster</span>
cluster_enabled:1</code></pre>
<p>其中 cluster_enabled 为 1 表示集群正常启用了。现在每个节点都是完全独立的，要将它们加入同一个集群里还需要几个步骤。</p>
<ul>
<li>初始化集群</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385</code></pre>
<p>其中 <code>create</code> 参数表示要初始化集群， <code>--cluster-replicas 1</code> 表示每个主数据库拥有的从数据库个数为 1，所有整个集群共有3（6/2）个主数据库以及 3 个从数据库。</p>
<p>执行完后会输出如下内容：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385

<span class="token operator">>></span><span class="token operator">></span> Performing <span class="token function">hash</span> slots allocation on 6 nodes<span class="token punctuation">..</span>.
Master<span class="token punctuation">[</span>0<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 0 - 5460
Master<span class="token punctuation">[</span>1<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 5461 - 10922
Master<span class="token punctuation">[</span>2<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 10923 - 16383
Adding replica 127.0.0.1:6384 to 127.0.0.1:6380
Adding replica 127.0.0.1:6385 to 127.0.0.1:6381
Adding replica 127.0.0.1:6383 to 127.0.0.1:6382
<span class="token operator">>></span><span class="token operator">></span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity
<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same host as their master
M: 70448213e6665fcaea8ed94d7f77b31db0ef3a43 127.0.0.1:6380
   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master
M: ef81cf4da7040c9d93bc85cfd358ed3886080fb4 127.0.0.1:6381
   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> master
M: f4ae8d7e88aacb0bf60cf926f143474d7dc4950c 127.0.0.1:6382
   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master
S: 4ab18f8ac3f516f48922df4319154f3cd5361310 127.0.0.1:6383
   replicates 70448213e6665fcaea8ed94d7f77b31db0ef3a43
S: a1a19b41fb7736ac610a46c448ebd000cb4a342e 127.0.0.1:6384
   replicates ef81cf4da7040c9d93bc85cfd358ed3886080fb4
S: bddfa2c27943030592fe138cdc37697ff33d1f28 127.0.0.1:6385
   replicates f4ae8d7e88aacb0bf60cf926f143474d7dc4950c
Can I <span class="token keyword">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>:</code></pre>
<p>内容包括集群具体的分配方案，如果觉得没问题则输入 yes 来开始创建。首先客户端会尝试连接所有的节点，并发送 PING 命令以确定节点能够正常服务。如果有任何节点无法连接，则创建失败。同时发送 <code>INFO</code> 命令获取每个节点的运行 ID 以及开启了集群的功能（即 cluster_enabled 为 1）。</p>
<p>准备就绪后集群会向每个节点发送 <code>CLUSTER MEET</code> 命令，格式为：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER MEET ip port</code></pre>
<p>这个命令用来告诉当前节点指定 <code>ip</code> 和 <code>port</code> 上在运行的节点也是集群的一部分，从而使得 6 个节点最终可以归为一个集群。在分配主从数据库节点，分配的原则是尽量保证每个主数据库运行在不同的 IP 低智商，同时每个从数据库和主数据库均不运行在同一 IP 地址上，以保证系统的容灾能力。分配结果如下：</p>
<pre class=" language-bash"><code class="language-bash">Master<span class="token punctuation">[</span>0<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 0 - 5460
Master<span class="token punctuation">[</span>1<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 5461 - 10922
Master<span class="token punctuation">[</span>2<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 10923 - 16383
Adding replica 127.0.0.1:6384 to 127.0.0.1:6380
Adding replica 127.0.0.1:6385 to 127.0.0.1:6381
Adding replica 127.0.0.1:6383 to 127.0.0.1:6382</code></pre>
<p>其中主数据库是 6380、6381 和 6382 端口上的节点（以下使用端口号来指代节点），6384 是 6380 的从数据库，6385 是 6381 的从数据库，6383 是 6382 的从数据库。</p>
<p>分配完成后，会为每个主数据库分配插槽，分配插槽的过程其实就是分配哪些键归哪些节点负责。之后对每个要成为子数据库的节点发送 ：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER REPLICATE 主数据库的运行ID</code></pre>
<p>来将当前当前节点转换成从数据库并复制指定运行 ID 的节点（主数据库）。</p>
<p>此时整个集群的过程即创建完成，使用 Redis 命令行客户端连接任意一个节点执行 :</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER NODES</code></pre>
<p>可以获得集群中的所有节点信息：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER nodes
fc0bb101cb9fb83cc7387c5436cea4e31f37933a 127.0.0.1:6380@16380 myself,master - 0 1611279056000 1 connected 0-5460
4092663430bae1fc3b2cfc6a622e56e0bd6cdd42 127.0.0.1:6383@16383 slave 789ff268a004e79d27298b08ac14b6e7927ed8a7 0 1611279058000 3 connected
a1a19b41fb7736ac610a46c448ebd000cb4a342e 127.0.0.1:6384@16384 slave fc0bb101cb9fb83cc7387c5436cea4e31f37933a 0 1611279058000 1 connected
789ff268a004e79d27298b08ac14b6e7927ed8a7 127.0.0.1:6382@16382 master - 0 1611279059797 3 connected 10923-16383
bddfa2c27943030592fe138cdc37697ff33d1f28 127.0.0.1:6385@16385 slave ba332a22254bd3dbaa8c2900f97b882ee245cf77 0 1611279058000 2 connected
ba332a22254bd3dbaa8c2900f97b882ee245cf77 127.0.0.1:6381@16381 master - 0 1611279058786 2 connected 5461-10922</code></pre>
<p>从上面的输出中可以看到所有节点的运行 ID、地址和端口、角色、状态以及负载的插槽等信息。</p>
<h3 id="节点的增加"><a href="#节点的增加" class="headerlink" title="节点的增加"></a>节点的增加</h3><p>加入新节点非常简单，只需要向新节点（一下记作 A） 发送如下命令即可：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER MEET ip port</code></pre>
<p>IP 和 PORT 是集群中任意一个节点的地址和端口号，A 接收到客户端发来的命令后，会与 该地址和端口号 的节点 B 进行握手，使 B 将 A 认作当前集群中的一员。当 B 与 A 握手成功后，B 会使用 <code>Grossip</code> 协议将节点A的信息通知给集群中的每一个节点。通过这一方式，即使集群中有多个节点，也只需要选择 MEET 其中任意一个节点，即可使新节点最终加入整个集群中。</p>
<h3 id="插槽的分配"><a href="#插槽的分配" class="headerlink" title="插槽的分配"></a>插槽的分配</h3><p>新的节点加入集群中有两个选择，要么使用 <code>CLUSTER REPLICATE</code> 命令复制每个主数据库来以从数据库的形式运行，要么向集群申请分配插槽（slot） 来以主数据库的形式运行。</p>
<p>在一个集群中，所有的键会被分配成 16384 个插槽，而每个主数据库会负责处理其中的一部分插槽。现在再回头来看创建集群时的输出：</p>
<pre class=" language-bash"><code class="language-bash">fc0bb101cb9fb83cc7387c5436cea4e31f37933a 127.0.0.1:6380@16380 myself,master - 0 1611279056000 1 connected 0-5460
789ff268a004e79d27298b08ac14b6e7927ed8a7 127.0.0.1:6382@16382 master - 0 1611279059797 3 connected 10923-16383
ba332a22254bd3dbaa8c2900f97b882ee245cf77 127.0.0.1:6381@16381 master - 0 1611279058786 2 connected 5461-10922</code></pre>
<p>上面的每一行表示一个主数据库的信息，其中可以看到 6380 负责处理 0<del>5460 这 5461 个插槽，6381 负责处理 5461 ~ 10922 这 5462 个插槽，6382 则负责处理 10923</del>16383 这 5461 个插槽。虽然初始化集群时分配给每个节点的插槽都是连续的，但是实际上 Redis 并没有此限制，可以将任意的几个插槽分配给任意的节点负责。</p>
<p>在介绍如何将插槽分配给指定的节点前，先来介绍键与插槽的对应关系。Redis 将每个键的键名的有效部分使用 CRC16 算法计算出散列值，然后去对 16384 的余数。这样使得每个键都可以分配到 16384 个插槽中，进而分配给执行的一个节点中处理。 这里键名的有效部分是指：</p>
<ul>
<li>如果键名包含 { 符号，且在符号的后面存在 } 符号，并且 { 和 } 之间有至少一个字符，则有效部分是指 { 和 } 之间的内容；</li>
<li>如果不满足上一条规则，那么整个键名为有效部分。</li>
</ul>
<p>例如，键 <code>hello.world</code> 的有效部分为 <code>“hello.world”</code>，键 <code>{user102}:last.name</code> 的有效部分为 <code>user102</code>。如果命令设计多个键（如 MGET），只有当所有键都位于同一个节点时 Redis 才能正常支持。利用键的分配规则，可以将所有相关键的有效部分设置成同样的值使得相关键都能分配到同一个节点以支持多键操作。比如，<code>{user102}:first.name</code> 和 <code>{user102}:last:name</code> 会被分配到同一个节点，所以可以使用：</p>
<pre class=" language-bash"><code class="language-bash">$ MGET <span class="token punctuation">{</span>user102<span class="token punctuation">}</span>:first.name <span class="token punctuation">{</span>user102<span class="token punctuation">}</span>:last.name </code></pre>
<p>来同时获取这两个键的值。</p>
<p>介绍完键与插槽的对应关系后，接下来再来介绍如何将插槽分配给执行节点。插槽的分配分为如下情况：</p>
<ul>
<li>插槽之前没有被分配过，现在向分配给指定节点。</li>
<li>插槽之前被分配过，现在想移动到指定节点。</li>
</ul>
<p>其中第一种情况使用 <code>CLUSTER ADDSLOTS</code> 来实现。 <code>CLUSTER ADDSLOTS</code> 命令的用法为：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER ADDSLOTS slot1 <span class="token punctuation">[</span>slot2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. <span class="token punctuation">[</span>slotN<span class="token punctuation">]</span></code></pre>
<p>如想将 100 和 101 两个插槽分配给某个节点，只需要在该节点执行：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER ADDSLOTS 100 101</code></pre>
<p>如果执行插槽已经分配过了，则会提示：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR Slot 100 is already busy</code></pre>
<p>可以通过命令 <code>CLUSTER SLOTS</code> 来查看插槽的分配情况，如：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER SLOTS
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5460
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6380
      3<span class="token punctuation">)</span> <span class="token string">"fc0bb101cb9fb83cc7387c5436cea4e31f37933a"</span>
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6384
      3<span class="token punctuation">)</span> <span class="token string">"a1a19b41fb7736ac610a46c448ebd000cb4a342e"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10923
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 16383
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6382
      3<span class="token punctuation">)</span> <span class="token string">"789ff268a004e79d27298b08ac14b6e7927ed8a7"</span>
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6383
      3<span class="token punctuation">)</span> <span class="token string">"4092663430bae1fc3b2cfc6a622e56e0bd6cdd42"</span>
3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5461
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10922
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6381
      3<span class="token punctuation">)</span> <span class="token string">"ba332a22254bd3dbaa8c2900f97b882ee245cf77"</span>
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6385
      3<span class="token punctuation">)</span> <span class="token string">"bddfa2c27943030592fe138cdc37697ff33d1f28"</span></code></pre>
<p>其中返回结果的格式很容易理解，一共 3 条记录，每条记录的前两个值表示插槽的开始号码和结束号码，后面的值则为负责该插槽的节点，包括主数据库和所有的从数据库，主数据库始终在第一位。</p>
<p>对于情况2，处理起来相对复杂一些，我们首先将一个插槽从 6380 迁移到 6381，执行如下命令：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER SETSLOT 插槽号 NODE 新节点运行的ID</code></pre>
<p>如想要把 0 号插槽迁移到 6381：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ba332a22254bd3dbaa8c2900f97b882ee245cf77 是 6381 的运行 id</span>
redis 6380<span class="token operator">></span> CLUSTER SETSLOT 0 NODE ba332a22254bd3dbaa8c2900f97b882ee245cf77
OK</code></pre>
<p>此时重新使用 <code>CLUSTER SLOTS</code> 查看插槽的分配情况：</p>
<pre class=" language-bash"><code class="language-bash">fc0bb101cb9fb83cc7387c5436cea4e31f37933a 127.0.0.1:6380@16380 myself,master - 0 1611283004000 1 connected 1-5460

ba332a22254bd3dbaa8c2900f97b882ee245cf77 127.0.0.1:6381@16381 master - 0 1611283005000 2 connected 0 5461-10922</code></pre>
<p>然而这样迁移插槽的前提是插槽中并没有任何键，因为使用 <code>CLUSTER SETSLOT</code> 命令迁移插槽时并不会连同相应的键一起迁移，这就造成了客户端在指定节点无法找到未迁移的键，造成这些键对客户端来说“丢失了”，为此需要手工获取插槽中存在哪些键，然后将每个键迁移到新的节点中才能运行。</p>
<p>手工获取某个插槽中存在哪些键的方法时：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER GETKEYSINSLOT 插槽号 要返回的键的数量</code></pre>
<p>之后对每个键，使用 MIGRATE 命令将其迁移到目标节点：</p>
<pre class=" language-bash"><code class="language-bash">$ MIGRATE 目标节点地址 目标节点端口 键名 数据库号码 超时时间 <span class="token punctuation">[</span>COPY<span class="token punctuation">]</span> <span class="token punctuation">[</span>REPLACE<span class="token punctuation">]</span></code></pre>
<p>其中 <code>COPY</code> 选项表示不将键从当前数据库中删除，而是复制一份副本。<code>REPLACE</code> 表示如果目标节点存在同名键，则覆盖。因为集群模式只能使用 0 号数据库，所以数据库号码始终为 0。如要把键 <code>abc</code> 从当前节点（如 6381）迁移到 6380：</p>
<pre class=" language-bash"><code class="language-bash">redis 6381<span class="token operator">></span> MIGRATE 127.0.0.1 6380 abc 0 16000 REPLACE</code></pre>
<p>至此，我们已经知道如果将插槽委派给其它节点，并同时将当前节点中插槽下所有的键迁移到目标节点中。然而还有最后一个问题是如果要迁移的数据量比较大，整个过程会发费较长时间，那么究竟什么时候执行 <code>CLUSTER SETSLOT</code> 命令来完成插槽的交接呢？如果在键迁移未完成时执行，那么客户端就会尝试在新的节点读取键值，此时还没有迁移完成，自然有可能读不到键值，从而造成相关键的“临时丢失”。相反，如果在键迁移完成后再执行，那么在迁移时客户端会在旧的节点读取键值，然后有些键已经迁移到新的节点上了，同时也会造成键的临时“丢失”。Redis 提供了如下两个命令用来实现再集群不下线的情况下迁移数据：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER SETSLOT 插槽号 MIGRATING 新节点的运行ID
$ CLUSTER SETSLOT 插槽号 IMPORTING 原节点的运行ID</code></pre>
<p>进行迁移时，假设要把 0 号插槽从 A 迁移到 B，此时会执行如下操作：</p>
<ol>
<li>在 B 执行 <code>CLUSTER SETSLOT 0 IMPORTING A 。</code></li>
<li>在 A 执行 CLUSTER SETSLOT 0 MIGRATING B。</li>
<li>执行 <code>CLUSTER GETKEYSINSLOT 0</code> 获取 0 号插槽的键列表。</li>
<li>对第 3 步获取的每个键执行 MIGRATE  命令，将其从 A 迁移到 B。</li>
<li>执行 <code>CLUSTER SETSLOT 0 NODE B</code> 来完成迁移。</li>
</ol>
<p>上面的 1 和 2 步骤就是为了解决迁移过程中键的临时 “丢失” 问题。首先执行完前两步后，当客户端 A 请求插槽 0 中的键时，如果键存在（即尚未被迁移），则正常处理，如果不存在，则返回一个 ASK 跳转请求，告诉客户端这个键在 B 里，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/16251611285456_.pic_hd.jpg"></p>
<p>客户端收到 ASK 跳转请求后，首先向 B 发送 ASKING 命令，然后再重新发送之前的命令。相反，当客户端向 B 请求插槽 0 中的键时，如果前面执行了 ASKING 命令，则返回键值内容，否则返回 MOVE 跳转请求。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/16241611285104_.pic_hd.jpg"></p>
<p>这样一来客户端只有能够处理 ASK 跳转，则可以在数据库迁移时自动从正确的节点获取到相应的键值，避免了键在迁移过程中临时 “丢失” 的问题。</p>
<h3 id="获取与插槽对应的节点"><a href="#获取与插槽对应的节点" class="headerlink" title="获取与插槽对应的节点"></a>获取与插槽对应的节点</h3><p>介绍了插槽的分配方式，对于指定的键，可以根据前面所说的算法来计算其属于哪个插槽，但是如何获取某一个键由哪个节点负责呢？</p>
<p>实际上，当客户端向集群中的任意一个节点发送命令后，该节点会判断相应的键是否在当前节点中，如果键在该节点中，就会像单机实例一样正确处理该命令：如果键不在该节点中，就会返回一个 MOVE 重定向请求，告诉客户端这个键目前由哪个节点负责，然后客户端再将同样的请求向目标节点重新发送一次以获得结果。</p>
<p>一些语言的 Redis 库支持代理 MOVE 请求，所以对于开发者而言命令重定向的过程是透明的，使用集权与使用单机实例并没有什么不同。然而也有些语言的 Redis 库并不支持集群，这时就需要在客户端编码处理了。</p>
<p>还是以上面的集群配置为例，键 foo 实际应该由 6382 节点负责，如果尝试在 6380 节点执行与键 foo 相关的命令，就会有如下输出：</p>
<pre class=" language-bash"><code class="language-bash">redis 6380<span class="token operator">></span> <span class="token keyword">set</span> foo bar
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> MOVED 12182 127.0.0.1:6382</code></pre>
<p>返回的是一个 MOVE 重定向请求，12182 表示 foo 所属的插槽号，127.0.0.1:6382 则是负责该插槽的节点地址和端口，客户端收到重定向请求后，应该将命令重新向 6382 节点发送一次：</p>
<pre class=" language-bash"><code class="language-bash">redis 6382<span class="token operator">></span> <span class="token keyword">set</span> foo bar
OK</code></pre>
<p>Redis 命令行客户端提供了集群模式来支持自动重定向，使用 -c 参数来启用：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -c -p 6380

redis 6380<span class="token operator">></span> <span class="token keyword">set</span> foo bar
-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>12182<span class="token punctuation">]</span> located at 127.0.0.1:6382
OK</code></pre>
<p>可见加入了 -c 参数后，如果当前节点并不负责要处理的键，Redis 命令行客户端会进行自动命令重定向。而这一过程正是负责集群的客户端应该实现的。</p>
<p>然而相比单机实例，集群的命令重定向也增加了命令的请求次数，原先只需要执行一次的命令，现在有可能一次发向两个节点，算上往返时延，可以说请求重定向对性能还是有些影响的。</p>
<p>为了解决这一问题，当发现新的重定向请求时，客户端应该在重新向正确节点发送命令的同时，缓存插槽的路由信息，即记录下当前插槽是由哪个节点负责的。这样每次发起命令时，客户端首先计算相关键是属于哪个插槽的，然后根据缓存的路由判断插槽由哪个节点负责。考虑到插槽总数相对较少（16384个），缓存所有插槽的路由信息后，每次命令将均只发向正确的节点，从而达到和单机实例同样的性能。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>在一个集群中，每个节点都会定期向其它节点发送 PING 命令，并通过有没有收到回复来判断目标节点是否已经下线了。具体来说，集群中的每个节点每个 1 秒就会随机选择 5 个节点，然后选择其中最久没有相应的节点发送 PING 命令。</p>
<p>如果一定时间内目标节点没有相应回复，则发起 PING 命令的节点会认为目标节点疑似下线（PFALL）。疑似下线可以与哨兵的主观下线类比，两者都表示某一节点从<strong>自身的角度认为</strong>目标节点是下线的状态。与哨兵的模式类似，如果要使在整个集群中的所有节点都认为某一节点已经下线，需要一定数量的节点都认为该节点疑似下线才可以，这一过程具体为：</p>
<ul>
<li>一旦节点 A 认为节点 B 是疑似下线状态，就会在集群中传播该消息，所有其它节点收到消息后都会记录下这一信息；</li>
<li>当集群中的某一节点 C 收集到半数以上的节点认为 B 是疑似下线的状态时，就会将 B 标记为下线（FALL），并且向集群中的其它节点传播该消息，从而使得 B 在整个集群中下线。</li>
</ul>
<p>在集群中，当一个主数据库下线时，就会出现一部分插槽无法写入的问题。这时如果该主数据库拥有至少一个从数据库，集群就进行故障恢复操作来将其中一个从数据库转变成主数据库来保证集群的完成。选择哪个从数据库来作为主数据库的过程与在哨兵中选择领头哨兵的过程一样，都是基于Raft 算法，过程如下：</p>
<ol>
<li>发现其复制的主数据库下线的从数据库库（下面称作 A）向每个集群中的节点发送请求，要求对方选自己成为主数据库。</li>
<li>如果请求的节点没有选过其他人，则会同意 A 设置成主数据库。</li>
<li>如果 A 发现有超过集群中节点总数一半的节点同意选自己成为主数据库，则 A 成功成为主数据库。</li>
<li>当有多个从数据库节点同时参选主数据库，则会出现没有任何节点当选的可能。此时每个参选点将等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。</li>
</ol>
<p>当某个从数据库当选为主数据库后，会通过命令 <code>SLAVEOF NO ONE</code> 将自己转换成主数据库，并将旧的数据库插槽转换给自己负责。</p>
<p>如果至少负责一个插槽的主数据库下线且没有相应的从数据库可以进行故障恢复，则整个集群默认会进入下线状态无法继续工作。如果想在这种情况下使集群仍能正常工作，可以修改配置：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 默认为 yes</span>
cluster-require-full-coverge no</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用各种条件进行提取</title>
    <url>/posts/2693.html</url>
    <content><![CDATA[<h3 id="准备表"><a href="#准备表" class="headerlink" title="准备表"></a>准备表</h3><p>我们将使用表 tb 来练习 SELECT 的用法。</p>
<table>
<thead>
<tr>
<th>empid</th>
<th>sales</th>
<th>month</th>
</tr>
</thead>
<tbody><tr>
<td>A103</td>
<td>101</td>
<td>4</td>
</tr>
<tr>
<td>A102</td>
<td>54</td>
<td>5</td>
</tr>
<tr>
<td>A104</td>
<td>181</td>
<td>4</td>
</tr>
<tr>
<td>A101</td>
<td>184</td>
<td>4</td>
</tr>
<tr>
<td>A103</td>
<td>17</td>
<td>5</td>
</tr>
<tr>
<td>A101</td>
<td>300</td>
<td>5</td>
</tr>
<tr>
<td>A102</td>
<td>205</td>
<td>6</td>
</tr>
<tr>
<td>A104</td>
<td>93</td>
<td>5</td>
</tr>
<tr>
<td>A103</td>
<td>12</td>
<td>6</td>
</tr>
<tr>
<td>A107</td>
<td>87</td>
<td>6</td>
</tr>
</tbody></table>
<p>表 tb 由员工号（empid）、销售额（sales）和月份（month） 3个列组成。</p>
<h3 id="计算列值或处理字符串之后显示列"><a href="#计算列值或处理字符串之后显示列" class="headerlink" title="计算列值或处理字符串之后显示列"></a>计算列值或处理字符串之后显示列</h3><p>我们可以使用列中的数据自由地进行乘法和除法等四则运算。但在计算机的世界中不能直接使用符号 ✖️ 或者 ➗，而要使用下面列出的算数运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>使用示例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>a + b</td>
<td>a 加上 b</td>
</tr>
<tr>
<td>-</td>
<td>a - b</td>
<td>a 减去 b</td>
</tr>
<tr>
<td>*</td>
<td>a * b</td>
<td>a 乘以 b</td>
</tr>
<tr>
<td>/</td>
<td>a / b</td>
<td>a 除以 b</td>
</tr>
<tr>
<td>DIV</td>
<td>a DIV b</td>
<td>a 除以 b (结果取整)</td>
</tr>
<tr>
<td>%、MOD</td>
<td>a % b</td>
<td>a 除以 b 取余</td>
</tr>
</tbody></table>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT sales*10000 AS 销售额 from tb;
+-----------+
| 销售额    |
+-----------+
|   1010000 |
|    540000 |
|   1810000 |
|   1840000 |
|    170000 |
|   3000000 |
|   2050000 |
|    930000 |
|    120000 |
|    870000 |
+-----------+
10 rows in set (0.00 sec)</code></pre>
<p>另外如果是 “销售额(元)” 这种包含半角括号的情况，就需要使用 “ ” 将整个内容括起来来，即 <code>"销售额(元)"</code>，否则就会发生错误。</p>
<pre class=" language-bash"><code class="language-bash">ERROR 1064 <span class="token punctuation">(</span>42000<span class="token punctuation">)</span>: You have an error <span class="token keyword">in</span> your SQL syntax<span class="token punctuation">;</span> check the manual that corresponds to your MySQL server version <span class="token keyword">for</span> the right syntax to use near <span class="token string">'(销售额) from tb'</span> at line 1</code></pre>
<p>使用全角括号时，能够正常执行，不会发生错误，这一点需要注意。</p>
<h3 id="使用函数进行计算"><a href="#使用函数进行计算" class="headerlink" title="使用函数进行计算"></a>使用函数进行计算</h3><p>传入数据后，<strong>函数</strong> 会执行指定的处理并返回结果。例如，AVG这个函数会返回传入数据时的平均值。函数名的后面要加上（），（）里面是需要处理的数据。放在（）中的数据称为<strong>参数</strong>。</p>
<p>虽然上面提到的函数与 Excel 等表计算的函数基本相同，但在 SQL 语句中，（）中指定的大多是列名。例如，AVG(x) 会返回列 x 中数据的平均值。由于列 x 的值和记录数相对应，所以该函数表示列 x 中所有记录的平均值。</p>
<p>当指定作为函数处理对象的记录时，我们可以使用 WHERE 设置条件进行提取，也可以使用 GROUP BY 对记录进行分组计算。</p>
<p>下面我们来计算一下公司的平均销售额。执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">mysql> SELECT AVG(sales) FROM tb;
+------------+
| avg(sales) |
+------------+
|   123.4000 |
+------------+
1 row in set (0.01 sec)</code></pre>
<h4 id="显示总和"><a href="#显示总和" class="headerlink" title="显示总和"></a>显示总和</h4><pre class=" language-mysql"><code class="language-mysql">mysql> SELECT SUM(sales) FROM tb;
+------------+
| SUM(sales) |
+------------+
|       1234 |
+------------+
1 row in set (0.01 sec)</code></pre>
<h4 id="显示个数"><a href="#显示个数" class="headerlink" title="显示个数"></a>显示个数</h4><pre class=" language-mysql"><code class="language-mysql">SELECT count(sales) FROM tb;
+--------------+
| count(sales) |
+--------------+
|           10 |
+--------------+
1 row in set (0.00 sec)</code></pre>
<p>个数是 “10”。因为销售额总和是 “1234”，而个数是 “10”，所以可以得知平均值与 AVG(sales) 返回的 123.4 一致。</p>
<p>MySQL 中有很多内置函数。除了这里介绍的用于计算平均值、总和以及个数的统计函数，还有 sin、cos 这种数学处理函数，以及字符串函数、日期和时间函数等。这里仅介绍了其中的一个部分。</p>
<h3 id="用于显示各种信息的函数"><a href="#用于显示各种信息的函数" class="headerlink" title="用于显示各种信息的函数"></a>用于显示各种信息的函数</h3><p>下面来介绍一个和表完全无关的函数。PI 适用于返回圆周率的函数。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT PI();
+----------+
| PI()     |
+----------+
| 3.141593 |
+----------+
1 row in set (0.00 sec)</code></pre>
<p>像这样将函数和 SELECT 一起使用，就能够显示出与列和表无关的数据。</p>
<h4 id="显示-MySQL-服务器版本"><a href="#显示-MySQL-服务器版本" class="headerlink" title="显示 MySQL 服务器版本"></a>显示 MySQL 服务器版本</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT VERSION();
+-----------+
| VERSION() |
+-----------+
| 8.0.19    |
+-----------+
1 row in set (0.00 sec)</code></pre>
<h4 id="显示当前使用的数据库"><a href="#显示当前使用的数据库" class="headerlink" title="显示当前使用的数据库"></a>显示当前使用的数据库</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| db1        |
+------------+
1 row in set (0.00 sec)</code></pre>
<h4 id="显示当前用户"><a href="#显示当前用户" class="headerlink" title="显示当前用户"></a>显示当前用户</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT USER();
SELECT USER();
+----------------+
| USER()         |
+----------------+
| root@localhost |
+----------------+
1 row in set (0.00 sec)</code></pre>
<h4 id="显示由这个参数指定的字符的字符编码"><a href="#显示由这个参数指定的字符的字符编码" class="headerlink" title="显示由这个参数指定的字符的字符编码"></a>显示由这个参数指定的字符的字符编码</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT CHARSET('这个字符');
+-------------------------+
| CHARSET('这个字符')     |
+-------------------------+
| utf8mb4                 |
+-------------------------+
1 row in set (0.00 sec)</code></pre>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>MySQL 中还有很多用于处理字符串的函数。例如在连接字符串的时候，可以使用 CONCAT 函数。CONCAT 中指定的字符串列需要使用 “,” 进行分割。比如在连接列 a、b、c 的字符时，就需要写成 CONCAT(a, b, c)。该函数还可以直接指定字符串。</p>
<p>例如，员工信息表 tb1 的列 empid 表示员工号，列 name 表示姓名。下面试着显示内容为 “员工+姓名+先生” 的字符串。连接表 tb1 的列 empid、列 name 以及 “先生” 并将其显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT CONCAT(empid, name, '先生') FROM tb1;
+-------------------------------+
| CONCAT(empid, name, '先生')   |
+-------------------------------+
| N111松田先生                  |
+-------------------------------+
1 row in set (0.00 sec)</code></pre>
<p>当然，CONCAT 函数也可以连接 3 个以上的字符串。两外，“先生” 是字符串数据，不要忘记 “`” 把它括起来。</p>
<h3 id="字符串操作中常用的函数"><a href="#字符串操作中常用的函数" class="headerlink" title="字符串操作中常用的函数"></a>字符串操作中常用的函数</h3><h4 id="从右取出：RIGHT-函数"><a href="#从右取出：RIGHT-函数" class="headerlink" title="从右取出：RIGHT 函数"></a>从右取出：RIGHT 函数</h4><p>下面的命令用户显示列 empid 最右边的两个字符。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT RIGHT(empid, 2) FROM tb1;
+-----------------+
| RIGHT(empid, 2) |
+-----------------+
| 11              |
+-----------------+
1 row in set (0.00 sec)</code></pre>
<h4 id="从左取出：LEFT-函数"><a href="#从左取出：LEFT-函数" class="headerlink" title="从左取出：LEFT 函数"></a>从左取出：LEFT 函数</h4><p>下面的命令用于显示列 empid 最左边的 2 个字符。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT LEFT(empid, 2) FROM tb1;
+----------------+
| LEFT(empid, 2) |
+----------------+
| N1             |
+----------------+
1 row in set (0.00 sec)</code></pre>
<h4 id="从第-X-个字符开始截取字符：SUBSTRING-函数"><a href="#从第-X-个字符开始截取字符：SUBSTRING-函数" class="headerlink" title="从第 X 个字符开始截取字符：SUBSTRING 函数"></a>从第 X 个字符开始截取字符：SUBSTRING 函数</h4><p>下面的命令用于从列 empid 的第 2 个字符开始连续显示 3 个字符。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT SUBSTRING(empid, 2, 3) FROM tb1;
+------------------------+
| SUBSTRING(empid, 2, 3) |
+------------------------+
| 111                    |
+------------------------+
1 row in set (0.00 sec)</code></pre>
<p>在列 empid 的值为 “N111” 的情况下，显示为 “111”。</p>
<h4 id="重复显示：REPEAT-函数"><a href="#重复显示：REPEAT-函数" class="headerlink" title="重复显示：REPEAT 函数"></a>重复显示：REPEAT 函数</h4><p>下面的命令用于重复显示字符 “.”，其重复次数为列 age 的值。</p>
<pre class=" language-mysql"><code class="language-mysql"># age 是 28 所以显示 28 个 .
$ SELECT REPEAT('·', age) FROM tb1;
+----------------------------------------------------------+
| REPEAT('·', age)                                         |
+----------------------------------------------------------+
| ····························                             |
+----------------------------------------------------------+
1 row in set (0.00 sec)</code></pre>
<h4 id="反转显示：REVERSE-函数"><a href="#反转显示：REVERSE-函数" class="headerlink" title="反转显示：REVERSE 函数"></a>反转显示：REVERSE 函数</h4><p>下面把列 name 中的字符倒着显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT REVERSE(name) FROM tb1;
+---------------+
| REVERSE(name) |
+---------------+
| 田松          |
+---------------+
1 row in set (0.00 sec)</code></pre>
<h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><p>处理日期和时间的函数也有很多。下面将介绍 NOW 函数。</p>
<p>NOW 是用于返回当前日期和时间的函数。如果想自动设置执行处理的日期和时间，可以使用 NOW()。NOW() 会返回日期和时间，所以最好将输入设置为 DATETIME 类型。</p>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE t_now(a INT AUTO_INCREMENT PRIMARY KEY, b DATETIME);
$ INSERT INTO t_now (b) VALUES(NOW());</code></pre>
<h3 id="设置条件进行显示"><a href="#设置条件进行显示" class="headerlink" title="设置条件进行显示"></a>设置条件进行显示</h3><p>我们可以使用 <code>LIMIT</code> 来限制要显示的记录数。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 LIMIT 显示的记录数;</code></pre>
<h3 id="使用-WHERE-提取纪录"><a href="#使用-WHERE-提取纪录" class="headerlink" title="使用 WHERE 提取纪录"></a>使用 WHERE 提取纪录</h3><pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 WHERE 条件;</code></pre>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>前面我们使用了符号 “&gt;=” 来设置 “大于等于 XX ” 的条件，这种符号称为 <strong>比较运算符</strong>。 MySQL 常用的比较运算符如下所示：</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>IN xx</td>
<td>在 xx 中</td>
</tr>
<tr>
<td>NOT IN xx</td>
<td>不在 xx 中</td>
</tr>
<tr>
<td>BETWEEN x AND xx</td>
<td>在 xx 到 xx 之间</td>
</tr>
<tr>
<td>NOT BETWEEN AND</td>
<td>不再 xx 之间</td>
</tr>
</tbody></table>
<h3 id="使用字符串作为条件"><a href="#使用字符串作为条件" class="headerlink" title="使用字符串作为条件"></a>使用字符串作为条件</h3><h4 id="LIKE-模糊查询"><a href="#LIKE-模糊查询" class="headerlink" title="LIKE 模糊查询"></a>LIKE 模糊查询</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE empid LIKE '%1%'</code></pre>
<h4 id="通配符含义"><a href="#通配符含义" class="headerlink" title="通配符含义"></a>通配符含义</h4><table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>任意字符串</td>
</tr>
<tr>
<td>_</td>
<td>任意一个字符</td>
</tr>
</tbody></table>
<p>如：</p>
<table>
<thead>
<tr>
<th>指定的字符串</th>
<th>符合的例子</th>
</tr>
</thead>
<tbody><tr>
<td>%县</td>
<td>奇遇县、非常好的县</td>
</tr>
<tr>
<td>福%</td>
<td>福井县、福岛、福</td>
</tr>
<tr>
<td>长_县</td>
<td>长野县、长其县、长海县</td>
</tr>
<tr>
<td>%县%</td>
<td>包含县的就可以，县、县名、长海县</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>提示</strong>    前面的 SQL 如下按照下面的方式书写：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE empid LIKE 'A101';</code></pre>
<p>等同于：</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT * FROM tb WHERE empid = 'A101';</code></pre>
</blockquote>
<h3 id="提取不包含指定字符串的纪录"><a href="#提取不包含指定字符串的纪录" class="headerlink" title="提取不包含指定字符串的纪录"></a>提取不包含指定字符串的纪录</h3><p>提取不包含某字符串的纪录时需要使用 NOT LIKE 命令。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb1 WHERE name NOT LIKE '佐%'</code></pre>
<h3 id="使用-NULL-作为条件"><a href="#使用-NULL-作为条件" class="headerlink" title="使用 NULL 作为条件"></a>使用 NULL 作为条件</h3><p>NULL 表示空值。如果没有向列中输入数据，也没有给列设置默认值，就会输入 NULL。</p>
<h4 id="当列值为-NULL-时"><a href="#当列值为-NULL-时" class="headerlink" title="当列值为 NULL 时"></a>当列值为 NULL 时</h4><p>提取列值为 NULL 的纪录时需要使用 IS NULL。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb1 WHERE age IS NULL;</code></pre>
<h4 id="当列值为非-NULL-时"><a href="#当列值为非-NULL-时" class="headerlink" title="当列值为非 NULL 时"></a>当列值为非 NULL 时</h4><p>提取值不是 NULL 的纪录时需要使用 IS NOT NULL。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb1 WHERE age IS NOT NULL;</code></pre>
<h3 id="指定多个条件进行选择"><a href="#指定多个条件进行选择" class="headerlink" title="指定多个条件进行选择"></a>指定多个条件进行选择</h3><p>我们可以设置任意次数的 AND 和 OR。下面是同时使用 AND 和 OR 进行处理的示例。</p>
<ul>
<li>“empid” 是 ‘A101’ 且 ‘month’ 是 4”，或者 “sales 大于等于 200”</li>
</ul>
<p>也就是说，要在处理 “员工号为 A101 的员工 4 月份的销售额” 的基础上添加 “销售额大于等于 200 万元” 的纪录。</p>
<pre class=" language-mysql"><code class="language-mysql"># empid 的值最后为 “1”
$ SELECT * FROM tb WHERE empid LIKE '%1' AND month = 4 OR sales >= 200;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A101  |   184 |     4 |
| A101  |   300 |     5 |
| A102  |   205 |     6 |
+-------+-------+-------+
3 rows in set (0.00 sec)</code></pre>
<p>可以看到，员工号为 A101 的员工 4 月份的纪录中增加了 2 条 sales 大于 200 的纪录。即使像下面这样修改条件的设置顺序，处理也不会发生任何改变。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE sales >= 200 OR empid LIKE '%1' AND month = 4;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A101  |   184 |     4 |
| A101  |   300 |     5 |
| A102  |   205 |     6 |
+-------+-------+-------+
3 rows in set (0.00 sec)</code></pre>
<p>也就是说，无论条件的设置顺序如何，都会先处理 <code>empid Like '%1' AND month = 4</code>，然后再用 OR 添加 sales 大于等于 200 的纪录。请记住下面的规则：</p>
<ul>
<li>当 AND 与 OR 混合使用时，会优先处理 AND。</li>
</ul>
<p>那么，如果想进行下面的处理，大家知道怎么做吗？</p>
<ul>
<li>“sales 大于等于 200，或者 empid 为 ‘A101’ ” 且 “month 是 4”</li>
</ul>
<p>该处理表示先提取满足销售额大于等于 200 万元，或者工号为 A101 这一条件的纪录，然后再从结果中提取满足 4 月份这个条件的纪录。我们想优先处理的是 OR 的部分，但是直接执行会先处理 AND 的部分。所以，在这种情况下，我们需要用 () 把想要优先处理的内容括起来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE (sales >= 200 OR empid LIKE '%1') AND month = 4;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A101  |   184 |     4 |
+-------+-------+-------+
1 row in set (0.00 sec)</code></pre>
<h3 id="使用-CASE-WHEN"><a href="#使用-CASE-WHEN" class="headerlink" title="使用 CASE WHEN"></a>使用 CASE WHEN</h3><p>还有一种 “根据条件改变输入值” 的高级方法。例如，大于等于 80 分输入“优”，大于等于 60 分小于 80 分输入“良”，大于等于 40 分小于 60 分输入“及格”，除此之外全部输入 “不及格”。对于这种处理，我们可以使用 CASE WHEN。</p>
<h4 id="根据条件改变并显示值"><a href="#根据条件改变并显示值" class="headerlink" title="根据条件改变并显示值"></a>根据条件改变并显示值</h4><pre class=" language-mysql"><code class="language-mysql">CASE 
        WHEN 条件1    THEN 显示的值
        WHEN 条件2    THEN 显示的值
        WHEN 条件3    THEN 显示的值
...
ELSE 不满足所有条件时的值
END</code></pre>
<p>当使用 SELECT 命令显示列值时，我们可以使用上述语句来纪录列的内容。如果需要显示多个列，向之前一样使用 “,” 进行分隔即可。</p>
<ul>
<li>当销售额（sales） 大于等于 100 时为 “高”，大于等于 50 小于 100 时为 “中等”，否则为 “低”。</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 
    CASE 
            WHEN sales >= 100 THEN '高'
            WHEN sales >=50 THEN '中等'
            ELSE '低'
    END
    FROM tb;
+---------------------------------------------------------------------------------------------+
| CASE
    WHEN sales >= 100 THEN '高'
    WHEN sales >= 50 THEN '中等'
    ELSE '低'
END     |    
+---------------------------------------------------------------------------------------------+
| 高                                                                                          |
| 中等                                                                                        |
| 高                                                                                          |
| 高                                                                                          |
| 低                                                                                          |
| 高                                                                                          |
| 高                                                                                          |
| 中等                                                                                        |
| 低                                                                                          |
| 中等                                                                                        |
+---------------------------------------------------------------------------------------------+
10 rows in set (0.00 sec)</code></pre>
<p>显示出来的内容让人有些难以理解。开头出现了乱糟糟的 “CASE WHEN …” 字符串，导致显示的内容过于冗长。</p>
<p>执行 SELECT 命令会先显示出列名等表示项目的描述。在前面的例子中，列名都是 empid 或 sales 这种简短的形式，但是这次显示的列名是 “CASE WHEN … END”。这种列名会对理解造成障碍，所以我们试着给 CASE …END 的部分加上别名 “评价”。不过，光显示评价并不能看出它表示的是什么，因此我们也让列 empid 和列 sales 显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, sales,
       CASE
           WHEN sales >=100 THEN '高'
           WHEN sales >= 50 THEN '中等'
           ELSE '低'
       END AS 评价
  FROM tb;
+-------+-------+--------+
| empid | sales | 评价   |
+-------+-------+--------+
| A103  |   101 | 高     |
| A102  |    54 | 中等   |
| A104  |   181 | 高     |
| A101  |   184 | 高     |
| A103  |    17 | 低     |
| A101  |   300 | 高     |
| A102  |   205 | 高     |
| A104  |    93 | 中等   |
| A103  |    12 | 低     |
| A107  |    87 | 中等   |
+-------+-------+--------+
10 rows in set (0.00 sec)</code></pre>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>我们可以指定 ORDER BY 按指定的列值顺序显示纪录。</p>
<h4 id="按升序显示纪录"><a href="#按升序显示纪录" class="headerlink" title="按升序显示纪录"></a>按升序显示纪录</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 ORDER BY 作为键的列</code></pre>
<p>在什么都不指定的情况下，记录会按照从小到大的顺序排列。但如果想明确指定按升序排列，就需要向下面这样给命令加上 ASC。执行结果是一样的。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb ORDER BY sales ASC;</code></pre>
<h4 id="按降序排序并显示"><a href="#按降序排序并显示" class="headerlink" title="按降序排序并显示"></a>按降序排序并显示</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 ORDER BY 作为键的列 DESC;</code></pre>
<h4 id="指定纪录的显示范围"><a href="#指定纪录的显示范围" class="headerlink" title="指定纪录的显示范围"></a>指定纪录的显示范围</h4><p>在按顺序显示纪录的情况下，如果能指定纪录的显示范围就会非常方便。我们使用 LIMIT 来限制显示的记录数。当时只是选择了 3 条纪录显示出来，而使用 OFFSET 可以进一步指定显示的范围。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 LIMIT 显示的记录数 OFFSET 开始显示的记录的位移数</code></pre>
<p>“开始显示纪录的移位数” 是指定 “移动多少位后开始显示纪录” 的数字。如果设置为 OFFSET 3，则表示 “从第 1 条纪录开始移动 3 位后，从第 4 条记录开始显示”。</p>
<p>对于销售信息 tb，我们按照销售额（列sales） 从高到低的顺序将排在第 4 位和 第 5 位的记录显示出来：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb ORDER BY sales DESC LIMIT 2 OFFSET 3;
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A104  |   181 |     4 |
| A103  |   101 |     4 |
+-------+-------+-------+
2 rows in set (0.00 sec)</code></pre>
<h3 id="分组显示"><a href="#分组显示" class="headerlink" title="分组显示"></a>分组显示</h3><p>在表 tb 中，empid 为 “A101” 的记录有多个。我们可以让同属 “A101” 的多条记录组成一个 “组合”。这样就能以组为单位计算该组记录的总和或平均值了。</p>
<p>分组后处理起来似乎更加方便了，但是在数据库中，当前的处理对象却变得模糊起来，所以我们要时刻了解当前的处理对象是谁。</p>
<p>分组时需要使用 GROUP BY 命令。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 GROUP BY 用于分组的列名;</code></pre>
<p>只是分组显示的话并没有什么意义，不过我们还是先试着按照列 empid 进行分组，看看会显示什么样的结果。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid FROM tb GROUP BY empid;
+-------+
| empid |
+-------+
| A103  |
| A102  |
| A104  |
| A101  |
| A107  |
+-------+</code></pre>
<p>表示员工号的 empid 每种只显示一个值。GROUP BY empid 使每组 empid 都被执行了 SELECT。通过这个处理，我们可以知道表 tb 的列 empid 中存在 A101、A102 等 5 种数据。</p>
<p>因为要按组进行处理，所以我们姑且可以认为属于该组的记录是被随机选择的。一定要记住处理对象是 “同一组中的所有记录”。</p>
<h4 id="计算各组的记录数"><a href="#计算各组的记录数" class="headerlink" title="计算各组的记录数"></a>计算各组的记录数</h4><p>下面试着计算每组记录的个数，即每个员工号有多少记录。计算个数需要使用 COUNT 函数。COUNT(x) 用于计算除 NULL 以外列 x 的值的个数。</p>
<p>分组后的处理对象是 “同一组中的所有记录”。因为计算的是记录的数量，所以在没有 NULL 的情况下，不管以哪个列为对象，结果都是一样的。因此，不仅仅是 COUNT(sales)，执行 COUNT(empid) 或 COUNT(month) 也不会有任何问题。当然，执行 COUNT(*) 也很方便。在这种情况下，计算的记录数就包含了 NULL。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT COUNT(*) FROM tb GROUP BY empid;
| COUNT(*) |
+----------+
|        3 |
|        2 |
|        2 |
|        2 |
|        1 |
+----------+</code></pre>
<h3 id="显示各组的总和以及平均值"><a href="#显示各组的总和以及平均值" class="headerlink" title="显示各组的总和以及平均值"></a>显示各组的总和以及平均值</h3><p>计算每位员工的总销售额：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, SUM(sales) AS 合计 FROM tb GROUP BY empid;
+-------+--------+
| empid | 合计   |
+-------+--------+
| A103  |    130 |
| A102  |    259 |
| A104  |    274 |
| A101  |    484 |
| A107  |     87 |
+-------+--------+
5 rows in set (0.00 sec)</code></pre>
<p>计算每组销售额平均值：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, AVG(sales) FROM tb GROUP BY empid;
+-------+------------+
| empid | AVG(sales) |
+-------+------------+
| A103  |    43.3333 |
| A102  |   129.5000 |
| A104  |   137.0000 |
| A101  |   242.0000 |
| A107  |    87.0000 |
+-------+------------+
5 rows in set (0.00 sec)</code></pre>
<h3 id="设置条件分组显示"><a href="#设置条件分组显示" class="headerlink" title="设置条件分组显示"></a>设置条件分组显示</h3><p>想要 “按员工号计算销售额的总和”，但是仅显示总和大于等于 xx 的记录“ 时，可以使用 HAVING 为分组的结果值设置提取条件。</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT 统计列 FROM 表名 GROUP BY 分组列 HAVING 条件;</code></pre>
<p>用 HAVING 设置的条件适用于分组的结果值。</p>
<p>设置 “按员工号分组计算总销售额，但仅显示小组总销售额大于等于 200 万元的记录” 的条件。具体来说，就是对于表 tb 中的每一种 empid，显示 “列 sales 的总和大于等于 200” 的列 empid 及列 sales 的总和。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_11-34-14.png" style="zoom:50%;">

<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, SUM(sales) FROM tb GROUP BY empid HAVING SUM(sales) >= 200;
+-------+------------+
| empid | SUM(sales) |
+-------+------------+
| A102  |        259 |
| A104  |        274 |
| A101  |        484 |
+-------+------------+
3 rows in set (0.00 sec)</code></pre>
<p>用于提取纪录的 HAVING 是在分组之后执行的。</p>
<h3 id="提取纪录后分组"><a href="#提取纪录后分组" class="headerlink" title="提取纪录后分组"></a>提取纪录后分组</h3><p>与 “分组后提取纪录” 相反，下面将介绍 “提取纪录后分组” 的相关内容。例如，仅提取销售额大于等于 1 万元的交易纪录，并以该纪录为对象计算各员工的平均销售额。</p>
<p>我们需要使用 WHERE 执行分组之前的提取操作。与以往不同的是，使用 GROUP BY 分组的操作要放到最后面。</p>
<p>下面我们试着仅提取销售额（sales） 大于等于 50 万元的交易纪录，并以该纪录为对象计算各员工的平均销售额。具体来说，就是对与表 tb 的列 sales 中大于等于 50 的纪录，按照列 empid 分组后，显示列 empid 以及各组 sales 的平均值。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_11-37-13.png" style="zoom:40%;">

<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, AVG(sales) FROM tb WHERE sales >= 50 GROUP BY empid;
+-------+------------+
| empid | AVG(sales) |
+-------+------------+
| A103  |   101.0000 |
| A102  |   129.5000 |
| A104  |   137.0000 |
| A101  |   242.0000 |
| A107  |    87.0000 |
+-------+------------+
5 rows in set (0.00 sec)</code></pre>
<h3 id="分组后排序"><a href="#分组后排序" class="headerlink" title="分组后排序"></a>分组后排序</h3><p>对分组后的结果重新排序并将结果显示出来。也就是需要同时使用 “GROUP BY …” 和 “ORDER BY …”。先写 “GROUP BY”，再写 “ORDER BY”。</p>
<pre><code>$ SELECT empid, AVG(sales) FROM tb GROUP BY empid ORDER BY AVG(sales) DESC;
+-------+------------+
| empid | AVG(sales) |
+-------+------------+
| A101  |   242.0000 |
| A104  |   137.0000 |
| A102  |   129.5000 |
| A107  |    87.0000 |
| A103  |    43.3333 |
+-------+------------+
5 rows in set (0.00 sec)</code></pre>
<h3 id="分组方法总结"><a href="#分组方法总结" class="headerlink" title="分组方法总结"></a>分组方法总结</h3><p>在分组的情况下设置条件的方法，主要包括以下两种类型。</p>
<p>a. 提取纪录后分组</p>
<p>b. 分组后提取纪录</p>
<p>在 a 的情况下，需要使用 WHERE 设置条件并提取纪录，然后通过 GROUP BY 进行分组。</p>
<p>在 b 的情况下，需要先用 GROUP BY 进行分组，然后使用 HAVING 提取纪录。</p>
<p>以销售额大于等于 50 万元的数据为对象，按照员工号（empid） 分组，计算各员工的平均销售额 AVG(sales)，然后按照降序消失。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, AVG(sales) FROM tb WHERE sales >= 50 GROUP BY empid ORDER BY AVG(sales) DESC;
+-------+------------+
| empid | AVG(sales) |
+-------+------------+
| A101  |   242.0000 |
| A104  |   137.0000 |
| A102  |   129.5000 |
| A103  |   101.0000 |
| A107  |    87.0000 |
+-------+------------+
5 rows in set (0.01 sec)</code></pre>
<p>WHERE、GROUP BY 和 ORDER BY 的执行顺序如下所示：</p>
<p>WHERE 条件 —&gt; GROUP BY —&gt; ORDER BY… (DESC)</p>
<blockquote>
<p><strong>WHERE 和 HAVING</strong>    介绍了 WHERE 和 HAVING 在使用方法上的区别。例如，使用 GROUP BY、ORDER BY 和 HAVING 的 SELECT 语句通常会按照如下方式描述。～ 是可选的。</p>
<p>SELECT ~ FROM ~ WHERE ~ GROUP BY ~ HAVING ~ ORDER BY</p>
<p>但是，实际的执行顺序确实下面这样的。</p>
<p>FROM ~ —&gt; WHERE ~ —&gt; GROUP BY ~ —&gt; HAVING ～ —&gt; SELECT ~ —&gt; ORDER BY ~</p>
<p>也就是说，在通过 GROUP BY 分组之前会执行 WHERE，而 HAVING 执行的对象是 GROUP BY 分组后的结果。另外，可以看到 ORDER BY 重新排列了 SELECT 的结果。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用多个表</title>
    <url>/posts/8c42.html</url>
    <content><![CDATA[<h3 id="显示多个表的记录"><a href="#显示多个表的记录" class="headerlink" title="显示多个表的记录"></a>显示多个表的记录</h3><h4 id="确认本章示例中使用的多个表"><a href="#确认本章示例中使用的多个表" class="headerlink" title="确认本章示例中使用的多个表"></a>确认本章示例中使用的多个表</h4><p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-27_11-09-50.png"></p>
<h4 id="显示多条提取结果"><a href="#显示多条提取结果" class="headerlink" title="显示多条提取结果"></a>显示多条提取结果</h4><p>从多个表中取出记录，并将它们汇总到一起显示出来。我们可以使用 UNION 命令从多个表中提取记录并将它们合并起来。</p>
<p>比如从去年的客户表和今年的客户表中把老客户的记录提取出来，然后合并到一起显示。也可以合并结构不同的表数据。一般来说，合并到一起显示的列，其数据类型需要一致。不过，即使数据类型不同，很多时候 MySQL 也会对可以合并的记录一起合并。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名1 FROM 表名1 UNION SELECT 列名2 FROM 表名;</code></pre>
<p>写成一行的话有点不好理解。执行换行和缩进后，格式会变成下面这样。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 
                列名 1
    FROM 
                表名 1
UNION
    SELECT 
                列名 2
    FROM
                表名 2;</code></pre>
<p>UNION 将两个 “SELECT … FROM …” 的结果合并存了起来。</p>
<p>首先试着合并具有相同列结构的表 tb1 和 tb2 的记录。因为合并的是所有的列，所以需要用 UNION 把 ”SELECT * FROM …“ 连接起来。</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT * FROM tb1 UNION SELECT * FROM tb2;
+-------+--------+------+
| empid | name   | age  |
+-------+--------+------+
| A101  | 佐腾   |   40 |
| A102  | 高桥   |   28 |
| A103  | 中川   |   20 |
| A104  | 渡边   |   23 |
| A105  | 西泽   |   35 |
| A106  | 中村   |   26 |
| A107  | 田中   |   24 |
| A108  | 铃木   |   23 |
| A109  | 村井   |   25 |
| A110  | 吉田   |   27 |
+-------+--------+------+
10 rows in set (0.00 sec)</code></pre>
<p>为了便于阅读，我们可以用 () 把各个 “SELECT …” 括起来。这种写法更容易理解。</p>
<pre class=" language-mysql"><code class="language-mysql">(SELECT * FROM tb1) UNION (SELECT * FROM tb2);</code></pre>
<h4 id="使用-UNION-合并-3-个以上的表"><a href="#使用-UNION-合并-3-个以上的表" class="headerlink" title="使用 UNION 合并 3 个以上的表"></a>使用 UNION 合并 3 个以上的表</h4><p>将 empid 为 A102、A103、A104、A107 的记录一个一个地 SELECT 出来，然后使用 UNION 进行合并。</p>
<pre class=" language-mysql"><code class="language-mysql">$ (SELECT * FROM tb WHERE empid = 'A102')
UNION (SELECT * FROM tb WHERE empid = 'A103')
UNION (SELECT * FROM tb WHERE empid = 'A104')
UNION (SELECT * FROM tb WHERE empid = 'A107');</code></pre>
<h4 id="按条件合并多条提取结果进行显示"><a href="#按条件合并多条提取结果进行显示" class="headerlink" title="按条件合并多条提取结果进行显示"></a>按条件合并多条提取结果进行显示</h4><p>当使用 UNION 合并提取的多条记录时，如果需要添加条件，可以在各个命令的最后加上 “WHERE 条件”。</p>
<p>试着提取符合下面两个条件中任意一个条件的员工的员工号：</p>
<ol>
<li><p>表 tb 中销售额（sales）大于等于 200 万元的员工的员工号（empid）（筛选出 A101 和 A102）</p>
</li>
<li><p>表 tb1 中年龄（age）大于等于 35 岁员工的员工号    (筛选出 A101 和  A105)</p>
</li>
</ol>
<pre class=" language-mysql"><code class="language-mysql">$ (SELECT empid FROM tb WHERE sales >= 200) UNION (SELECT empid FROM tb1 WHERE age >= 35);
+-------+
| empid |
+-------+
| A101  |
| A102  |
| A105  |
+-------+
3 rows in set (0.01 sec)</code></pre>
<h4 id="合并显示多条提取结果（允许重复）"><a href="#合并显示多条提取结果（允许重复）" class="headerlink" title="合并显示多条提取结果（允许重复）"></a>合并显示多条提取结果（允许重复）</h4><p>每个员工的员工号整齐地显示出来。大家可能认为这是理所当然的，但事实并非如此。这个结果合并的是多个表中的记录。也就是说，根据条件 1 提取了 A101 和 A102，根据条件 2 提取了 A101 和 A105，所以按理说应该显示多个 A101。但是，A101 仅显示了一条记录。之所以会出现这样的情况，是因为在提取纪录的同时执行了 “消除重复记录” 的操作。</p>
<p>如果对大量记录执行 “消除重复” 的操作，就会产生一定的等待时间。因此，在处理大量记录的情况下，省去这项操作效率更高。我们可以通过 UNION 加上 ALL 来省去消除重复记录的操作。</p>
<pre class=" language-mysql"><code class="language-mysql">$ (SELECT empid FROM tb WHERE sales >= 200) UNION ALL (SELECT empid FROM tb1 WHERE age >= 35);
+-------+
| empid |
+-------+
| A101  |
| A102  |
| A101  |
| A105  |
+-------+
4 rows in set (0.00 sec)</code></pre>
<h3 id="连接多个表并显示-内连接"><a href="#连接多个表并显示-内连接" class="headerlink" title="连接多个表并显示(内连接)"></a>连接多个表并显示(内连接)</h3><p>将多个表通过某个连接键连接在一起的处理称为 “连接”。这种处理符合关系数据库的特性。</p>
<p>表 tb 中 empid 为 A101 的员工是 40 岁的佐藤。可如果只看表 tb，我们是无法得知员工姓名的。因此，我们需要将销售信息表 tb 和员工信息表 tb1 共同拥有的列 empid 设置为连接键，连接这两个表并显示出来。</p>
<p>我们可以使用 JOIN 连接两个表</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表1 JOIN 要连接的表2 ON 表1的列 = 表2的列</code></pre>
<p>ON 的后面要写上作为连接键的条件。例如，在连接表 tb 和表 tb1 的情况下，由于列 empid 是共同的列，所以我们要设置这个键为连接键。在 “ON 表1的列 = 表2的列” 的部分中， “xx 表的 xx 列” 的中间要加上 “.”。就像下面这样：</p>
<pre class=" language-mysql"><code class="language-mysql">ON tb.empid = tb1.empid</code></pre>
<p>这里我们暂时使用 ‘*’ 将所有的列都显示出来：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb JOIN tb1 ON tb.empid = tb1.empid;
+-------+-------+-------+-------+--------+------+
| empid | sales | month | empid | name   | age  |
+-------+-------+-------+-------+--------+------+
| A103  |   101 |     4 | A103  | 中川   |   20 |
| A102  |    54 |     5 | A102  | 高桥   |   28 |
| A104  |   181 |     4 | A104  | 渡边   |   23 |
| A101  |   184 |     4 | A101  | 佐腾   |   40 |
| A103  |    17 |     5 | A103  | 中川   |   20 |
| A101  |   300 |     5 | A101  | 佐腾   |   40 |
| A102  |   205 |     6 | A102  | 高桥   |   28 |
| A104  |    93 |     5 | A104  | 渡边   |   23 |
| A103  |    12 |     6 | A103  | 中川   |   20 |
+-------+-------+-------+-------+--------+------+
9 rows in set (0.00 sec)</code></pre>
<p>像这样把不同的表中相匹配的记录提取出来的连接方式称为<strong>内连接</strong>。如果要明确指出某一处理是内连接，可以将 JOIN 部分写成 INNER JOIN。像下面这样 JOIN 的前面加上 INNER，结果不会发生任何改变。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb INNER JOIN tb1 ON tb.empid = tb1.empid;</code></pre>
<h4 id="选择列进行显示"><a href="#选择列进行显示" class="headerlink" title="选择列进行显示"></a>选择列进行显示</h4><p>我们使用 “*” 显示了所有的列。这次，我们来选择要显示的列。不过，在连接表的时候如果只写 name 和 sales，MySQL 会不知道这些列属于哪个表。在这种情况下，我们要把列名写成 “表名.列名”。另外，列会按照指定的顺序显示。同一列显示多少次都没有关系。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb.empid, tb1.name, tb.sales 
        FROM tb 
    JOIN tb1
        ON tb.empid = tb1.empid;
+-------+--------+-------+
| empid | name   | sales |
+-------+--------+-------+
| A103  | 中川   |   101 |
| A102  | 高桥   |    54 |
| A104  | 渡边   |   181 |
| A101  | 佐腾   |   184 |
| A103  | 中川   |    17 |
| A101  | 佐腾   |   300 |
| A102  | 高桥   |   205 |
| A104  | 渡边   |    93 |
| A103  | 中川   |    12 |
+-------+--------+-------+
9 rows in set (0.00 sec)</code></pre>
<h4 id="给表添加别名"><a href="#给表添加别名" class="headerlink" title="给表添加别名"></a>给表添加别名</h4><pre class=" language-mysql"><code class="language-mysql">表名 AS 别名</code></pre>
<h4 id="使用-USING-使-ON-的部分更容易阅读"><a href="#使用-USING-使-ON-的部分更容易阅读" class="headerlink" title="使用 USING 使 ON~ 的部分更容易阅读"></a>使用 USING 使 ON~ 的部分更容易阅读</h4><p>在前面的示例中，作为连接键的两个列恰好都是 empid 这个名字。在使用相同列名进行指定的情况下，我们可以使用 <strong>USING(作为连接键的列名)</strong> 简单地进行记述。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb.empid, tb1.name, tb.sales FROM tb JOIN tb1 USING(empid);
+-------+--------+-------+
| empid | name   | sales |
+-------+--------+-------+
| A103  | 中川   |   101 |
| A102  | 高桥   |    54 |
| A104  | 渡边   |   181 |
| A101  | 佐腾   |   184 |
| A103  | 中川   |    17 |
| A101  | 佐腾   |   300 |
| A102  | 高桥   |   205 |
| A104  | 渡边   |    93 |
| A103  | 中川   |    12 |
+-------+--------+-------+
9 rows in set (0.00 sec)</code></pre>
<h4 id="通过-WHERE-设置条件从连接表中提取纪录"><a href="#通过-WHERE-设置条件从连接表中提取纪录" class="headerlink" title="通过 WHERE 设置条件从连接表中提取纪录"></a>通过 WHERE 设置条件从连接表中提取纪录</h4><p>通过 WHERE 来设置条件，仅显示连接表中符合条件的记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb.empid AS 员工号, tb1.name AS 姓名, tb.sales AS 销售额
            FROM tb
    JOIN tb1
            USING(empid)
    WHERE tb.sales >= 100;
+-----------+--------+-----------+
| 员工号    | 姓名   | 销售额    |
+-----------+--------+-----------+
| A103      | 中川   |       101 |
| A104      | 渡边   |       181 |
| A101      | 佐腾   |       184 |
| A101      | 佐腾   |       300 |
| A102      | 高桥   |       205 |
+-----------+--------+-----------+
5 rows in set (0.00 sec)</code></pre>
<h4 id="提取多个表中的记录"><a href="#提取多个表中的记录" class="headerlink" title="提取多个表中的记录"></a>提取多个表中的记录</h4><p>我们可以使用 JOIN 连接多个表。在 “SELECT … JOIN … ON …” 的基础上加上 “JOIN … ON …” 就可以对多个表进行连接。但是，在连接多个表的情况下，处理时间会相应地变长，记述的内容也会变得难以理解。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT ~ FROM
 表名 1
 JOIN 表名 2 连接条件
 JOIN 表名 3 连接条件
 ...;</code></pre>
<p>公司员工的 “出生地” 信息保存在表 tb3 中。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb.empid, tb.sales, tb1.name, tb3.region
    FROM tb
JOIN tb1
    USING(empid)
JOIN tb3
    USING(empid);</code></pre>
<p>我们使用 3 个表共有的列 empid 执行了 USING(empid)。如果使用 ON 将 ON tb.empid = tb1.empid 和  on tb.empid = tb3.empid。</p>
<h3 id="显示多个表的所有记录（外连接）"><a href="#显示多个表的所有记录（外连接）" class="headerlink" title="显示多个表的所有记录（外连接）"></a>显示多个表的所有记录（外连接）</h3><pre class=" language-mysql"><code class="language-mysql">$ SELECT x.empid, y.name, x.sales
      FROM tb AS x
  JOIN tb1 AS y
      on x.empid = y.empid;
+-------+--------+-------+
| empid | name   | sales |
+-------+--------+-------+
| A103  | 中川   |   101 |
| A102  | 高桥   |    54 |
| A104  | 渡边   |   181 |
| A101  | 佐腾   |   184 |
| A103  | 中川   |    17 |
| A101  | 佐腾   |   300 |
| A102  | 高桥   |   205 |
| A104  | 渡边   |    93 |
| A103  | 中川   |    12 |
+-------+--------+-------+
9 rows in set (0.00 sec)</code></pre>
<p>实际上，表 tb 中有一个 empid = A107 的人，但这个人没有登记在表 tb1 的员工名单上。A107是其它营业所的员工，所有表 tb1 中没有这个人的数据。虽然他贡献了一部分销售额，但使用 JOIN 连接表时不会显示这个人的记录。</p>
<p>另外，员工信息表 tb1 中虽然有 A105 西泽的信息，但销售信息表 tb 没有他的相关信息。也就是说，虽然西泽被列入了员工名册中，但可能因为没有销售成绩，所以销售信息表中没有显示 A105 的记录。</p>
<ul>
<li><strong>使用了 JOIN (或者 INNER JOIN) 的 “内连接” 只会提取与连接键相匹配的记录</strong></li>
</ul>
<p>因此，只存在表 tb 或者表 tb1 中的记录将被忽略。但是，我们有时也会遇到必须显示这些记录的情况。这这种情况下，我们需要使用 <strong>外连接</strong>。外连接具有一下特性：</p>
<ul>
<li><strong>即使与连接键不匹配，外链接也会提取两个表中的所有记录。</strong></li>
</ul>
<h4 id="外连接的种类"><a href="#外连接的种类" class="headerlink" title="外连接的种类"></a>外连接的种类</h4><ul>
<li>左外连接<ul>
<li>显示 “相匹配的记录” 和 “表1（即左表）的全部记录”</li>
</ul>
</li>
<li>右外连接<ul>
<li>显示 “相匹配的记录” 和 “要连接的表2（即右表）的全部记录”</li>
</ul>
</li>
</ul>
<h4 id="使用左外连接"><a href="#使用左外连接" class="headerlink" title="使用左外连接"></a>使用左外连接</h4><p>当进行左外连接时，我们只需将内连接中使用的 JOIN 修改为 <strong>LEFT JOIN</strong> 即可。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名
            FROM 表1
    LEFT JOIN 要连接的表2
            ON 表1的列 = 表2的列 </code></pre>
<p>使用左外连接显示表 tb 和 表 tb1 相匹配的记录，以及表 tb 的所有记录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb.empid, tb1.name FROM tb LEFT JOIN tb1 USING(empid);
+-------+--------+
| empid | name   |
+-------+--------+
| A103  | 中川   |
| A102  | 高桥   |
| A104  | 渡边   |
| A101  | 佐腾   |
| A103  | 中川   |
| A101  | 佐腾   |
| A102  | 高桥   |
| A104  | 渡边   |
| A103  | 中川   |
| A107  | NULL   |
+-------+--------+
10 rows in set (0.00 sec)</code></pre>
<h4 id="使用右外连接"><a href="#使用右外连接" class="headerlink" title="使用右外连接"></a>使用右外连接</h4><p>通过右外连接显示 “相匹配的记录” 和 “要连接的右表的所有记录”。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 
            FROM 表 1
    RIGHT JOIN 要连接的表2
            ON 表1的列 = 表2的列</code></pre>
<p>有些记录在员工信息表 tb1 中有，但在销售信息表 tb 中没有，对于这种没有销售额的员工的记录，我们也将其全部显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb.empid, tb1.name
            FROM tb
    RIGHT JOIN tb1
    USING(empid);
+-------+--------+
| empid | name   |
+-------+--------+
| A103  | 中川   |
| A102  | 高桥   |
| A104  | 渡边   |
| A101  | 佐腾   |
| A103  | 中川   |
| A101  | 佐腾   |
| A102  | 高桥   |
| A104  | 渡边   |
| A103  | 中川   |
| NULL  | 西泽   |
+-------+--------+
10 rows in set (0.00 sec)</code></pre>
<p>执行的结果中显示了表 tb 和表 tb1 相匹配的记录，以及右表 tb1 的所有记录。</p>
<blockquote>
<p><strong>加上 OUTER 后的书写方法</strong>    </p>
<p>LEFT JOIN 也可以写成 LEFT OUTER JOIN。同样，RIGHT JOIN 也可以写成 RIGHT OUTER JOIN。</p>
</blockquote>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>我们可以将表与其自身，也就是和同名的表进行连接。这种连接方式称为自连接。因为是两个同名的表进行连接，所以如果直接执行连接，就会显示出两个同名的列。这样就无法对列进行识别了（发生了错误），因此连接时必须定义别名。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT 列名 FROM 表名 AS 别名1 JOIN 表名 AS 别名2;</code></pre>
<p>我们试着对员工信息表 tb1 进行自连接，并把所有的列显示出来。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb1 AS a JOIN tb1 AS b;
+-------+--------+------+-------+--------+------+
| empid | name   | age  | empid | name   | age  |
+-------+--------+------+-------+--------+------+
| A101  | 佐腾   |   40 | A101  | 佐腾   |   40 |
| A102  | 高桥   |   28 | A101  | 佐腾   |   40 |
| A103  | 中川   |   20 | A101  | 佐腾   |   40 |
| A104  | 渡边   |   23 | A101  | 佐腾   |   40 |
| A105  | 西泽   |   35 | A101  | 佐腾   |   40 |
| A101  | 佐腾   |   40 | A102  | 高桥   |   28 |
| A102  | 高桥   |   28 | A102  | 高桥   |   28 |
| A103  | 中川   |   20 | A102  | 高桥   |   28 |
| A104  | 渡边   |   23 | A102  | 高桥   |   28 |
| A105  | 西泽   |   35 | A102  | 高桥   |   28 |
| A101  | 佐腾   |   40 | A103  | 中川   |   20 |
| A102  | 高桥   |   28 | A103  | 中川   |   20 |
| A103  | 中川   |   20 | A103  | 中川   |   20 |
| A104  | 渡边   |   23 | A103  | 中川   |   20 |
| A105  | 西泽   |   35 | A103  | 中川   |   20 |
| A101  | 佐腾   |   40 | A104  | 渡边   |   23 |
| A102  | 高桥   |   28 | A104  | 渡边   |   23 |
| A103  | 中川   |   20 | A104  | 渡边   |   23 |
| A104  | 渡边   |   23 | A104  | 渡边   |   23 |
| A105  | 西泽   |   35 | A104  | 渡边   |   23 |
| A101  | 佐腾   |   40 | A105  | 西泽   |   35 |
| A102  | 高桥   |   28 | A105  | 西泽   |   35 |
| A103  | 中川   |   20 | A105  | 西泽   |   35 |
| A104  | 渡边   |   23 | A105  | 西泽   |   35 |
| A105  | 西泽   |   35 | A105  | 西泽   |   35 |
+-------+--------+------+-------+--------+------+
25 rows in set (0.01 sec)</code></pre>
<h4 id="排序的技巧-其一"><a href="#排序的技巧-其一" class="headerlink" title="排序的技巧 其一"></a>排序的技巧 其一</h4><p>自连接的结果中会包含所有的组合。如果其中有你想要的组合，之后就可以通过设置条件来选出想要的内容了。</p>
<img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/2991611739549_.pic_hd.jpg" style="zoom:50%;">

<p>请看右侧为 “佐藤 40 ”，左侧为 “佐藤 40 ”、“高桥 28 ”、“中川 20 ”、“渡边 23 ”、“西泽 35 ” 的 5 行记录。</p>
<p>在这 5 行记录中，大于等于右侧 “佐藤 40 ” 中 40 这个数字的数据在左侧仅有 1，所以佐藤排名第一。</p>
<p>同样，请看右侧 “高桥 28”，左侧为 “佐藤 40 ”、“高桥 28 ”、“中川 20 ”、“渡边 23 ”、“西泽 35 ” 的 5 行记录。</p>
<p>在这 5 行记录中，其中大于等于右侧 “高桥 28 ” 中 28 这个数字的数据在左侧有 3个，分别是 40、38、28，也就是说高桥排在第三。</p>
<p>像这样，在右侧相同的 5 行记录的范围内，大于等于右侧 age 的值在左侧 age 中的个数就是排名。</p>
<p>换句话说，就是只需要自连接，并对每一组 empid 计算大于等于右侧 age 的值在左侧 age 中的个数即可。该数可以通过 COUNT(*) 计算。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT a.name, a.age, COUNT(*)
        FROM tb1 AS a
    JOIN tb1 AS b
        WHERE a.age <= b.age
    GROUP BY a.empid;
+--------+------+----------+
| name   | age  | COUNT(*) |
+--------+------+----------+
| 佐腾   |   40 |        1 |
| 高桥   |   28 |        3 |
| 中川   |   20 |        5 |
| 渡边   |   23 |        4 |
| 西泽   |   35 |        2 |
+--------+------+----------+
5 rows in set (0.01 sec)</code></pre>
<h3 id="从-SELECT-的记录中-SELECT-子查询"><a href="#从-SELECT-的记录中-SELECT-子查询" class="headerlink" title="从 SELECT 的记录中 SELECT (子查询)"></a>从 SELECT 的记录中 SELECT (子查询)</h3><h4 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h4><p>使用子查询可以完成两个阶段的处理：执行查询，然后使用检索到的记录进一步执行查询。例如，在第一阶段中进行 “从销售信息表中提取销售额大于等于200万元的员工号” 的处理，然后在第二阶段中进行  “从提取出来的员工号中提出相对应的姓名” 的处理。 第一阶段的查询称为 <strong>子查询</strong>。</p>
<p>第一阶段的子查询可以返回值、列和记录等。许多使用了子查询的处理，可以用其他方法取代，例如内连接。但是，子查询的处理方式更容易理解，处理效率也更高。</p>
<h4 id="显示最大值（返回的值的子查询-其一）"><a href="#显示最大值（返回的值的子查询-其一）" class="headerlink" title="显示最大值（返回的值的子查询 其一）"></a>显示最大值（返回的值的子查询 其一）</h4><ul>
<li>显示表 tb 中列 sales 最大值的记录</li>
</ul>
<p>换句话说，就是显示在销售信息表 tb 中销售额最高（sales最大） 的员工记录。列的最大值可以用 MAX 函数计算。或许有人会想 ”这还不简单“，按照下面的方式处理不就可以了。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE sales = MAX(sales);</code></pre>
<p>试着执行一下，结果会发生错误。只写 MAX(sales) 是不会计算出列 sales 的最大值的。想要获取列 sales 中的最大值，就需要按照下面的方式进行查询。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT MAX(sales) FROM tb;</code></pre>
<p>当提取最大值相对应的记录时，需要先通过上面的操作获取最大值，然后从表 tb 中提取纪录。这里，子查询就起到了非常重要的作用。首先，在第一阶段的查询中取出 MAX(sales) 的值，然后在第二阶段选择（SELECT）包含了最大值的列 sales 的纪录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * FROM tb WHERE sales IN (第一阶段的处理结果);</code></pre>
<p>执行下面的命令：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT *
            FROM tb 
    WHERE sales 
            in (SELECT MAX(seles) FROM tb);
+-------+-------+-------+
| empid | sales | month |
+-------+-------+-------+
| A101  |   300 |     5 |
+-------+-------+-------+
1 row in set (0.02 sec)</code></pre>
<blockquote>
<p><strong>GROUP BY 函数</strong>    MAX、AVG 和 SUM 等聚合函数也称为 “GROUP BY” 函数，这类函数用于处理分组后的值。但是，在没有 “GROUP BY” 的情况下，这类函数会将整个表作为一个组进行处理。</p>
</blockquote>
<h4 id="提取大于等于平均值的纪录（返回值的子查询-其二）"><a href="#提取大于等于平均值的纪录（返回值的子查询-其二）" class="headerlink" title="提取大于等于平均值的纪录（返回值的子查询 其二）"></a>提取大于等于平均值的纪录（返回值的子查询 其二）</h4><p>试着计算员工信息报 tb1 中员工的平均年龄，并提取大于等于平均年龄的员工的纪录。</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * 
            FROM tb1 
    WHERE AGE >= (SELECT AVG(age) FROM tb1);
+-------+--------+------+
| empid | name   | age  |
+-------+--------+------+
| A101  | 佐腾   |   40 |
| A105  | 西泽   |   35 |
+-------+--------+------+
2 rows in set (0.00 sec)</code></pre>
<blockquote>
<p><strong>子查询和内连接的提取结果的差异（虽然相似但不同!）</strong></p>
<p>子查询和内连接非常相似。我们来看一个例子。对于销售信息表 tb 中存在的员工号 empid，显示员工信息表 tb1 中相应的员工号 empid 和 姓名name。下面分别用 “子查询” 和 “内连接” 实现上述内容的示例。</p>
<ul>
<li>子查询</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT empid, name 
          FROM tb1 
  WHERE empid IN (SELECT empid FROM tb);
+-------+--------+
| empid | name   |
+-------+--------+
| A101  | 佐腾   |
| A102  | 高桥   |
| A103  | 中川   |
| A104  | 渡边   |
4 rows in set (0.00 sec)</code></pre>
<ul>
<li>内连接</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT tb1.empid, tb1.name 
            FROM tb1 
    JOIN tb ON tb1.empid = tb.empid;
+-------+--------+
| empid | name   |
+-------+--------+
| A103  | 中川   |
| A102  | 高桥   |
| A104  | 渡边   |
| A101  | 佐腾   |
| A103  | 中川   |
| A101  | 佐腾   |
| A102  | 高桥   |
| A104  | 渡边   |
| A103  | 中川   |
+-------+--------+
9 rows in set (0.00 sec)</code></pre>
<p>二者的执行结果是不同的。在使用子查询的情况下，会先提取表 tb 中存在 empid，然后仅显示和表 tb1 相匹配的纪录。而使用内连接的话，将显示表 tb 中所有的纪录。</p>
</blockquote>
<h4 id="使用-“-”-代替-IN-会报错吗"><a href="#使用-“-”-代替-IN-会报错吗" class="headerlink" title="使用 “=” 代替 IN 会报错吗"></a>使用 “=” 代替 IN 会报错吗</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT * 
            FROM tb1 
    WHERE empid = (SELECT empid FROM tb WHERE sales >= 200);
ERROR 1242 (21000): Subquery returns more than 1 row</code></pre>
<p>很遗憾，执行此命令会出现 <code>ERROR 1242 (21000): Subquery returns more than 1 row</code>（子查询返回的结果多于一行）。如果满足 “e pid 与 x x 恰好一致” 的条件，使用 “=” 也无妨。但是在这个示例中，多条记录在第一阶段被提取了出来，因此必须使用表示 “…之一” 的 IN。</p>
<p>当然，如果只有一条相对应的记录，那么即使使用 “=” 也不会报错。如：</p>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * 
            FROM tb1 
    WHERE empid = (SELECT empid FROM tb ORDER BY sales DESC LIMIT 1);
+-------+--------+------+
| empid | name   | age  |
+-------+--------+------+
| A101  | 佐腾   |   40 |
+-------+--------+------+
1 row in set (0.00 sec)</code></pre>
<p>LIMIT 1 时仅能提出一条记录，所以使用 “=” 也不会报错。</p>
<h4 id="使用-EXISTS，仅以存在的记录为对象"><a href="#使用-EXISTS，仅以存在的记录为对象" class="headerlink" title="使用 EXISTS，仅以存在的记录为对象"></a>使用 EXISTS，仅以存在的记录为对象</h4><p>我们也可以使用 EXISTS，不返回指定的列而返回 “第一阶段子查询存在的目标记录” 这样的信息。</p>
<ul>
<li>从表 tb 中提取有销售额的员工的记录，然后从表 tb1 中提取相对应的记录显示出来。</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ SELECT * 
            FROM tb1 
    WHERE EXISTS(SELECT * FROM tb WHERE tb.empid = tb1.empid);
+-------+--------+------+
| empid | name   | age  |
+-------+--------+------+
| A101  | 佐腾   |   40 |
| A102  | 高桥   |   28 |
| A103  | 中川   |   20 |
| A104  | 渡边   |   23 |
+-------+--------+------+
4 rows in set (0.00 sec)</code></pre>
<p>A105 在表 tb 中不存在相应的 empid，所以没有显示出来。从中我们可以知道，A105 的西泽没有销售额。</p>
<h4 id="使用-NOT-EXISTS"><a href="#使用-NOT-EXISTS" class="headerlink" title="使用 NOT EXISTS"></a>使用 NOT EXISTS</h4><pre class=" language-mysql"><code class="language-mysql">$ SELECT * 
            FROM tb1 
    WHERE EXISTS(SELECT * FROM tb WHERE tb.empid = tb1.empid);
| empid | name   | age  |
+-------+--------+------+
| A105  | 西泽   |   35 |
+-------+--------+------+
1 row in set (0.01 sec)    </code></pre>
<p>从中我们可以知道，没有销售额的员工是 35 岁的 A105 西泽。</p>
<h4 id="排序的技巧-其二"><a href="#排序的技巧-其二" class="headerlink" title="排序的技巧 其二"></a>排序的技巧 其二</h4><p>在使用子查询的情况下，我们可以用各种各样的方法进行排序，而且这些方法比自连接的方法更容易理解。这里来介绍其中一种方法。</p>
<ul>
<li>创建和表 tb 结构相同的表 tb_rank。</li>
<li>向表 tb_rank 中添加具有自动连续编号功能的列 c_rank。</li>
<li>对表 tb 执行按列 sales 由高到低排序的 SELECT 子查询</li>
<li>将子查询的结果 INSERT 到 tb_rank 中。</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">$ CREATE TABLE tb_rank LIKE tb;
$ ALTER TABLE tb_rank ADD c_rank INT AUTO_INCREMENT PRIMARY KEY;
$ INSERT INTO tb_rank(empid, sales, month) (SELECT empid,sales, month FROM tb ORDER BY sales DESC);
$ SELECT * FROM tb_rank;
+-------+-------+-------+--------+
| empid | sales | month | c_rank |
+-------+-------+-------+--------+
| A101  |   300 |     5 |      1 |
| A102  |   205 |     6 |      2 |
| A101  |   184 |     4 |      3 |
| A104  |   181 |     4 |      4 |
| A103  |   101 |     4 |      5 |
| A104  |    93 |     5 |      6 |
| A107  |    87 |     6 |      7 |
| A102  |    54 |     5 |      8 |
| A103  |    17 |     5 |      9 |
| A103  |    12 |     6 |     10 |
+-------+-------+-------+--------+
10 rows in set (0.00 sec)</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/posts/1e3a.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们常把 23 种经典的设计模式分为三类：创建型、结构型、行为型。创建型设计模式主要解决 “对象的创建” 问题，结构性设计模式主要解决 “类或对象的组合或组装” 问题，那行为型设计模式主要解决的就是 “类或对象之间的交互” 问题。</p>
<p>行为型设计模式比较多，有 11 个，几乎占了 23 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p>
<p>观察者模式属于行为型设计模式，也是在实际的开发中用得比较多的一种模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。这篇文章通过实现一个基于观察者模式的异步非阻塞的 EventBus，加深对这个模式的理解。</p>
<h3 id="原理及应用场景剖析"><a href="#原理及应用场景剖析" class="headerlink" title="原理及应用场景剖析"></a>原理及应用场景剖析</h3><p><strong>观察者模式（Observer Design Pattern）</strong>也被称为<strong>发布订阅模式（Publish-Subscribe Design Pattern）</strong>。在 GoF 的 《设计模式》 一书中，它的定义是这样的：</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state，all its dependents are notified and updated automatically.</p>
</blockquote>
<p>翻译成中文就是：<strong>在对象之间定义一个 一对多 的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</strong></p>
<p>一般情况下，被依赖的对象叫作 <strong>被观察者（Observable）</strong>，依赖的对象叫作 <strong>观察者（Observer）</strong>。不过，在实际的项目开发中，这两种对象的称呼是对象灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>
<p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。现在，我们先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">registerObserver</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerObserver</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeObserver</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer observer <span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserverOne</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//TODO: 获取消息通知，执行自己的逻辑...</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteObserverOne is notified."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserverTwo</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//TODO: 获取消息通知，执行自己的逻辑...</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteObserverTwo is notified."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ConcreteSubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    subject<span class="token punctuation">.</span><span class="token function">registerObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteObserverOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    subject<span class="token punctuation">.</span><span class="token function">registerObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteObserverTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>实际上，上面的代码算是观察者模式的 “模板代码”，只能反映大体的思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的。</p>
<p>原理和代码实现都非常简单，也比较好理解，不需要我过多的解释。我们还是通过一个具体的例子来重点讲一下，什么情况下需要用到这种设计模式？或者说，这种设计模式能解决什么问题呢？</p>
<p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>
  <span class="token keyword">private</span> PromotionService promotionService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>

  <span class="token keyword">public</span> Long <span class="token function">register</span><span class="token punctuation">(</span>String telephone<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//省略输入参数的校验代码</span>
    <span class="token comment" spellcheck="true">//省略userService.register()异常的try-catch代码</span>
    <span class="token keyword">long</span> userId <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>telephone<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    promotionService<span class="token punctuation">.</span><span class="token function">issueNewUserExperienceCash</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> userId<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p>
<p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠卷，并且还要给用户发送一封 “欢迎注册成功“ 的站内信。这种情况下，我们就需要频繁地修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p>
<p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RegObserver</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">handleRegSuccess</span><span class="token punctuation">(</span><span class="token keyword">long</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegPromotionObserver</span> <span class="token keyword">implements</span> <span class="token class-name">RegObserver</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> PromotionService promotionService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRegSuccess</span><span class="token punctuation">(</span><span class="token keyword">long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    promotionService<span class="token punctuation">.</span><span class="token function">issueNewUserExperienceCash</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegNotificationObserver</span> <span class="token keyword">implements</span> <span class="token class-name">RegObserver</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> NotificationService notificationService<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRegSuccess</span><span class="token punctuation">(</span><span class="token keyword">long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    notificationService<span class="token punctuation">.</span><span class="token function">sendInboxMessage</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> <span class="token string">"Welcome..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>
  <span class="token keyword">private</span> List<span class="token operator">&lt;</span>RegObserver<span class="token operator">></span> regObservers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 一次性设置好，之后也不可能动态的修改</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRegObservers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>RegObserver<span class="token operator">></span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    regObservers<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>observers<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> Long <span class="token function">register</span><span class="token punctuation">(</span>String telephone<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//省略输入参数的校验代码</span>
    <span class="token comment" spellcheck="true">//省略userService.register()异常的try-catch代码</span>
    <span class="token keyword">long</span> userId <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>telephone<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>RegObserver observer <span class="token operator">:</span> regObservers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      observer<span class="token punctuation">.</span><span class="token function">handleRegSuccess</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> userId<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册消息给大数据征信系统，基于观察者模式的代码实现， <code>UserController</code> 类的 <code>register()</code> 函数完全不需要修改，只需要再添加一个实现了 <code>RegObserver</code> 接口的类，并且通过 <code>setRegObservers()</code> 函数将它注册到 <code>UserController</code> 类中即可。</p>
<p>不过，你可能会说，当我们把发送体验金替换为发送优惠卷的时候，需要修改 <code>RegPromotionObserver</code> 类中 <code>handleReqSuccess()</code> 函数的代码，这还是违反开闭原则呀？你说得没错，不过，相对于 <code>register()</code> 函数来说，<code>handleRegSuccess()</code> 函数的逻辑要简单很多，修改更不容易出错，引入 bug 的风险更低。</p>
<p>实际上，<strong>设计模式要干的事情就是解耦。创建型模式是将创建代码和使用代码解耦，结构性模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，依次来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<h3 id="基于不同应用场景的不同实现方式"><a href="#基于不同应用场景的不同实现方式" class="headerlink" title="基于不同应用场景的不同实现方式"></a>基于不同应用场景的不同实现方式</h3><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p>
<p>不同的应用场景和需求下，这个模式也有截然不同的实现方式。有同步阻塞的实现方式，也有异步非阻塞的实现方式，有进程内的实现方式，也有跨进程的实现方式。</p>
<p>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，<code>register()</code> 函数依次调用执行每个观察者的 <code>handleRegSuccess()</code> 函数，等到都执行完成之后，才会返回结果给客户端。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当 <code>userService.register()</code> 函数执行完成之后，我们启动一个新的线程来执行观察者的 <code>handleRegSuccess()</code> 函数，这样 <code>userController.register()</code> 函数就不需要等到所有的 <code>handleRegSuccess()</code> 函数都执行完成之后才返回结果给客户端。</p>
<p><code>userController.register()</code> 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句才返回，响应时间粗略来讲减少为原来的 1/3。</p>
<p>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 <code>handleRegSuccess()</code> 函数中，创建一个新的线程执行代码。不过我们还有一种更加优雅的实现方式，那就是基于 EventBus 来实现 。</p>
<p>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p>
<p>如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现思路，在 <code>handleRegSuccess()</code> 函数中调用 RPC 接口来发送数据。但是我们还有一种更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 RocketMQ）来实现。</p>
<p>当然这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显：在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行响应的逻辑。</p>
<h3 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h3><p>对于异步非阻塞观察者模式，如果只是实现了一个简易版本，不考虑任何通用性、复用性，实际上是非常容易的。</p>
<p>我们有两种实现方式。其中一种是：在每个 <code>handleRegSuccess()</code> 函数中创建一个新的线程执行代码逻辑；另一种是：在 UserController 的 <code>register()</code> 函数中使用线程池来执行每个观察者的 <code>handleRegSuccess()</code> 函数。两种实现方式的具体代码如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一种实现方式，其他类代码不变，就没有再重复罗列</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegPromotionObserver</span> <span class="token keyword">implements</span> <span class="token class-name">RegObserver</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> PromotionService promotionService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRegSuccess</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token annotation punctuation">@Override</span>
      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        promotionService<span class="token punctuation">.</span><span class="token function">issueNewUserExperienceCash</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 第二种实现方式，其他类代码不变，就没有再重复罗列</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>
  <span class="token keyword">private</span> List<span class="token operator">&lt;</span>RegObserver<span class="token operator">></span> regObservers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> Executor executor<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">UserController</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>executor <span class="token operator">=</span> executor<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRegObservers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>RegObserver<span class="token operator">></span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    regObservers<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>observers<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> Long <span class="token function">register</span><span class="token punctuation">(</span>String telephone<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//省略输入参数的校验代码</span>
    <span class="token comment" spellcheck="true">//省略userService.register()异常的try-catch代码</span>
    <span class="token keyword">long</span> userId <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>telephone<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>RegObserver observer <span class="token operator">:</span> regObservers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          observer<span class="token punctuation">.</span><span class="token function">handleRegSuccess</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> userId<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 <code>register()</code> 函数中，增加了这部分业务代码的维护成本。</p>
<p>如果我们的需求更加极端一点，需要在同步阻塞和异步阻塞之间灵活切换，那就要不停地修改 UserController 的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。</p>
<p>我们知道，框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，而这个框架就是要说的 EventBus。</p>
<h3 id="EventBus-框架功能需求介绍"><a href="#EventBus-框架功能需求介绍" class="headerlink" title="EventBus 框架功能需求介绍"></a>EventBus 框架功能需求介绍</h3><p>EventBus 翻译为 ”事件总线“，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。</p>
<p>现在，我们就通过例子来看一下，Guava EventBus 具有哪些功能。还是用户注册的例子，我们用 Guava EventBus 重新实现以下，代码如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>

  <span class="token keyword">private</span> EventBus eventBus<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_EVENTBUS_THREAD_POOL_SIZE <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">UserController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//eventBus = new EventBus(); // 同步阻塞模式</span>
    eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncEventBus</span><span class="token punctuation">(</span>Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>DEFAULT_EVENTBUS_THREAD_POOL_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 异步非阻塞模式</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRegObservers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Object<span class="token operator">></span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Object observer <span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      eventBus<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> Long <span class="token function">register</span><span class="token punctuation">(</span>String telephone<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//省略输入参数的校验代码</span>
    <span class="token comment" spellcheck="true">//省略userService.register()异常的try-catch代码</span>
    <span class="token keyword">long</span> userId <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>telephone<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>

    eventBus<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> userId<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegPromotionObserver</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> PromotionService promotionService<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 依赖注入</span>

  <span class="token annotation punctuation">@Subscribe</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRegSuccess</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    promotionService<span class="token punctuation">.</span><span class="token function">issueNewUserExperienceCash</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegNotificationObserver</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> NotificationService notificationService<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@Subscribe</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRegSuccess</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    notificationService<span class="token punctuation">.</span><span class="token function">sendInboxMessage</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> <span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>利用 EventBus 框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上来说，实现思路大致一样，都需要定义 Observer，并且通过 <code>register()</code> 函数注册 Observer，也都需要通过调用某个函数（比如，EventBus 中的 post() 函数）来给 Observer 发送消息（在 EventBus 中消息被称作事件 event）。</p>
<p>但在实现细节方面，它们又有些区别。基于 EventBus，我们不需要定义 Observer 接口，任意类型的对象都可以注册到 EventBus 中，通过 @Subscribe 注解来标明类中哪个函数可以接受被观察者发送的消息。</p>
<p>接下来，我们详细地讲一下，Guava EventBus 的几个只要的类和函数。</p>
<ul>
<li>EventBus、AsyncEventBus</li>
</ul>
<p>Guava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。具体使用方法如下所示：</p>
<pre class=" language-java"><code class="language-java">EventBus eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 同步阻塞模式</span>
EventBus eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncEventBus</span><span class="token punctuation">(</span>Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>；<span class="token comment" spellcheck="true">// 异步阻塞模式</span></code></pre>
<ul>
<li>register() 函数</li>
</ul>
<p>EventBus 类提供了 <code>register()</code> 函数用来注册观察者。具体的函数定义如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>它可以接受任何类型（Object）的观察者。而在经典的观察者模式的实现中，register() 函数必须接受实现了同一 Observer 接口的类对象。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>unregister() 函数</li>
</ul>
<p>相对于 register() 函数，<code>unregister()</code> 函数用来从 EventBus 中删除某个观察者。我就不多解释了，具体的函数定义如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unregister</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>post() 函数</li>
</ul>
<p>EventBus 类提供了 post() 函数，用来给观察者发送消息。具体函数定义如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">post</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>跟经典的观察者模式的不同之处在于，当我们调用 <code>post()</code>函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接受的消息类型是发送消息（post 函数定义的 event）类型是同一类型（本类和子类）。我举个例子来解释一下。</p>
<p>比如，<code>AObserver</code> 能接收的消息类型是 <code>XMsg</code>，<code>BObserver</code> 能接收的消息类型是 <code>YMsg</code>，<code>CObserver</code> 能接收的消息类型是 <code>ZMsg</code>。其中，<code>XMsg</code> 是 <code>YMsg</code> 的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p>
<pre class=" language-java"><code class="language-java">XMsg xMsg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
YMsg yMsg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ZMsg zMsg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">post</span><span class="token punctuation">(</span>xMsg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">></span> AObserver接收到消息
<span class="token function">post</span><span class="token punctuation">(</span>yMsg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">></span> AObserver、BObserver接收到消息
<span class="token function">post</span><span class="token punctuation">(</span>zMsg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">></span> CObserver接收到消息</code></pre>
<p>你可能会问，每个 Observer 能接受的消息类型是在哪里定义的呢？我们来看一下 Guava EventBus 最特别的一个地方，那就是 @Subscribe 注解。</p>
<ul>
<li>@Subscribe 注解</li>
</ul>
<p>EventBus 通过 @Subscribe 注解来标明，某个函数能接收哪种类型的消息。具体的使用代码如下所示。在 DObserver 类中，我们通过 @Subscribe 注解了两个函数 f1()、f2()。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> DObserver<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...省略其它属性和方法...</span>

    <span class="token annotation punctuation">@Subscribe</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>PMsg event<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>

    <span class="token annotation punctuation">@Subscribe</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>OMsg event<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
<span class="token punctuation">}</span></code></pre>
<p>当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且将两个函数能接受的消息类型记录下来（PMsg -&gt; f1, QMsg -&gt; f2）。当我们通过 post() 函数发送消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg -&gt; f2），调用相应的函数（f2）。</p>
<h3 id="手把手实现一个-EventBus-框架"><a href="#手把手实现一个-EventBus-框架" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h3><p>Guava EventBus 的功能我们已经讲清楚了，总体上来说，还是比较简单的。接下来，我们就重复造轮子，“山寨” 一个 EventBus 出来。</p>
<p>我们重点来看，EventBus 中两个核心函数 register() 和 post() 的实现原理。弄懂了它们，基本上就弄懂了整个 EventBus 框架。下面两张图是这两个函数的实现原理图。</p>
<p><img src="C:\Users\a9763\AppData\Roaming\Typora\typora-user-images\image-20210125092809112.png" alt="image-20210125092809112"></p>
<p>从图中我们可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接受消息函数的对应关系。</p>
<p><img src="C:\Users\a9763\AppData\Roaming\Typora\typora-user-images\image-20210125093300900.png" alt="image-20210125093300900"></p>
<p>当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接受消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p>
<p>弄懂了原理，实现起来就简单多了。整个小框架的代码实现包括 5 个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。接下来，我们依次来看下这 5 个类。</p>
<ol>
<li>Subscribe</li>
</ol>
<p>Subscribe 是一个注解，用于标明观察者中的哪个函数可以接受消息。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Subscribe</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<ol start="2">
<li>ObserverAction</li>
</ol>
<p>ObserverAction 类用来表示 @Subscribe 注解的方法，其中，target 表示观察者类，method 表示方法。它主要用在 ObserverRegistry 观察者注册表中。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverAction</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Method method<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">ObserverAction</span><span class="token punctuation">(</span>Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> Preconditions<span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>method <span class="token operator">=</span> method<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// event是method方法的参数</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> <span class="token operator">|</span> IllegalAccessException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ol start="3">
<li>ObserverRegistry</li>
</ol>
<p>ObserverRegistry 类就是前面讲到的 Observer 注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类大量使用了 Java 的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是 CopyOnWriteArraySet 的使用。</p>
<p>CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的 set，并且将原始数据 clone 到新的 set中，在新的 set 中写入数据完成之后，再用新的 set 替换老的 set。这样就能保证在写入数据的时候，不影响数据的读取操作，以此来解决读写并发问题。除此之外，CopyOnWriteArraySet还通过加锁的方式，避免了并发写冲突。具体的作用你可以去查看一下 CopyOnWriteArraySet类的源码，一目了然。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverRegistry</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> ConcurrentMap<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> CopyOnWriteArraySet<span class="token operator">&lt;</span>ObserverAction<span class="token operator">>></span> registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Object observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>ObserverAction<span class="token operator">>></span> observerActions <span class="token operator">=</span> <span class="token function">findAllObserverActions</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>ObserverAction<span class="token operator">>></span> entry <span class="token operator">:</span> observerActions<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      Collection<span class="token operator">&lt;</span>ObserverAction<span class="token operator">></span> eventActions <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      CopyOnWriteArraySet<span class="token operator">&lt;</span>ObserverAction<span class="token operator">></span> registeredEventActions <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>registeredEventActions <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        registry<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArraySet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        registeredEventActions <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      registeredEventActions<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>eventActions<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>ObserverAction<span class="token operator">></span> <span class="token function">getMatchedObserverActions</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>ObserverAction<span class="token operator">></span> matchedObservers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> postedEventType <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> CopyOnWriteArraySet<span class="token operator">&lt;</span>ObserverAction<span class="token operator">>></span> entry <span class="token operator">:</span> registry<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      Collection<span class="token operator">&lt;</span>ObserverAction<span class="token operator">></span> eventActions <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>postedEventType<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        matchedObservers<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>eventActions<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> matchedObservers<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>ObserverAction<span class="token operator">>></span> <span class="token function">findAllObserverActions</span><span class="token punctuation">(</span>Object observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>ObserverAction<span class="token operator">>></span> observerActions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> observer<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> <span class="token function">getAnnotatedMethods</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> eventType <span class="token operator">=</span> parameterTypes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>observerActions<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        observerActions<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      observerActions<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>eventType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObserverAction</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> observerActions<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Method<span class="token operator">></span> <span class="token function">getAnnotatedMethods</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Method<span class="token operator">></span> annotatedMethods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Subscribe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Preconditions<span class="token punctuation">.</span><span class="token function">checkArgument</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span>
                <span class="token string">"Method %s has @Subscribe annotation but has %s parameters."</span>
                        <span class="token operator">+</span> <span class="token string">"Subscriber methods must have exactly 1 parameter."</span><span class="token punctuation">,</span>
                method<span class="token punctuation">,</span> parameterTypes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        annotatedMethods<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> annotatedMethods<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ol start="4">
<li>EventBus</li>
</ol>
<p>EventBus 实现的是阻塞同步的观察者模式。看代码你可能会有疑问，这明明就用到了线程池 Executor 啊。实际上，<code>MoreExectors.directExecutor</code> 是 Google Guava 提供的工具类，看似是多线程，实际上是单线程。之所以要这么实现，主要还是为了跟 AsyncEventBus 统一代码逻辑，做到代码复用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventBus</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> Executor executor<span class="token punctuation">;</span>
  <span class="token keyword">private</span> ObserverRegistry registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObserverRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">EventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>MoreExecutors<span class="token punctuation">.</span><span class="token function">directExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">protected</span> <span class="token function">EventBus</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>executor <span class="token operator">=</span> executor<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    registry<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">post</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>ObserverAction<span class="token operator">></span> observerActions <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">getMatchedObserverActions</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>ObserverAction observerAction <span class="token operator">:</span> observerActions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          observerAction<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ol start="5">
<li>AsyncEventBus</li>
</ol>
<p>有了 EventBus，AsyncEventBus 的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能继续再使用 <code>MoreExectors.directExecutor()</code> 了，而是需要在构造函数中，有调用者注入线程池。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncEventBus</span> <span class="token keyword">extends</span> <span class="token class-name">EventBus</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">AsyncEventBus</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>至此，我们用到不到 200 行代码，就实现了一个还算凑活能用的 EventBus，从功能上来讲，它跟 Google Guava EventBus 几乎一样。不过，如果去查看 <a href="https://github.com/google/guava">google Guava EventBus</a> 的源码，你会发现，在实现细节方面，相比我们现在的实现，它其实做了很多优化，比如优化了在注册表中查找消息可匹配函数的算法。如果有时间的话，建议去一下它的源码。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
</search>
