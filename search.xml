<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git在工作时的概念</title>
    <url>/posts/23d0.html</url>
    <content><![CDATA[<h3 id="进入-git目录"><a href="#进入-git目录" class="headerlink" title="进入.git目录"></a>进入.git目录</h3><p>首先，使用git init来初始化一个空的版本库，然后运行find来看看都创建了什么文件。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> init hello
$ <span class="token function">cd</span> hello
已初始化空的 Git 仓库于 /Users/asiama/IdeaProjects/hello/.git/
<span class="token comment" spellcheck="true"># 列出当前目录中的所有文件</span>
$ <span class="token function">find</span> <span class="token keyword">.</span>
<span class="token keyword">.</span>
./.git
./.git/config
./.git/objects
./.git/objects/pack
./.git/objects/info
./.git/HEAD
./.git/info
./.git/info/exclude
./.git/description
./.git/hooks
./.git/hooks/commit-msg.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/pre-commit.sample
./.git/hooks/applypatch-msg.sample
./.git/hooks/fsmonitor-watchman.sample
./.git/hooks/pre-receive.sample
./.git/hooks/prepare-commit-msg.sample
./.git/hooks/post-update.sample
./.git/hooks/pre-merge-commit.sample
./.git/hooks/pre-applypatch.sample
./.git/hooks/pre-push.sample
./.git/hooks/update.sample
./.git/refs
./.git/refs/heads
./.git/refs/tags</code></pre>
<p>可以看到，.git 目录包含很多内容。这些文件是基于模板目录显示的，根据需要可以进行调整。根据使用的Git的版本，实际列表可能看起来会有一点不同。例如，旧版本的Git不对.git/hooks文件使用.sample后缀。</p>
<p>最初，除了几个占位符之外，.git/objects目录（用来存放所有Git对象的目录）是空的。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> .git/objects
.git/objects
.git/objects/pack
.git/objects/info</code></pre>
<p>现在，让我们创建一个简单的对象。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"hello world"</span> <span class="token operator">></span> hello.txt
$ <span class="token function">git</span> add hello.txt</code></pre>
<p>如果输入的“hello world”跟这里一样（没有改变间距和大小写），那么objects目录应该如下所示：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> .git/objects
.git/objects
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/pack
.git/objects/info</code></pre>
<p>所有这一切看起来很神秘。其实不然，下面会慢慢解释原因。</p>
<h3 id="对象、散列和blob"><a href="#对象、散列和blob" class="headerlink" title="对象、散列和blob"></a>对象、散列和blob</h3><p>当为hello.txt创建一个对象的时候，Git并不关心hello.txt的文件名。Git只关心文件里面的内容：表示“hello world”的10个字节和换行符（跟之前创建的blob一样）。Git对这个blob执行一些操作，计算它的SHA1散列值，把散列值的十六进制表示作为文件名它放进对象库中。</p>
<blockquote>
<p><strong>如何知道一个SHA1散列值是唯一的？</strong></p>
<p>两个不同blob产生相同SHA1散列值的机会十分渺茫。当这种情况发生的时候，称为一次碰撞。然而，一次SHA1碰撞的可能性太低，你可以放心地认为它不会干扰我们对Git的使用。</p>
<p>SHA1是“安全散列加密”算法。直到现在，没有任何已知的方法（除了运气之外）可以让一个用户刻意造成一次碰撞。但是碰撞会随机发生吗？让我们来看看。</p>
<p>对于160位数，你有2的160次方或者大约10的48次方（1后面跟48个0）种可能的SHA1散列值。这个数是极其巨大的。即使你雇用一万亿人来每秒产生一万亿个新的唯一blob对象，持续一万亿年，你也只有10的43次方个blob对象。</p>
<p>如果你散列了2的80次方个随机blob，可能会发生一次碰撞。</p>
</blockquote>
<p>在这种情况下散列值是3b18e512dba79e4c8300dd08aeb37f8e728b8dad。160位的SHA1散列值对应20 个字节，这需要40 个十六进制来显示，因此这内容另存为.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad。<strong>Git在前两个数字后面插入一个“/”以提高文件系统效率（如果你把太多的文件放在同一个目录中，一些文件系统会变慢；使SHA1的第一个字节成为一个目录是一个很简单的办法，可以为所有均匀分布的可能对象创建一个固定的、256路分区的命名空间）</strong>。</p>
<p>为了展示Git真的没有对文件的内容做很多事情（它还是同样的内容“hello world”），可以在任何时间使用散列值把它从对象库里提取出来。</p>
<pre><code>$ git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
hello world</code></pre>
<p>Git也知道手动输入40个字符是很不切实际的，因此它提供了一个命令通过对象的唯一前缀来查找对象的散列值。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> rev-parse 3b18e512d
3b18e512dba79e4c8300dd08aeb37f8e728b8dad</code></pre>
<h3 id="文件和树"><a href="#文件和树" class="headerlink" title="文件和树"></a>文件和树</h3><p>既然“hello world”那个blob已经安置在对象库里了，那么它的文件名又发生了什么事呢？如果不能通过文件名找到文件Git就太没用了。</p>
<p>正如前面提到的，Git通过另一种叫做目录树（tree）的对象来跟踪文件的路径名。当使用git add命令时，Git会给添加的每个文件的内容创建一个对象，但它并不会马上为树创建一个对象。相反，索引更新了。索引位于.git/index中，它跟踪文件的路径名和相应的blob。每次执行命令（比如，git  add、git rm或者git mv）的时候，Git会用新的路径名和blob信息来更新索引。</p>
<p>任何时候，都可以从当前索引创建一个树对象，只要通过底层的git  write-tree命令来捕获索引当前信息的快照就可以了。</p>
<p>目前，该索引只包含一个文件，hello.txt。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> ls-files -s
100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0    hello.txt</code></pre>
<p>在这里你可以看到文件的关联，hello.txt与3b18e4…的blob。</p>
<p>接下来，让我们捕获索引状态并把它保存到一个树对象里。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ <span class="token function">find</span> .git/objects
.git/objects
.git/objects/68
.git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/pack
.git/objects/info</code></pre>
<p>现在有两个对象：3b18e5的“hello world”对象和一个新的68aba6树对象。可以看到，SHA1对象名完全对应.git/objects下的子目录和文件名。</p>
<p>但是树是什么样子的呢？因为它是一个对象，就像blob一样，所以可以用底层命令来查看它。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p 68aba6
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt</code></pre>
<p>对象的内容应该很容易解释。第一个数100644，是对象的文件属性的八进制表示，用过UNIX的chmod命令的人应该对这个很熟悉了。这里，3b18e5是hello world的blob的对象名，hello.txt是与该blob关联的名字</p>
<p>当执行<code>git ls-files -s</code>的时候，很容易就可以看到树对象已经捕获了索引中的信息。</p>
<h3 id="对Git使用SHA1的一点说明"><a href="#对Git使用SHA1的一点说明" class="headerlink" title="对Git使用SHA1的一点说明"></a>对Git使用SHA1的一点说明</h3><p>在更详细地讲解树对象的内容之前，让我们先来看看SHA1散列的一个重要特性。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ <span class="token function">git</span> write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ <span class="token function">git</span> write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60</code></pre>
<p>每次对相同的索引计算一个树对象，它们的SHA1散列值仍是完全一样的。Git并不需要重新创建一个新的树对象。</p>
<p>这样看来，散列函数在数学意义上是一个真正的函数：对于一个给定的输入，它总产生相同的输出。这样的散列函数有时也称为摘要，用来强调它就像散列对象的摘要一样。当然，任何散列函数（即使是低级的奇偶校验位）也有这个属性。</p>
<p>这是非常重要的。例如，如果你创建了跟其他开发人员相同的内容，无论你俩在何时何地工作，相同的散列值就足以证明全部内容是一致的。事实上，Git确实将它们视为一致的。但是等一下—SHA1散列是唯一的吗？难道万亿人每秒产生的万亿个blob永远不会产生一次碰撞吗？</p>
<p>在这种情况下，相同的SHA1散列值并不算碰撞。只有两个不同的对象产生一个相同的散列值时才算碰撞。在这里，你创建了相同内容的两个单独实例，相同的内容始终有相同的散列值。</p>
<p>Git 依赖于SHA1 散列函数的另一个后果：你是如何得到称为68aba62e560c0ebc3396 e8ae9335232cd93a3f60的树的并不重要。Bob通过合并Jennie的提交A、提交B和Sergey的提交C来创建这个树，而你是从Sue得到提交A，然后从Lakshmi那里更新提交B和提交C的合并。结果都是一样的，这有利于分布式开发。</p>
<p>如果要求你查看对象68aba62e560c0ebc3396e8ae9335232cd93a3f60，并且你能找到这样的一个对象，同时因为SHA1是一个加密散列算法，因此你就可以确信你找的对象跟散列创建时的那个对象的数据是相同的。</p>
<p>反过来也是如此：如果你在你的对象库里没找到具有特定散列值的对象，那么你就可以肯定你没有持有那个对象的副本。总之，你可以判断你的对象库是否有一个特定的的对象，即使你对它（可能非常大）的内容一无所知。因此，散列就好似对象的可靠标签或名称。</p>
<p>但是Git也依赖于比那个结论更强的东西。考虑最近的一次提交（或者它关联的树对象）。因为它包含其父提交以及树的散列，反过来又通过递归整个数据结构包含其所有子树和blob的散列，因此可归结为它通过原始提交的散列值唯一标识整个数据结构在提交时的状态。</p>
<p>最后，我们在上一段中的声明可以推出散列函数的强大应用：它提供了一种有效的方法来比较两个对象，甚至是两个非常大而复杂的数据，而且并不需要完全传输。</p>
<h3 id="树层次结构"><a href="#树层次结构" class="headerlink" title="树层次结构"></a>树层次结构</h3><p>只有单个文件的信息是很好管理的，但项目包含复杂而且深层嵌套的目录结构，并且会随着时间的推移而重构和移动。通过创建一个新的子目录，该目录包含hello.txt的一个完全相同的副本，让我们看看Git是如何处理这个问题的。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">pwd</span>
/Users/asiama/IdeaProjects/hello
$ <span class="token function">mkdir</span> subdir
$ <span class="token function">cp</span> hello.txt subdir
$ <span class="token function">git</span> add subdir/hello.txt
$ <span class="token function">git</span> write-tree
492413269336d21fac079d4a4672e55d5d2147ac
$ <span class="token function">git</span> cat-file -p 4924132693
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
040000 tree 68aba62e560c0ebc3396e8ae9335232cd93a3f60    subdir</code></pre>
<p>新的顶级树包含两个条目：原始的hello.txt以及新的子目录，子目录是树而不是 blob。注意到不寻常之处了吗？仔细看subdir的对象名。是你的老朋友，68aba62e560c0 ebc3396e8ae9335232cd93a3f60！</p>
<p>刚刚发生了什么？subdir的新树只包含一个文件hello.txt，该文件跟旧的“hello  world”内容相同。所以subdir树跟以前的顶级树是完全一样的！当然它就有跟之前一样的SHA1对象名了。让我们来看看.git/objects目录，看看最近的更改有哪些影响。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> .git/objects
.git/objects
.git/objects/68
.git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/pack
.git/objects/info
.git/objects/49
.git/objects/49/2413269336d21fac079d4a4672e55d5d2147ac</code></pre>
<p>这只有三个唯一的对象：一个包含“hello world”的blob；一棵包含hello.txt的树，文件里是“hello world”加一个换行；还有第一棵树旁边包含hello.txt的另一个索引的另一棵树。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -t 492413269336d21fac079d4a4672e55d5d2147ac
tree
$ <span class="token function">git</span> cat-file -p 492413269336d21fac079d4a4672e55d5d2147ac
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
040000 tree 68aba62e560c0ebc3396e8ae9335232cd93a3f60    subdir</code></pre>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>讨论的下一主题是提交（commit）。现在hello.txt已经通过git add命令添加了，树对象也通过git write-tree命令生成了，可以像这样用底层命令那样创建提交对象。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> -n <span class="token string">"Commit a file that says hello\n"</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree 492413269336d21fac079d4a4672e55d5d2147ac
2c991b784138747072d3544b3d7eb4552e57daab</code></pre>
<p>结果如下所示:</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p 2c991b7841
tree 492413269336d21fac079d4a4672e55d5d2147ac
author asiama <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span> 1601055237 +0800
committer asiama <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span> 1601055237 +0800

Commit a <span class="token function">file</span> that says hello</code></pre>
<p>你可能会发现你生成的提交对象跟上面的名字不一样。如果你已经理解了目前为止的一切内容，那原因就很明显了：这是不同的提交。提交包含你的名字和创建提交的时间，尽管这区别很微小，但依然是不同的。另一方面，你的提交确实有相同的树。这就是提交对象与它们的树对象分开的原因：不同的提交经常指向同一棵树。当这种情况发生时，Git能足够聪明地只传输新的提交对象，这是非常小的，而不是很可能很大的树和blob对象。</p>
<p>在实际生活中，你可以（并且应该）跳过底层的git write-tree和git commit-tree步骤，并只使用git commit命令。成为一个完全快乐的Git用户，你不需要记住那些底层命令。</p>
<p>一个基本的提交对象是相当简单的，这是成为一个真正的RCS需要的最后组成部分。提交对象可能是最简单的一个，包含：</p>
<ul>
<li>标识关联文件的树对象的名称；</li>
<li>创作新版本的人（作者）的名字和创作的时间；</li>
<li>把新版本放到版本库的人（提交者）的名字和提交的时间；</li>
<li>对本次修订原因的说明（提交消息）。</li>
</ul>
<p>默认情况下，作者和提交者是同一个人，也有一些情况下，他们是不同的。</p>
<p>可以使用git show –pretty=fuller命令来查看给定提交的其他细节。</p>
<p>尽管提交对象跟树对象用的结构是完全不同的，但是它也存储在图结构中。当你做一个新提交时，你可以给它一个或多个父提交。通过继承链来回溯，可以查看项目历史。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>最后，Git还管理的一个对象就是标签。尽管Git只实现了一种标签对象，但是有两种基本的标签类型，通常称为轻量级的（lightweight）和带附注的（annotated）。</p>
<p>轻量级标签只是一个提交对象的引用，通常被版本库视为是私有的。这些标签并不在版本库里创建永久对象。带标注的标签则更加充实，并且会创建一个对象。它包含你提供的一条消息，并且可以根据RFC 4880来使用GnuPG密钥进行数字签名。</p>
<p>Git在命名一个提交的时候对轻量级的标签和带标注的标签同等对待。不过，默认情况下，很多Git命令只对带标注的标签起作用，因为它们被认为是“永久”的对象。</p>
<p>可以通过<code>git tag</code>命令来创建一个带有提交信息、带附注且未签名的标签：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> tag -m <span class="token string">"Tag version 1.0"</span> V1.0 2c991b78</code></pre>
<p>可以通过git cat-file -p命令来查看标签对象，但是标签对象的SHA1值是什么呢？为了找到它，使用</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> rev-parse V1.0
75ea1517ca3a5987df8f31414a18e9b332622b43
$ <span class="token function">git</span> cat-file -p 75ea1517ca
object 2c991b784138747072d3544b3d7eb4552e57daab
<span class="token function">type</span> commit
tag V1.0
tagger asiama <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span> 1601056048 +0800

Tag version 1.0</code></pre>
<p>除了日志消息和作者信息之外，标签指向提交对象75ea1517ca。通常情况下，Git通过某些分支来给特定的提交命名标签。请注意，这种行为跟其他VCS有明显的不同。</p>
<p>Git通常给指向树对象的提交对象打标签，这个树对象包含版本库中文件和目录的整个层次结构的总状态。</p>
<p>回想一下上面的图，V1.0标签指向提交1492—依次指向跨越多个文件的树（8675309）。因此，这个标签同时适用于该树的所有文件。</p>
<p>这跟CVS不同，例如，对每个单独的文件应用标签，然后依赖所有打过标签的文件来重建一个完整的标记修订。并且CVS允许你移动单独文件的标签，而Git则需要在标签移动到的地方做一个新的提交，囊括该文件的状态变化。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git介绍</title>
    <url>/posts/f3f.html</url>
    <content><![CDATA[<h3 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h3><p>在Git诞生之前，Linux内核开发过程中使用BitKeeper来作为VCS。BitKeeper提供当时的一些开源VCS（如RCS、CVS）所不能提供的高级操作。然而，在2005年春天，当BitKeeper的所有方对他们的免费版BitKeeper加入了额外的限制时，Linux社区意识到，使用BitKeeper不再是一个长期可行的解决方案。</p>
<p>Git于2005年4月诞生了。不久之后，Linux内核的第一个提交也诞生了。这一次提交将整个Linux内核导入Git版本库中。这次提交的统计信息如下：</p>
<pre class=" language-bash"><code class="language-bash">17291 files changed, 6718755 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>，0 deletions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>。</code></pre>
<p>是的，这次提交足足引入了670万行代码。</p>
<h3 id="先例"><a href="#先例" class="headerlink" title="先例"></a>先例</h3><p>源码控制系统（Source Code Control System, SCCS）是UNIX上最初的几个系统之一，由M.J.Rochkind于20世纪70年代早期开发。这是可以运行在UNIX系统上最早的VCS。</p>
<p>SCCS 提供的数据存储中心称为“版本库”（repository），而这个基本概念一直沿用至今。SCCS 同样提供了一个简单的锁模型来保证开发过程有序。如果一个开发人员需要运行或者测试一个程序，他需要将该程序解锁并检出。然而，如果他想修改某个文件，他则需要锁定并检出（通过 UNIX 文件系统执行的转换）。当编辑完成以后，他又可以将文件检入到版本库中并解锁它。</p>
<p>修订控制系统（Revision Control System，RCS）由 Walter F. Tichy 于 20 世纪 80 年代早期引入。RCS 引入了双向差异的概念，来提高文件不同版本的存储效率。</p>
<p>并行版本系统（Concurrent Version System，CVS）由 Dick Grune 于 1986 年设计并最初实现。4 年后又被Berliner 和他的团队融入 RCS 模型重新实现，这次实现非常成功。CVS 变得非常流行，并且成为<a href="https://opensource.org/">开源社区</a>许多年的事实标准。CVS 相对 RCS 有多项优势，包括分布式开发和版本库范围内对整个“模块”的更改集。</p>
<p>此外，CVS 引入了一个关于“锁”的新范式。而之前的系统需要开发人员在修改某个文件之前先锁定它， 一个文件同时只允许一个开发人员进行修改，所有需要修改这个文件的开发人员需要有序等候。CVS 给予每个开发人员对于自己的私有版本写的权限。因此，不同开发人员的改动可以自动合并，除非两个开发人员尝试修改同一行。如果出现修改同一行的情况，那这一行将会作为“冲突”被标记出来，由开发 人员手动去解决。这个关于“锁”的新规则使得多个开发人员可以并行地编写代码。</p>
<p>就像经常发生的那样，对 CVS 短处和缺点的改进，促进了新 VCS 的诞生：Subversion（SVN）。SVN 于 2001 年问世，迅速风靡了开源社区。不像 CVS，SVN 以原子方式提交改动部分，并且更好地支持分支。 BitKeeper 和 Mercurial 则彻底抛弃了上述所有解决方案。它们淘汰了中心版本库的概念，取而代之的，数据的存储是分布式的，每个开发人员都拥有自己可共享的版本库副本。Git 则是从这种端点对端点（Peer to Peer）的模型继承而来。</p>
<p>最后，Mercurial 和 Monotone 首创了用散列指纹来唯一标识文件的内容，而文件名只是个“绰号”，旨在方便用户操作，再没有别的作用。Git 沿用了这个概念。从内部实现上来说，Git 的文件标识符基于文件的内容，这是一个叫做“内容可寻址文件存储”（Content Addressable File Store，CAFS）的概念。这不是一个新概念。见<a href="https://www.usenix.org/legacy/events/fast02/quinlan/quinlan_html/index.html">“The Venti Filesystem,” (Plan 9)</a>, Bell Labs,  据 Linus 的说法3，Git 直接从 Monotone 借用了这个概念。Mercurial 也同时实现了这个概念。</p>
<h3 id="名字含义"><a href="#名字含义" class="headerlink" title="名字含义"></a>名字含义</h3><p>据Linus宣称，命名Git，是因为“我是一个自私的混蛋，我照着自己命名我所有的项目，先是Linux，现在是Git。”倘若，Linux这个名字是Linus和Minix的某种结合。那么反用一个表示愚蠢无用之人的英语词汇也不是没可能。</p>
<p>那之后，也有人曾建议，使用一些其它也许更让人舒服的解释。其中最受欢迎的一个就是：全局信息追踪器（Global Information Tracker）。</p>
<h3 id="版本管理的演变"><a href="#版本管理的演变" class="headerlink" title="版本管理的演变"></a>版本管理的演变</h3><p>VCS出现前</p>
<ul>
<li>用目录拷贝区别不同的版本</li>
<li>公共文件容易被覆盖</li>
<li>成员沟通成本很高，代码集成效率低下</li>
</ul>
<img src="https://s1.ax1x.com/2020/09/20/wTkMUU.md.png" alt="VSC出现之前" style="zoom:50%;">

<p>集中式VCS</p>
<ul>
<li>有集中的版本管理服务器</li>
<li>具备文件版本管理和分支管理能力</li>
<li>集成效率有明显的提高</li>
<li>客户端必须时刻和服务器相连</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/20/wTkKET.md.png" alt="集中式VCS"></p>
<p>分布式VCS</p>
<ul>
<li>服务端和客户端都有完整的版本库</li>
<li>脱离服务端，客户端照样可以管理版本</li>
<li>查看历史和版本比较等多数操作，都不需要访问服务器，比集中式VCS更能提高版本管理效率。</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/20/wTkQ5F.md.png" alt="分布式VCS"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/posts/1b99.html</url>
    <content><![CDATA[<h3 id="建Git仓库"><a href="#建Git仓库" class="headerlink" title="建Git仓库"></a>建Git仓库</h3><p>把已有的项目代码纳入Git管理</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> 项目代码所在的文件夹
$ <span class="token function">git</span> init</code></pre>
<p>新建的项目直接用Git管理</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> 某个文件夹
$ <span class="token function">git</span> init your_project <span class="token comment" spellcheck="true"># 会在当前项目下创建和项目名称同名的文件夹</span>
$ <span class="token function">cd</span> your_project</code></pre>
<h3 id="查看提交"><a href="#查看提交" class="headerlink" title="查看提交"></a>查看提交</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 条目按照从最新的到最老的顺序罗列出来</span>
$ <span class="token function">git</span> log 
<span class="token comment" spellcheck="true"># 查看特定提交更加详细的信息</span>
$ <span class="token function">git</span> show commitId 
<span class="token comment" spellcheck="true"># 查看当前分支的最近10次提交</span>
$ <span class="token function">git</span> show-branch --more<span class="token operator">=</span>10
<span class="token comment" spellcheck="true"># 查看简洁信息</span>
$ <span class="token function">git</span> log --oneline
<span class="token comment" spellcheck="true"># 显示最近四次提交的简介信息</span>
$ <span class="token function">git</span> log -n4 --oneline</code></pre>
<h3 id="版本库内文件的删除和重命名"><a href="#版本库内文件的删除和重命名" class="headerlink" title="版本库内文件的删除和重命名"></a>版本库内文件的删除和重命名</h3><p>文件删除</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 表示你想要删除这个文件的意图并暂存这个变更</span>
$ <span class="token function">git</span> <span class="token function">rm</span> poem.html
<span class="token comment" spellcheck="true"># 在版本库里实现这个变更</span>
$ <span class="token function">git</span> commit -m <span class="token string">"Remove a poem"</span></code></pre>
<p>文件重命名</p>
<ul>
<li>方式一</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">mv</span> foo.html bar.html <span class="token comment" spellcheck="true"># 防止git命令会把foo.html从文件系统中永久删除</span>
$ <span class="token function">git</span> <span class="token function">rm</span> foo.html
$ <span class="token function">git</span> add bar.html</code></pre>
<ul>
<li>方式二</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">mv</span> foo.html bar.html</code></pre>
<h3 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout 3aadece1f41abc
注意：正在切换到 <span class="token string">'3aadece1f41abc'</span>。

您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换
回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。

如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令
中添加参数 -c 来实现（现在或稍后）。例如：

  <span class="token function">git</span> switch -c <span class="token operator">&lt;</span>新分支名<span class="token operator">></span>

或者撤销此操作：

  <span class="token function">git</span> switch -

通过将配置变量 advice.detachedHead 设置为 <span class="token boolean">false</span> 来关闭此建议

HEAD 目前位于 3aadece Create README.md

<span class="token comment" spellcheck="true"># 做一些更改...</span>

$ <span class="token function">git</span> checkout master
警告：您正丢下 1 个提交，未和任何分支关联：

  821e0a5 Update readme.md

如果您想要通过创建新分支保存它，这可能是一个好时候。
如下操作：

 <span class="token function">git</span> branch <span class="token operator">&lt;</span>新分支名<span class="token operator">></span> 821e0a5

切换到分支 <span class="token string">'master'</span>
您的分支领先 <span class="token string">'origin/master'</span> 共 2 个提交。
$ <span class="token function">git</span> branch hot-fix 821e0a5 <span class="token comment" spellcheck="true"># 新建一个分支关联刚刚丢失的提交</span></code></pre>
<h3 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> log --all
commit 821e0a5873ee5800d1bb8661da3ca05955693f2f <span class="token punctuation">(</span>hot-fix<span class="token punctuation">)</span>
Author: xiu <span class="token operator">&lt;</span>xiu@163.com<span class="token operator">></span>
Date:   Sat Sep 26 10:17:27 2020 +0800

    Update readme.md

commit 1de4a338cb7f3753d94729fcf247534e97dd860c <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>
Author: xiu <span class="token operator">&lt;</span>xiu@163.com<span class="token operator">></span>
Date:   Mon Sep 21 22:47:25 2020 +0800

    add <span class="token function">git</span> tree

commit 570d12a33be783aeb557d44c17f66ac17cec10d7
Author: xiu <span class="token operator">&lt;</span>xiu@163.com<span class="token operator">></span>
Date:   Mon Sep 21 21:59:40 2020 +0800

    绝对是借口

commit 3aadece1f41abceaca380ff25d9872da112644e4 <span class="token punctuation">(</span>origin/master, origin/HEAD, 0a<span class="token punctuation">)</span>
Author: AsiaMa <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span>
Date:   Fri Mar 9 20:37:22 2018 +0800

    Create README.md

commit 42acb0b8f4d5f207f248e75bc6553bb3d51a37d3
Author: PEP\mayz <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span>
Date:   Fri Mar 9 20:33:17 2018 +0800
$ <span class="token function">git</span> <span class="token function">diff</span> 821e0a5873e 1de4a338cb7
$ <span class="token function">git</span> <span class="token function">diff</span> HEAD HEAD^ <span class="token comment" spellcheck="true">#(与父提交匹配，等价于 git diff HEAD HEAD~1)</span>
$ <span class="token function">git</span> <span class="token function">diff</span> HEAD HEAD^^ <span class="token comment" spellcheck="true">#(等价于git diff HEAD HEAD~2)</span></code></pre>
<h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 暂存区已经修改的添加进去</span>
$ <span class="token function">git</span> add -u
<span class="token comment" spellcheck="true"># 暂存区的修改全部抹除掉</span>
$ <span class="token function">git</span> reset --hard
<span class="token comment" spellcheck="true"># 根据commitId检索分支</span>
$ <span class="token function">git</span> checkout -b fix_readme dc8aff7<span class="token punctuation">(</span>也可以基于分支, 如master、developer或feature/add-spring-security<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 切换到master分支</span>
$ <span class="token function">git</span> checkout master
<span class="token comment" spellcheck="true"># 显示所有分支</span>
$ <span class="token function">git</span> branch -av
<span class="token comment" spellcheck="true"># 显示所有分支的提交信息</span>
$ <span class="token function">git</span> log --all
<span class="token comment" spellcheck="true"># 图像化的方式展示提交信息</span>
$ <span class="token function">git</span> log --all --graph
<span class="token comment" spellcheck="true"># 以浏览器的方式打开git帮助文档</span>
$ <span class="token function">git</span> <span class="token function">help</span> --web log
<span class="token comment" spellcheck="true"># 查看帮助命令</span>
$ <span class="token function">git</span> <span class="token function">help</span> --all</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git目录</title>
    <url>/posts/9d17.html</url>
    <content><![CDATA[<h3 id="git目录"><a href="#git目录" class="headerlink" title="git目录"></a>git目录</h3><p><img src="https://s1.ax1x.com/2020/09/20/w70pxe.md.png" alt="Git目录"></p>
<p>head：显示当前所在分支</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> .git/HEAD
ref: refs/heads/master</code></pre>
<p>config: 本地的配置信息</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> .git/config
<span class="token punctuation">[</span>core<span class="token punctuation">]</span>
    repositoryformatversion <span class="token operator">=</span> 0
    filemode <span class="token operator">=</span> <span class="token boolean">true</span>
    bare <span class="token operator">=</span> <span class="token boolean">false</span>
    logallrefupdates <span class="token operator">=</span> <span class="token boolean">true</span>
    ignorecase <span class="token operator">=</span> <span class="token boolean">true</span>
    precomposeunicode <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">[</span>remote <span class="token string">"origin"</span><span class="token punctuation">]</span>
    url <span class="token operator">=</span> git@github.com:AsiaMa/xunfeiasia.git
    fetch <span class="token operator">=</span> +refs/heads/*:refs/remotes/origin/*
<span class="token punctuation">[</span>branch <span class="token string">"master"</span><span class="token punctuation">]</span>
    remote <span class="token operator">=</span> origin
    merge <span class="token operator">=</span> refs/heads/master
<span class="token punctuation">[</span>user<span class="token punctuation">]</span>
    name <span class="token operator">=</span> xiu
    email <span class="token operator">=</span> xiu@163.com</code></pre>
<p>refs: 里面有heads、remotes、tags三个文件夹</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> refs
$ ll
drwxr-xr-x  5 asiama  staff   160B  9 21 21:59 heads
drwxr-xr-x  3 asiama  staff    96B  9 20 20:26 remotes
drwxr-xr-x  2 asiama  staff    64B  9 20 20:26 tags
$ <span class="token function">cd</span> heads
$ ll
-rw-r--r--  1 asiama  staff    41B  9 20 20:26 master
-rw-r--r--  1 asiama  staff    41B  9 20 22:18 temp
$ <span class="token function">cat</span> master
3aadece1f41abceaca380ff25d9872da112644e4 <span class="token comment" spellcheck="true">#master分支最新提交</span>
$ <span class="token function">git</span> cat-file -t 3aadece1f41abceaca380ff25d9872da112644e4
commit
$ <span class="token function">cat</span> temp
dc8aff7c2cce1c3956113e701f54f43585a4e730 <span class="token comment" spellcheck="true">#temp分支最新提交</span>
$ <span class="token function">git</span> cat-file -t dc8aff7c2cce1c3956113e701f54f43585a4e730
commit</code></pre>
<p>objects: 核心文件夹</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> objects
$ ll
drwxr-xr-x  3 asiama  staff    96B  9 21 21:59 57
drwxr-xr-x  3 asiama  staff    96B  9 21 21:59 9d
drwxr-xr-x  3 asiama  staff    96B  9 21 21:57 b9
drwxr-xr-x  2 asiama  staff    64B  9 20 20:26 info
drwxr-xr-x  4 asiama  staff   128B  9 20 20:26 pack <span class="token comment" spellcheck="true"># 松散的文件比较多时，会进行打包放在这里面</span>
$ <span class="token function">cd</span> 57
0d12a33be783aeb557d44c17f66ac17cec10d7
<span class="token comment" spellcheck="true"># 需要前面拼接57</span>
$ <span class="token function">git</span> cat-file -t 570d12a33be783aeb557d44c17f66ac17cec10d7
commit
<span class="token comment" spellcheck="true"># 再看b9</span>
$ <span class="token function">cd</span> <span class="token punctuation">..</span>
$ <span class="token function">ls</span> b9/
67cf8fdb60314c33f2bceacd8ff1c4567f5b53
<span class="token comment" spellcheck="true"># 需要前面拼接b9</span>
$ <span class="token function">git</span> cat-file -t b967cf8fdb60314c33f2bceacd8ff1c4567f5b53
blob
$ <span class="token function">git</span> cat-file -p b967cf8fdb60314c33f2bceacd8ff1c4567f5b53
<span class="token comment" spellcheck="true"># 提交的文件里的内容</span>
ifjksjdfkfldjslfj
费德勒快速反击撒了接口
的快感和附近的恐慌感
ijdk
$ <span class="token function">ls</span> 9d/
a73a42ec544fe149927f595a4fec01ea3f5018
<span class="token comment" spellcheck="true"># 需要前面拼接9d</span>
$ <span class="token function">git</span> cat-file -t 9da73a42ec544fe149927f595a4fec01ea3f5018
tree
$ <span class="token function">git</span> cat-file -p 9da73a42ec544fe149927f595a4fec01ea3f5018
100644 blob 39fb081a42a86ccf8f9cf99dbccc8bdf7c828bce    .gitignore
040000 tree b0feff2525390e998fe1c6fa596956d0b1cc3fb0    .idea
100644 blob 72b6f3f4f7b1a4900057c2776a0dac63171ab9ff    README.md
040000 tree b73d8756304943ab811652d55582c54ffeb4b494    app
100644 blob 31fb06fc06923bbe3d0abf746498eb32069f778d    build.gradle
100644 blob aac7c9b4614ccfde6c721f24994cf30885a791d0    gradle.properties
040000 tree f76200a0891f6681e508b4af256edd7db7e0a929    gradle
100644 blob 9d82f78915133e1c35a6ea51252590fb38efac2f    gradlew
100644 blob 8a0b282aa6885fb573c106b3551f7275c5f17e8e    gradlew.bat
040000 tree 460455f25404eb4775c79dbba28fb5c1a870173b    mylibrary
100644 blob 9c982a3ebd0288b2ed9bff0c1da11828cb396b28    settings.gradle
100644 blob b967cf8fdb60314c33f2bceacd8ff1c4567f5b53    <span class="token function">test</span></code></pre>
<h3 id="Git对象类型-objects"><a href="#Git对象类型-objects" class="headerlink" title="Git对象类型(objects)"></a>Git对象类型(objects)</h3><p>对象库是Git版本库实现的心脏。它包含你的原始数据文件和所有日志信息、作者信息、日期，以及其它用来重建项目任意版本或分支的信息。</p>
<p>Git放在对象库里的对象只有4种类型：块（blob）、目录树（tree）、提交（commit）和标签（tag）。这4种原子对象构成Git高层数据结构的基础。</p>
<h4 id="块（blob）"><a href="#块（blob）" class="headerlink" title="块（blob）"></a>块（blob）</h4><p>文件的每一个版本表示为一个块（blob）。blob是“二进制大对象”（binary  large  object）的缩写，是计算机领域的常用术语，用来指代某些可以包含任意数据的变量或文件，同时其内部结构会被程序忽略。一个blob被视为一个黑盒。一个blob保存一个文件的数据，但不包含任何关于这个文件的元数据，甚至连文件名也没有「只要文件内容相同，在git眼里就是同一个blob，只有一份」。</p>
<h4 id="目录树（tree）"><a href="#目录树（tree）" class="headerlink" title="目录树（tree）"></a>目录树（tree）</h4><p>一个目录树（tree）对象代表一层目录信息。它记录blob标识符、路径名和在一个目录里所有文件的一些元数据。它也可以递归引用其他目录树或子树对象，从而建立一个包含文件和子目录的完整层次结构。</p>
<h4 id="提交（commit）"><a href="#提交（commit）" class="headerlink" title="提交（commit）"></a>提交（commit）</h4><p>一个提交（commit）对象保存版本库中每一次变化的元数据，包括作者、提交者、提交日期和日志消息。每一个提交对象指向一个目录树对象，这个目录树对象在一张完整的快照中捕获提交时版本库的状态。最初的提交或者根提交（root commit）是没有父提交的。大多数提交都有一个父提交。</p>
<h4 id="标签（tag）"><a href="#标签（tag）" class="headerlink" title="标签（tag）"></a>标签（tag）</h4><p>一个标签对象分配一个任意的且人类可读的名字给一个特定对象，通常是一个提交对象。虽然9da581d910c9c4ac93557ca4859e767f5caf5169指的是一个确切且定义好的提交，但是一个更熟悉的标签名（如Ver-1.0-Alpha）可能会更有意义！</p>
<p>随着时间的推移，所有信息在对象库中会变化和增长，项目的编辑、添加和删除都会被跟踪和建模。为了有效地利用磁盘空间和网络带宽，Git把对象压缩并存储在打包文件（packfile）里，这些文件也在对象库里。</p>
<p><img src="https://s1.ax1x.com/2020/09/22/wXAqaj.md.png" alt="对象之间的关系"></p>
<h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h3><p>索引是一个临时的、动态的二进制文件，它描述整个版本库的目录结构。更具体地说，索引捕获项目在某个时刻的整体结构的一个版本。项目的状态可以用一个提交和一棵目录树表示，它可以来自项目历史中的任意时刻，或者它可以是你正在开发的未来状态。</p>
<p>Git的关键特色之一就是它允许你用有条理的、定义好的步骤来改变索引的内容。索引使得开发的推进与提交的变更之间能够分离开来。</p>
<p>下面是它的工作原理。作为开发人员，你通过执行Git命令在索引中暂存（stage）变更。变更通常是添加、删除或者编辑某个文件或某些文件。索引会记录和保存那些变更，保障它们的安全直到你准备好提交了。还可以删除或替换索引中的变更。因此，索引支持一个由你主导的从复杂的版本库状态到一个可推测的更好状态的逐步过渡。</p>
<h3 id="可寻址内容名称"><a href="#可寻址内容名称" class="headerlink" title="可寻址内容名称"></a>可寻址内容名称</h3><p>Git对象库被组织及实现成一个内容寻址的存储系统。具体而言，对象库中的每个对象都有一个唯一的名称，这个名称是向对象的内容应用SHA1得到的SHA1散列值。因为一个对象的完整内容决定了这个散列值，并且认为这个散列值能有效并唯一地对应特定的内容，所以SHA1散列值用来做对象数据库中对象的名字和索引是完全充分的。文件的任何微小变化都会导致SHA1散列值的改变，使得文件的新版本被单独编入索引。</p>
<p>SHA1的值是一个160位的数，通常表示为一个40位的十六进制数，比如，9da581d910c9c4ac93557ca4859e767f5caf5169。有时候，在显示期间，SHA1值被简化成一个较小的、唯一的前缀。Git用户所说的SHA1、散列码和对象ID都是指同一个东西。</p>
<blockquote>
<p><strong>全局唯一标识符</strong></p>
<p>SHA散列计算的一个重要特性是不管内容在哪里，它对同样的内容始终产生同样的ID。换言之，在不同目录里甚至不同机器中的相同文件内容产生的SHA1哈希ID是完全相同的。因此，文件的SHA1散列ID是一种有效的全局唯一标识符。</p>
<p>这里有一个强大的推论，在互联网上，文件或者任意大小的blob都可以通过仅比较它们的SHA1标识符来判断是否相同。</p>
</blockquote>
<h3 id="Git追踪内容"><a href="#Git追踪内容" class="headerlink" title="Git追踪内容"></a>Git追踪内容</h3><p>Git同时还是一个内容追踪系统（content tracking system）。这种区别尽管很微小，但是指导了Git的很多设计，并且也许这就是处理内部数据操作相对容易的关键原因。</p>
<p>Git的内容追踪主要表现为两种关键的方式，这两种方式与大多数其他版本控制系统都不一样。首先，Git的对象库基于其对象内容的散列计算的值，而不是基于用户原始文件布局的文件名或目录名设置。因此，当Git放置一个文件到对象库中的时候，它基于数据的散列值而不是文件名。事实上，Git并不追踪那些与文件次相关的文件名或者目录名。再次强调，Git追踪的是内容而不是文件。如果两个文件的内容完全一样，无论是否在相同的目录，Git在对象库里只保存一份blob形式的内容副本。Git仅根据文件内容来计算每一个文件的散列码，如果文件有相同的SHA1值，它们的内容就是相同的，然后将这个blob对象放到对象库里，并以SHA1值作为索引。项目中的这两个文件，不管它们在用户的目录结构中处于什么位置，都使用那个相同的对象指代其内容。</p>
<p>如果这些文件中的一个发生了变化，Git会为它计算一个新的SHA1值，识别出它现在是一个不同的blob对象，然后把这个新的blob加到对象库里。原来的blob在对象库里保持不变，为没有变化的文件所使用。</p>
<p>其次，当文件从一个版本变到下一个版本的时候，Git的内部数据库有效地存储每个文件的每个版本，而不是它们的差异。因为Git使用一个文件的全部内容的散列值作为文件名，所以它必须对每个文件的完整副本进行操作。Git不能将工作或者对象库条目建立在文件内容的一部分或者文件的两个版本之间的差异上。</p>
<p>Git用不同散列值的blob之间的区别来计算这个历史，而不是直接存储一个文件名和一系列差异。这似乎有些奇怪，但这个特性让Git在执行某些任务的时候非常轻松。</p>
<h3 id="路径名与内容"><a href="#路径名与内容" class="headerlink" title="路径名与内容"></a>路径名与内容</h3><p>跟很多其他VCS一样，Git需要维护一个明确的文件列表来组成版本库的内容。然而，这个需求并不需要Git的列表基于文件名。实际上，Git把文件名视为一段区别于文件内容的数据。这样，Git就把索引从传统数据库的数据中分离出来了。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>索机制</th>
<th>数据存储</th>
</tr>
</thead>
<tbody><tr>
<td>传统数据库</td>
<td>索引顺序存取方法（ISAM）</td>
<td>数据记录</td>
</tr>
<tr>
<td>UNIX文件系统</td>
<td>目录（/path/to/file）</td>
<td>数据块</td>
</tr>
<tr>
<td>Git</td>
<td>.git/objects/hash、树对象内容</td>
<td>bolb对象、树对象</td>
</tr>
</tbody></table>
<p>文件名和目录名来自底层的文件系统，但是Git并不真正关心这些名字。Git仅仅记录每个路径名，并且确保能通过它的内容精确地重建文件和目录，这些是由散列值来索引的。</p>
<p>Git的物理数据布局并不模仿用户的文件目录结构。相反，它有一个完全不同的结构却可以重建用户的原始布局。在考虑其自身的内部操作和存储方面，Git的内部结构是一种更高效的数据结构</p>
<p>当Git需要创建一个工作目录时，它对文件系统说：“嘿！我这有这样大的一个blob数据，应该放在路径名为path/to/directory/file的地方。你能理解吗？”文件系统回复说：“啊，是啊，我认出那个字符串是一组子目录名，并且我知道把你的blob数据放在哪里！谢谢！</p>
<h3 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h3><p>直接存储每个文件每个版本的完整内容是否太低效率了？即使它是压缩的，把相同文件的不同版本的全部内容都存储的效率是否太低了？如果你只添加一行到文件里，Git是不是要存储两个版本的全部内容？幸运的是，答案是“不是，不完全是！</p>
<p>相反，Git使用了一种叫做打包文件（pack file）的更有效的存储机制。要创建一个打包文件，Git 首先定位内容非常相似的全部文件，然后为它们之一存储整个内容。之后计算相似文件之间的差异并且只存储差异。例如，如果你只是更改或者添加文件中的一行，Git 可能会存储新版本的全部内容，然后记录那一行更改作为差异，并存储在包里。</p>
<p>存储一个文件的整个版本并存储用来构造其他版本的相似文件的差异并不是一个新伎俩。这个机制已经被其他VCS（如RCS）用了好几十年了，它们的方法本质上是相同的。</p>
<p>然而，Git文件打包得非常巧妙。因为Git是由内容驱动的，所以它并不真正关心它计算出来的两个文件之间的差异是否属于同一个文件的两个版本。这就是说，Git可以在版本库里的任何地方取出两个文件并计算差异，只要它认为它们足够相似来产生良好的数据压缩。因此，Git有一套相当复杂的算法来定位和匹配版本库中潜在的全局候选差异。此外，Git可以构造一系列差异文件，从一个文件的一个版本到第二个，第三个，等等。</p>
<p>Git还维护打包文件表示中每个完整文件（包括完整内容的文件和通过差异重建出来的文件）的原始blob的SHA1值。这给定位包内对象的索引机制提供了基础。打包文件跟对象库中其他对象存储在一起。它们也用于网络中版本库的高效数据传输。</p>
<h3 id="对象库图示"><a href="#对象库图示" class="headerlink" title="对象库图示"></a>对象库图示</h3><p>让我们看看Git的对象之间是如何协作来形成完整系统的。</p>
<p>blob对象是数据结构的“底端”；它什么也不引用而且只被树对象引用。在接下来的图里，每个blob由一个矩形表示。</p>
<p>树对象指向若干blob对象，也可能指向其他树对象。许多不同的提交对象可能指向任何给定的树对象。每个树对象由一个三角形表示。</p>
<p>一个圆圈表示一个提交对象。一个提交对象指向一个特定的树对象，并且这个树对象是由提交对象引入版本库的。</p>
<p>每个标签由一个平行四边形表示。每个标签可以指向最多一个提交对象。</p>
<p>分支不是一个基本的Git对象，但是它在命名提交对象的时候起到了至关重要的作用。把每个分支画成一个圆角矩形。</p>
<p>下面这张图展示了所有部分如何协作。显示了一个版本库在添加了两个文件的初始提交后的状态。两个文件都在顶级目录中。同时它们的master分支和一个叫V1.0的标签都指向ID为1492的提交对象。</p>
<p><img src="https://s1.ax1x.com/2020/09/23/wxtbUH.md.png" alt="对象图示"></p>
<p>现在，让我们使事情变得复杂一点。保留原来的两个文件不变，添加一个包含一个文件的新子目录。对象库就如下所示：</p>
<p><img src="https://s1.ax1x.com/2020/09/23/wxNnqU.md.png" alt="xxx"></p>
<p>就像前一张图里，新提交对象添加了一个关联的树对象来表示目录和文件结构的总状态。在这里，它是ID为cafed00d的树对象。</p>
<p>因为顶级目录被添加的新子目录改变了，顶级树对象的内容也跟着改变了，所以Git引进了一个新的树对象：cafed00d。</p>
<p>然而，blob对象dead23和feeb1e在从第一次到第二次提交的时候没有发生变化。Git意识到ID没有变化，所以可以被新的cafed00d树对象直接引用和共享。</p>
<p>请注意提交对象之间箭头的方向。父提交在时间上来得更早。因此，在Git的实现里，每个提交对象指回它的一个或多个父提交。版本库的状态通常画成反方向：数据流从父提交流向子提交。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git之前需要做的最小配置</title>
    <url>/posts/5174.html</url>
    <content><![CDATA[<h3 id="配置user-name-和-user-email"><a href="#配置user-name-和-user-email" class="headerlink" title="配置user.name 和 user.email"></a>配置user.name 和 user.email</h3><p>全局配置「对当前用户所有仓库有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --global user.email <span class="token string">"your_email"</span></code></pre>
<p>缺省等同于local「只对某个仓库有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --local user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --local user.email <span class="token string">"your_email"</span></code></pre>
<p>系统配置「对系统所有登录的用户有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --system user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --system user.email <span class="token string">"your_email"</span></code></pre>
<h3 id="显示config的配置"><a href="#显示config的配置" class="headerlink" title="显示config的配置"></a>显示config的配置</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --list --local
$ <span class="token function">git</span> config --list --global
$ <span class="token function">git</span> config --list --system</code></pre>
<h3 id="查看某一个属性"><a href="#查看某一个属性" class="headerlink" title="查看某一个属性"></a>查看某一个属性</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name</code></pre>
<h3 id="移除设置"><a href="#移除设置" class="headerlink" title="移除设置"></a>移除设置</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --unset --global user.email</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/3eeb.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>数一数tree的个数</title>
    <url>/posts/4069.html</url>
    <content><![CDATA[<p>新建的Git仓库，有且仅有1个commit，仅仅包含/doc/readme，请问内含多少个tree，多少个blob?</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> init watch-git-objects
已初始化空的 Git 仓库于 /Users/asiama/IdeaProjects/watch-git-objects/.git/
$ <span class="token function">cd</span> watch-git-objects
$ <span class="token function">mkdir</span> doc
$ <span class="token function">git</span> status
位于分支 master

尚无提交

无文件要提交（创建/拷贝文件并使用 <span class="token string">"git add"</span> 建立跟踪）
$ <span class="token function">cd</span> doc
$ <span class="token keyword">echo</span> <span class="token string">"hello,world"</span> <span class="token operator">></span> readme
$ <span class="token function">cd</span> <span class="token punctuation">..</span>
位于分支 master

尚无提交

未跟踪的文件:
  （使用 <span class="token string">"git add &lt;文件>..."</span> 以包含要提交的内容）
    doc/

提交为空，但是存在尚未跟踪的文件（使用 <span class="token string">"git add"</span> 建立跟踪）
$ <span class="token function">find</span> .git/objects -type f <span class="token comment" spellcheck="true"># 空的 没有东西</span>
$ <span class="token function">git</span> add doc
$ <span class="token function">git</span> status
位于分支 master

尚无提交

要提交的变更：
  （使用 <span class="token string">"git rm --cached &lt;文件>..."</span> 以取消暂存）
    新文件：   doc/readme
$ <span class="token function">find</span> .git/objects -type f
.git/objects/2d/832d9044c698081e59c322d5a2a459da546469
$ <span class="token function">git</span> cat-file -t 2d832d9044c698081e59c322d5a2a459da546469
blob
$ <span class="token function">git</span> cat-file -p 2d832d9044c698081e59c322d5a2a459da546469
hello,world
$ <span class="token function">git</span> commit -m <span class="token string">"Add readme"</span>
<span class="token punctuation">[</span>master（根提交） 8fe36c1<span class="token punctuation">]</span> Add readme
 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>
 create mode 100644 doc/readme</code></pre>
<p>猜一猜我们的.git/objects到底有多少个文件创建出来，有多少个tree，多少个blob。</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> .git/objects -type f
.git/objects/8f/e36c1c741d52526c2d3d228a6f6cd25de88849
.git/objects/08/3e18d286d8d2a9eda8c62d9d98935dcc07ca4c
.git/objects/ba/8711bd7540faa22e4e76a1cf5c78501fa4e162
.git/objects/2d/832d9044c698081e59c322d5a2a459da546469
$ <span class="token function">git</span> cat-file -t 8fe36c1c741d52526c2d3d228a6f6cd25de88849
commit
$ <span class="token function">git</span> cat-file -p 8fe36c1c741d52526c2d3d228a6f6cd25de88849
tree 083e18d286d8d2a9eda8c62d9d98935dcc07ca4c
author asiama <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span> 1601082923 +0800
committer asiama <span class="token operator">&lt;</span>a976304624@outlook.com<span class="token operator">></span> 1601082923 +0800

Add readme
$ <span class="token function">git</span> cat-file -t 083e18d286d8d2a9eda8c62d9d98935dcc07ca4c
tree
$ <span class="token function">git</span> cat-file -p 083e18d286d8d2a9eda8c62d9d98935dcc07ca4c
040000 tree ba8711bd7540faa22e4e76a1cf5c78501fa4e162    doc
$ <span class="token function">git</span> cat-file -t ba8711bd7540faa22e4e76a1cf5c78501fa4e162
tree
$ <span class="token function">git</span> cat-file -p ba8711bd7540faa22e4e76a1cf5c78501fa4e162
100644 blob 2d832d9044c698081e59c322d5a2a459da546469    readme
$ <span class="token function">git</span> cat-file -t 2d832d9044c698081e59c322d5a2a459da546469
blob
$ <span class="token function">git</span> cat-file -p 2d832d9044c698081e59c322d5a2a459da546469
hello,world</code></pre>
<p><img src="https://s1.ax1x.com/2020/09/26/0PADN6.md.png" alt="ss"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第一天</title>
    <url>/posts/56b.html</url>
    <content><![CDATA[<h2 id="五种基本句型"><a href="#五种基本句型" class="headerlink" title="五种基本句型"></a>五种基本句型</h2><h3 id="主-连系动词-表语"><a href="#主-连系动词-表语" class="headerlink" title="主+连系动词+表语"></a>主+连系动词+表语</h3><ul>
<li>I am cold.</li>
<li>The food is delicious.</li>
<li>We are friends.</li>
<li>Make is a nice person.</li>
</ul>
<h3 id="主-谓"><a href="#主-谓" class="headerlink" title="主+谓"></a>主+谓</h3><ul>
<li>He died.</li>
<li>He smiled.</li>
<li>He cried.</li>
</ul>
<h3 id="主-谓-宾"><a href="#主-谓-宾" class="headerlink" title="主+谓+宾"></a>主+谓+宾</h3><ul>
<li>I visited him.</li>
<li>He killed a bear.</li>
<li>We love her.</li>
</ul>
<h3 id="主-谓-双宾"><a href="#主-谓-双宾" class="headerlink" title="主+谓+双宾"></a>主+谓+双宾</h3><ul>
<li>My father bought me a car.</li>
<li>Mary give me an apple.</li>
<li>He wrote her a letter.</li>
</ul>
<h3 id="主-谓-宾-宾语补语"><a href="#主-谓-宾-宾语补语" class="headerlink" title="主+谓+宾+宾语补语"></a>主+谓+宾+宾语补语</h3><ul>
<li>They named him Jamie.</li>
<li>She makes me laugh.</li>
<li>I painted the wall white.</li>
<li>She pushed the door open.</li>
<li>He asked me to call Tom.</li>
<li>I wish you to be happy.</li>
</ul>
<h2 id="人称代词"><a href="#人称代词" class="headerlink" title="人称代词"></a>人称代词</h2><h3 id="主格"><a href="#主格" class="headerlink" title="主格"></a>主格</h3><table>
<thead>
<tr>
<th></th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody><tr>
<td>第一人称</td>
<td>i</td>
<td>we</td>
</tr>
<tr>
<td>第二人称</td>
<td>you</td>
<td>you</td>
</tr>
<tr>
<td>第三人称</td>
<td>he/she/it</td>
<td>they</td>
</tr>
</tbody></table>
<h3 id="宾格"><a href="#宾格" class="headerlink" title="宾格"></a>宾格</h3><table>
<thead>
<tr>
<th></th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody><tr>
<td>第一人称</td>
<td>me</td>
<td>us</td>
</tr>
<tr>
<td>第二人称</td>
<td>you</td>
<td>you</td>
</tr>
<tr>
<td>第三人称</td>
<td>him/her/it</td>
<td>them</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
</search>
