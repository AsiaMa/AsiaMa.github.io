<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bean 延迟查找</title>
    <url>/posts/cdfc.html</url>
    <content><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectProviderDemo</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// @Configuration 是非必须注解</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册配置类</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>ObjectProviderDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找集合对象</span>
    <span class="token function">lookupByObjectProvider</span><span class="token punctuation">(</span>annotationConfigApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lookupIfAvailable</span><span class="token punctuation">(</span>annotationConfigApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lookupByStreamOps</span><span class="token punctuation">(</span>annotationConfigApplicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lookupByObjectProvider</span><span class="token punctuation">(</span>
      AnnotationConfigApplicationContext annotationConfigApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectProvider<span class="token operator">&lt;</span>String<span class="token operator">></span> objectProvider <span class="token operator">=</span>
        annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanProvider</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objectProvider<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lookupIfAvailable</span><span class="token punctuation">(</span>
      AnnotationConfigApplicationContext annotationConfigApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectProvider<span class="token operator">&lt;</span>User<span class="token operator">></span> userObjectProvider <span class="token operator">=</span>
        annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanProvider</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    User user <span class="token operator">=</span> userObjectProvider<span class="token punctuation">.</span><span class="token function">getIfAvailable</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"hah"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user: "</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lookupByStreamOps</span><span class="token punctuation">(</span>
      AnnotationConfigApplicationContext annotationConfigApplicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ObjectProvider<span class="token operator">&lt;</span>String<span class="token operator">></span> objectProvider <span class="token operator">=</span>
        annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBeanProvider</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    objectProvider<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> String <span class="token function">helloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 方法名就是 Bean 名称 = "helloWorld</span>
    <span class="token keyword">return</span> <span class="token string">"hello, world!"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token annotation punctuation">@Primary</span>
  <span class="token keyword">public</span> String <span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    Message
    user: User{id=1, name='hah'}
    hello, world!
    Message */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的初始化方式</title>
    <url>/posts/c3f8.html</url>
    <content><![CDATA[<h3 id="PostConstruct标注方法"><a href="#PostConstruct标注方法" class="headerlink" title="@PostConstruct标注方法"></a>@PostConstruct标注方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：@PostConstruct Employee 初始化中... */</span></code></pre>
<h3 id="自定义初始化方法"><a href="#自定义初始化方法" class="headerlink" title="自定义初始化方法"></a>自定义初始化方法</h3><ul>
<li>XML配置：&lt;bean init-method = “init” … /&gt;</li>
</ul>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initEmployee<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre>
<ul>
<li>Java注解：@Bean(initMethod = “init”)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中... */</span></code></pre>
<ul>
<li>Java API: AbstractBeanDefinition#setInitMethodName(String)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    AbstractBeanDefinition beanDefinition <span class="token operator">=</span>
        BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setInitMethodName</span><span class="token punctuation">(</span><span class="token string">"initEmployee"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>
        <span class="token string">"myEmployee"</span><span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中... */</span></code></pre>
<h3 id="实现InitialzingBean接口的afterPropertiesSet方法"><a href="#实现InitialzingBean接口的afterPropertiesSet方法" class="headerlink" title="实现InitialzingBean接口的afterPropertiesSet方法"></a>实现InitialzingBean接口的afterPropertiesSet方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...    */</span></code></pre>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>@PostConstruct ——&gt; InitialzingBean ——&gt; 自定义初始化方法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的不足</title>
    <url>/posts/26f4.html</url>
    <content><![CDATA[<h3 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h3><p>检查异常会在编译时强制执行try catch处理，同时还需要进行某种排序处理。检查异常是一个失败的实践，几乎所有的主要API提供者都返回可检查异常。Kotlin中摒弃了检查异常。</p>
<h3 id="基本类型和数组"><a href="#基本类型和数组" class="headerlink" title="基本类型和数组"></a>基本类型和数组</h3><p>Java的这个设计保留了字节码的底层细节，违反了“凡事皆为对象”的原则，如泛型无法包容基本类型就是一个例子。这也使得Java的类型系统显得不是那么地简单统一。比较好的方案是，源代码不用直接使用基本类型和数组，由编译器（或者JVM）来决定是否可以帮你对其优化，而Kotlin正是这么做的。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态方法经常会导致需要显式的定义接口，从而使得API更加复杂。一个更好的办法就是采用单例对象，单例对象在大多数情况下表现得与静态对象差不多，但是可以像一个对象被传递。Kotlin中提供了object单例对象。</p>
<h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>在Java中我们不得不写一堆防御代码来避免令人头疼的NPE。Kotlin中引入可空类型与安全调用符、Elvis操作符等特性来实现空安全。</p>
<h3 id="一堆getter-setter单调冗长的样板代码"><a href="#一堆getter-setter单调冗长的样板代码" class="headerlink" title="一堆getter/setter单调冗长的样板代码"></a>一堆getter/setter单调冗长的样板代码</h3><p>在Kotlin中，我们可以使用数据类：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> id<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre>
<h3 id="不容易传递函数"><a href="#不容易传递函数" class="headerlink" title="不容易传递函数"></a>不容易传递函数</h3><p>Java中没有一等函数类型，函数式（FP）编程只能通过使用接口类型以及多态特性“曲线”来实现。Java会将每一个算法（方法）都放入类中，这种限制会出现这样的“荒唐事”：我们只想实现一个函数算法，而这个时候必须还要给出一个类来放置这个方法；同样，如果在其它地方调用这个方法，必须通过创建该类来实现调用。在Kotlin中直接提供了一等函数（First-Class Function Type）类型，其跟普通类型一样，函数类型可以作为值来传递，也可以作为返回值。</p>
<blockquote>
<p>不可否认的是，C、C++和Java语言都是非常优秀的编程语言。但是事物总是不断发展变化的。就像C++语言是对C语言的继承与发展，Java语言是对C++语言的继承与改造，而Kotlin语言也是对Java语言的继承与变革。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin内联:noinline与crossinline</title>
    <url>/posts/11c5.html</url>
    <content><![CDATA[<p>在Kotlin中，内部Lambda是不允许中断外部函数执行的。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    test1<span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token label symbol">@test1</span>    <span class="token comment" spellcheck="true">//如果直接return（不带@test1）就会报错，内部Lambda是不允许中断外部函数执行的</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span>l<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
            hello 
            hello */</span></code></pre>
<p>inline的Lambda可以中断外部函数调用:</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    test1<span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span>l<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果：hello */</span></code></pre>
<p>crossinline不允许inline的Lambda中断外部函数执行。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    test1 <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token label symbol">@test1</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello1"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello2"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">crossinline</span> l<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果：
            hello
            hello2 */</span></code></pre>
<p>noinline拒绝内联。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> runnable <span class="token operator">=</span> Runnable <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runnable"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> test2 <span class="token operator">=</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> runnable<span class="token operator">::</span>run<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 如果函数返回值是一个lambda表达式的话，我需要对这个lambda表达式加上 noinline 关键字</span>
<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token function">test2</span><span class="token punctuation">(</span>l0<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">,</span> <span class="token keyword">noinline</span> l1<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token punctuation">{</span>
    l0<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    l1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> l1
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotin介绍</title>
    <url>/posts/5487.html</url>
    <content><![CDATA[<h3 id="Kotlin的主要特征"><a href="#Kotlin的主要特征" class="headerlink" title="Kotlin的主要特征"></a>Kotlin的主要特征</h3><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><p>Kotlin和Java一样是一种静态类型的编程语言。这意味着<code>所有表达式的类型在编译器已经确定了，而编译器就能验证对象是否包含了你想访问的方法或者字段</code>。</p>
<p>这与动态类型的编程语言形成了鲜明的对比，后者在JVM上的代表包括Grovvy和JRuby。这些语言<code>允许你定义可以存储任何数据类型的变量，或者返回任何数据类型的函数，并在运行时才解析方法和字段引用</code>。这会减少代码量并增加创建数据结构的灵活性。但它的缺点是，在编译期不能发现像名字拼写错误这样的问题，继而导致运行时的错误。</p>
<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>另一方面，与Java不同的是，<code>Kotin不需要你在源代码中显式地声明每个变量的类型。很多情况下，变量类型可以根据上下文来自动推断</code>，这样就可以省略类型声明。如</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token number">1</span></code></pre>
<p>在声明这个变量时，由于变量初始化整型值，Kotin自动判断出它的类型是Int。<code>编译器这种从上下文推断变量类型的能力称作类型推导</code>。</p>
<h4 id="扩展函数与扩展属性"><a href="#扩展函数与扩展属性" class="headerlink" title="扩展函数与扩展属性"></a>扩展函数与扩展属性</h4><p>扩展函数与扩展属性的“好玩”之处在于，可以在不修改原来类的条件下自定义函数和属性，是它们表现得就像是属于这个类一样。例如，我们给String类型扩展一个返回字符串首字母的firstChar()函数，代码如下：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//调用我们自定义的扩展函数</span>
    <span class="token keyword">val</span> firstChar <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token function">firstChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this first char <span class="token interpolation variable">$firstChar</span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> String<span class="token punctuation">.</span><span class="token function">firstChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="不可空类型与空安全"><a href="#不可空类型与空安全" class="headerlink" title="不可空类型与空安全"></a>不可空类型与空安全</h4><p>Kotlin中引入了不可空类型与可空类型来明确声明一个变量是否可能为null，同时在编译器通过类型是否匹配来检查空指针异常，大大降低了空指针异常出现的概率。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span>  <span class="token comment" spellcheck="true">//声明一个字符串，编译器会默认推断变量a的类型为不可空的String</span>
a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不可空类型不能赋值为null</span>
error<span class="token operator">:</span> Null can not be a value of a non<span class="token operator">-</span><span class="token keyword">null</span> type String

<span class="token keyword">var</span> b<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"abc"</span>
b<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">//可空类型不能直接调用方法，需要使用安全调用符?.或者断言调用!!.</span>
b<span class="token operator">?</span><span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">//使用安全调用符，null对象使用安全调用符访问length属性，直接返回null</span></code></pre>
<p>这个问号确实非常简洁易懂，同时能够时刻提醒我们：这个调用者有可能是null的。这个语言明显比Java8中引入的Optional&lt;String&gt;更加简单、直接。</p>
<h4 id="一等函数支持"><a href="#一等函数支持" class="headerlink" title="一等函数支持"></a>一等函数支持</h4><p>在Kotlin中函数是第一等类型：我们可以将函数像值一样传递，函数可以作为另一个函数的返回值。我们通常称之为“一等函数”支持。</p>
<p>下面是把一个函数作为参数传递给函数的Lambda表达式的例子：</p>
<pre class=" language-kotlin"><code class="language-kotlin"> <span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>
 <span class="token keyword">val</span> filterList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">}</span></code></pre>
<h3 id="Kotin设计哲学"><a href="#Kotin设计哲学" class="headerlink" title="Kotin设计哲学"></a>Kotin设计哲学</h3><h4 id="务实"><a href="#务实" class="headerlink" title="务实"></a>务实</h4><p>JetBrains内部和社区的开发者已经使用Kotlin的早起版本很多年，Kotlin能够帮助解决实际项目的问题。</p>
<h4 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h4><p>许多标准的Java样板代码，例如getter、setter以及将构造方法的参数赋值给字段的逻辑，在Kotlin中都是隐式的，并不会使你的源代码变得混乱。</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Kotlin设计了一个“归一化”的类型系统（一切类型皆是引用类型），纯天然地设置了一道空指针的屏障，使得Kotin比Java更加安全可靠。Kotlin有助与避免的另一种异常类型就是ClassCastException。当你把一个对象转换成一种类型，而没有事先检查它是否是正确的类型时，就会发生这个异常。Kotlin中的检查和转换被组合成了一次操作：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token keyword">is</span> String<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//不需要额外的转换就能直接引用属于这个类型的成员</span>
  <span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h4><p>Kotlin的优势是既有Java的完整生态（Kotlin完全无缝使用各类Java API框架库）,又有现代语言的高级特性（语法糖）。</p>
<h3 id="编程哲学"><a href="#编程哲学" class="headerlink" title="编程哲学"></a>编程哲学</h3><p>编程的真正问题在于，如何把人类脑子里对问题的解决方案“具化”到机器世界，而这个“具化”过程正是编程语言所要表达的东西。如何富有表现力并且安全简洁的表达，这是所有编程语言所要解决的问题。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin单例</title>
    <url>/posts/9fbb.html</url>
    <content><![CDATA[<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Singleton <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Singleton <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Holder<span class="token punctuation">.</span>instance
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">object</span> Holder <span class="token punctuation">{</span>
        <span class="token keyword">val</span> instance <span class="token operator">=</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础命令</title>
    <url>/posts/f6d7.html</url>
    <content><![CDATA[<p>在Windows和macOS的环境中不区分字符的大小写，但是在Linux环境中却区分大小写。也就是说，表tb1和表TB1在Windows和macOS环境中会作为相同的表名处理，但是在Linux环境中会作为不同的表名处理。</p>
<h3 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h3><pre class=" language-mysql"><code class="language-mysql">$ use db1;
# 或者
$ \u db1</code></pre>
<p>我们可以直接指定数据库启动MySQL监视器。</p>
<p>在这种情况下，可以像<code>mysql db1 -u root -proot</code> 这样，通过在命令提示符中指定数据库名来执行mysql命令。</p>
<p>数据库也有分开使用术语的情况，比如构成表的项目称为<code>字段</code>（field），构成记录的各项目的数据称为<code>列</code>。不过为了方便，可以统一使用“列”这一术语。</p>
<blockquote>
<p>在使用use选择数据库的状态下，也能够操作其它数据库中的表。这时可以像“数据库名.表名”这样把“数据库名”和“表名”用“.”连接起来。例如，当从其它数据库访问数据库db2中的表table的所有记录时，可以使用下面的命令。</p>
<pre class=" language-mysql"><code class="language-mysql">SELECT * FROM db2.table;</code></pre>
</blockquote>
<h3 id="指定字符编码创建表"><a href="#指定字符编码创建表" class="headerlink" title="指定字符编码创建表"></a>指定字符编码创建表</h3><p>在MySQL中输入字符到表中时，会因为各种原因出现字符乱码的情况。这时有一个方法可以解决这个问题，那就是指定字符编码创建表。</p>
<pre class=" language-mysql"><code class="language-mysql">CREATE TABLE tb1 (emp_id VARCHAR(10), name VARCHAR(10), age INT) CHARACTER=utf8</code></pre>
<h3 id="确认表的结构"><a href="#确认表的结构" class="headerlink" title="确认表的结构"></a>确认表的结构</h3><pre class=" language-mysql"><code class="language-mysql"># DESC 表名;
DESC db1;</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/two.png"></p>
<p>Null 表示“允许不输入任何值”，Default表示“如果什么值都不输入就用这个值”。Field表示列名，Type表示数据类型。</p>
<p>因为列name被设置成了VARCHAR(10)，所以我们无法输入多于10个字符的数据。但是在MySQL中，即使输入了多于指定字符数（这里是10个字符）的数据也不会报错，而是会忽略无法插入的字符（这里是指10个字符之后的数据），这一点需要注意。</p>
<blockquote>
<p>如果将SQL Modes设为STRICE_TRANS_TABLES时回报出Data to long for column ‘XXX’ at row XX的错误。</p>
</blockquote>
<h3 id="向表中插入多行记录"><a href="#向表中插入多行记录" class="headerlink" title="向表中插入多行记录"></a>向表中插入多行记录</h3><pre class=" language-mysql"><code class="language-mysql">INSERT INTO tb1 (emp_id, name, age) VALUES ('A101', '佐藤', 40), ('A102', '高桥', 28), ('A103', '中川', 20), ('A104', '渡边', 23), ('A105', '西泽', 35);</code></pre>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE tb1A SELECT * FROM tb1;</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL权限相关</title>
    <url>/posts/8cf.html</url>
    <content><![CDATA[<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class=" language-mysql"><code class="language-mysql">$ SET PASSWORD FOR root@localhost='A123456!'</code></pre>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre class=" language-mysql"><code class="language-mysql"># CREATE USER 新用户名 IDENTIFIED BY '密码'
$ CREATE USER asiama@localhost IDENTIFIED BY 'A123456!'</code></pre>
<h3 id="设置用户权限"><a href="#设置用户权限" class="headerlink" title="设置用户权限"></a>设置用户权限</h3><pre class=" language-mysql"><code class="language-mysql"># GRANT 赋予的权限 ON 数据库名.表名 TO 用户名
$ GRANT ALL ON db1.* TO asiama@localhost</code></pre>
<blockquote>
<p>用户名需要按照“用户名@主机名”的方式书写（如果不确定主机名，可以”用户名@%”来允许所有主机）。“赋予的权限”如果是所有的权限，就设置为“ALL”；如果仅允许SELECT和UPDATE,就设置为“SELECT, UPDATE”；如果是所有的数据库的所有表，就设置为“*.*”</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL编码设置</title>
    <url>/posts/17fc.html</url>
    <content><![CDATA[<h3 id="命令提示符的UTF-8设置"><a href="#命令提示符的UTF-8设置" class="headerlink" title="命令提示符的UTF-8设置"></a>命令提示符的UTF-8设置</h3><p>Windows终端默认使用字符编码GBK进行数据的输入和输出，而数据库则使用UTF-8存储数据。其实我们也可以把命令终端的字符编码设置成UTF-8。我们需要按照下面的格式在命令终端执行<code>chcp</code></p>
<pre class=" language-shell"><code class="language-shell">$ chcp 65001</code></pre>
<p>chcp用于修改命令终端的字符编码，<code>65001代表UTF-8</code>。</p>
<h3 id="确认MySQL中字符编码的设置情况"><a href="#确认MySQL中字符编码的设置情况" class="headerlink" title="确认MySQL中字符编码的设置情况"></a>确认MySQL中字符编码的设置情况</h3><p>启动MySQL监视器，输入status。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/one.png"></p>
<p>1代表服务器端的字符编码设置，2代表客户端的字符编码设置。</p>
<p>指定字符编码启动MySQL监视器</p>
<pre class=" language-sh"><code class="language-sh">$ mysql -uroot -proot --default-character-set=gbk</code></pre>
<p>另外字符编码设置情况还可以通过下面的命令查看</p>
<pre class=" language-mysql"><code class="language-mysql">SHOW VARIABLES LIKE 'char%'</code></pre>
<p>按下<code>F7键后，历史命令</code>会全部显示出来。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis小热身</title>
    <url>/posts/4f87.html</url>
    <content><![CDATA[<h3 id="redis-server-配置"><a href="#redis-server-配置" class="headerlink" title="redis-server 配置"></a>redis-server 配置</h3><p>Redis 支持通过配置文件来设置启动参数，如：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-server /path/to/redis.conf</code></pre>
<p>通过启动参数传递同名的配置选项会覆盖配置文件中相应的参数，就像这样：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-server /path/to/redis.conf --loglevel warning</code></pre>
<p>Redis 运行时通过 CONFIG SET 命令在不重新启动 Redis 的情况下动态修改部分 Redid配置：</p>
<pre class=" language-bash"><code class="language-bash">$ CONFIG SET loglevel warning
OK</code></pre>
<p>并不是所有配置都可以使用Config SET 命令修改。同样在运行的时候也可以使用 CONFIG GET 命令获得 Redis 当前的配置情况：</p>
<pre class=" language-bash"><code class="language-bash">$ CONFIG GET loglevel
1<span class="token punctuation">)</span> <span class="token string">"loglevel"</span>
2<span class="token punctuation">)</span> <span class="token string">"notice"</span></code></pre>
<p>其中第一行字符串回复表示的是选项名，第二行既是选项值。</p>
<h3 id="redsic-cli-连接"><a href="#redsic-cli-连接" class="headerlink" title="redsic-cli 连接"></a>redsic-cli 连接</h3><p>通过 redis-cli 向 Redis 发送命令有两种方式，第一种方式是将命令作为 redis-cli 的参数执行，如：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli SHUTDOWN</code></pre>
<p>redis-cli 执行时会自动按照默认配置（服务器地址为 127.0.0.1，端口号为 6379）连接 Redis，通过 -h 和 -p 参数可以自定义地址和端口号，-a 参数后跟 redis 连接密码：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -h 127.0.0.1 -p 6379 -a password</code></pre>
<p>第二种方式是不附带参数运行 redis-cli，这样会进入交互模式，可以自由输入命令，例如：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli
127.0.0.1:6379<span class="token operator">></span> PING
PONG</code></pre>
<p>这种方式在输入多条命令时比较方便。</p>
<h3 id="简单的几个小命令"><a href="#简单的几个小命令" class="headerlink" title="简单的几个小命令"></a>简单的几个小命令</h3><ol>
<li>获得符合规则的键名列表</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ KEYS pattern</code></pre>
<p>pattern 支持 glob 风格通配符格式：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配一个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意个（包括0个）字符</td>
</tr>
<tr>
<td>[]</td>
<td>匹配括号间的任一字符，可以使用 “-” 符号表示一个范围，如 a[b-d] 可以匹配 “ab”、“ac” 和 “ad”</td>
</tr>
<tr>
<td>\x</td>
<td>匹配字符 x，用于转义符号。如要匹配 “?” 就需要使用 ?</td>
</tr>
</tbody></table>
<blockquote>
<p>KEYS 命令需要遍历 Redis 中的所有键，当键的数量较多时会影响性能，不建议在生产环境中使用。Redis 不区分命令大小写。</p>
</blockquote>
<ol start="2">
<li>判断一个键是否存在</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ EXISTS key</code></pre>
<p>如果键存在则返回整数类型1，否则返回0。</p>
<ol start="3">
<li>删除键</li>
</ol>
<pre><code>$ DEL key</code></pre>
<p>可以删除一个或多个键，返回值是删除的键的个数。</p>
<blockquote>
<p><strong>技巧</strong>     DEL 命令的参数不支持通配符，但我们可以结合 Linux 的管道和 xargs 命令自己实现删除所有符合规则的键盘。比如要删除所有以 “user:” 开头的键，就可以执行<code>redis-cli KEYS "user:*" | xagrs redis cli DEL</code>。另外由于 DEL 命令支持多个键作为参数，所以还可执行如下命令来达到同样的效果，性能更好。</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli DEL `redis-cli KEYS <span class="token string">"user:*"</span>`</code></pre>
<p>如果连接redis 需要密码，则可以使用下面的这个命令</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -a 123456 DEL `redis-cli -a 123456 keys <span class="token string">"user:*"</span>`</code></pre>
</blockquote>
<ol start="4">
<li>获得键值的数据类型</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ TYPE key</code></pre>
<h3 id="命名习惯"><a href="#命名习惯" class="headerlink" title="命名习惯"></a>命名习惯</h3><blockquote>
<p>Redis 对于键的命名并没有强制的要求，但比较好的实践是用 <strong>“对象类型:对象ID:对象属性”</strong> 来命名一个键，如使用键  <code>user:1:friends</code> 来存储 ID 为 1 的用户的好友列表。对于多个单词则推荐使用 <code>“.”</code> 分隔，一方面是沿用以前的习惯（Redis 以前版本键名不能包含空格等特殊字符），另一方面是在 redis-cli 中容易输入，无需使用双引号包裹。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之发布-订阅模式</title>
    <url>/posts/8649.html</url>
    <content><![CDATA[<h3 id="发布-订阅-模式"><a href="#发布-订阅-模式" class="headerlink" title="发布/订阅 模式"></a>发布/订阅 模式</h3><p>Redis 提供了一组命令可以让开发者实现 “发布/订阅”（publish/subscribe）模式。“发布/订阅” 模式同样可以实现进程间的消息传递，其原理是这样的：</p>
<p>“发布/订阅” 模式中包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或若干个频道（channel），而发布者可以向指定的频道发布消息，所有订阅此频道的订阅者都可以收到此消息。</p>
<p>发布者发布消息的命令是 <code>PUBLISH</code>，用法是 <code>PUBLISH channel message</code>，如向 <code>channel.1</code> 说一声 “hi”：</p>
<pre class=" language-bash"><code class="language-bash">$ PUBLISH channel.1 hi
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>这样消息就发出去了。<code>PUBLISH</code> 命令的返回值表示接收到这条消息的订阅者数量。因为此时没有客户端订阅 <code>channel.1</code>，所以返回 0。发出去的消息不会被持久化，也就是说当有客户端订阅  <code>channel.1</code> 后只能收到后续发布到该频道的消息，之前发送的就收不到了。</p>
<p>订阅频道的命令是 <code>SUBSCRIBE</code>，可以同时订阅多个频道，用法是：</p>
<pre class=" language-bash"><code class="language-bash">$ SUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>现在新开一个 redis-cli 实例 A，用来订阅 <code>channel.1</code> ：</p>
<pre class=" language-bash"><code class="language-bash">$ SUBSCRIBE channel.1
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
1<span class="token punctuation">)</span> <span class="token string">"subscribe"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.1"</span>
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>执行 <code>SUBSCRIBE</code> 命令后，客户端会进入订阅状态，处于此状态下客户端不能使用除<code>SUBSRCIBE</code> 、<code>UNSUBSRCIBE</code> 、<code>PSUBSCRIBE</code> 、<code>PUNSUBSCRIBE</code> 这4个属于“发布/订阅”模式的命令之外的命令，否则会报错。</p>
<p>进入订阅状态后客户端可能收到三种类型的回复。每种类型的回复都包含3个值，第一个值是消息的类型，根据消息类型的不同，第二、第三个值的含义也不同。</p>
<p>消息类型的取值可能有一下3个：</p>
<ul>
<li><code>subscribe</code>。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个值是当前客户端订阅的频道数量。</li>
<li><code>message</code>。这个类型的回复是我们最关心的，它表示接收到的消息。第二个值表示产生消息的频道名称，第三个值是消息的内容。</li>
<li><code>unsubscribe</code>。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量。当此值为 0 时，客户端会退出订阅状态，之后就可以执行其它非 “发布/订阅” 模式的命令了。</li>
</ul>
<p>上例中当实例 A 订阅了 <code>channel.1</code>，进入订阅状态后收到一条 <code>subscribe</code> 类型的回复，这是我们打开另一个 redis-cli 实例 B，并向 <code>channel.1</code> 发送一条消息：</p>
<pre class=" language-bash"><code class="language-bash">$ PUBLISH channel.1 good
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>返回值为 1 表示有一个客户端订阅了 <code>channel.1</code>，此时实例 A 收到了类型为 <code>message</code> 的回复：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"message"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.1"</span>
3<span class="token punctuation">)</span> <span class="token string">"good"</span></code></pre>
<p>使用 UNSUBSCRIBE 命令可以取消订阅者指定的频道，用法为 </p>
<pre class=" language-bash"><code class="language-bash">UNSUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>如果不指定频道，则会取消订阅所有频道。</p>
<h3 id="按照规则订阅"><a href="#按照规则订阅" class="headerlink" title="按照规则订阅"></a>按照规则订阅</h3><p>除了可以使用 <code>SUBSCRIBE</code> 命令订阅指定的频道外，还可以使用 <code>PSUBSCRIBE</code> 命令订阅指定的规则。规则支持 <code>glob</code> 风格通配符格式。</p>
<pre class=" language-bash"><code class="language-bash">$ PSUBSCRIBE channel.?*
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
1<span class="token punctuation">)</span> <span class="token string">"psubscribe"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.?*"</span>
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>规则 <code>channel.1?*</code> 可以匹配 <code>channel.1</code> 和 <code>channel.10</code>。 但不会匹配 <code>channel.</code>。</p>
<p>这时在实例 B 中发布消息：</p>
<pre class=" language-bash"><code class="language-bash">$ PUBLISH channel.1 hi
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p>返回结果为 2 是因为实例 A 和 实例 C 两个客户端都订阅了 <code>channel.1</code> 频道。实例 C 收到的回复是：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"pmessage"</span>
2<span class="token punctuation">)</span> <span class="token string">"channel.?*"</span>
3<span class="token punctuation">)</span> <span class="token string">"channel.1"</span>
4<span class="token punctuation">)</span> <span class="token string">"hi"</span></code></pre>
<p>第一个值表示这条消息是通过 <code>PSUBSCRIBE</code> 命令订阅频道收到的，第二个值表示订阅时使用的通配符，第三个值表示产生消息的频道命令，第四个值则是消息内容。</p>
<blockquote>
<p><strong>提示</strong>    使用 <code>PSUBSCRIBE</code> 命令可以重复订阅一个频道，如某客户端执行了 <code>PUBSCRIBE  channel.?  channel.?*</code> ，这是向 <code>channel.2</code> 发布消息后该客户端会收到两条消息，而同时 <code>PUBLISH</code> 命令的返回值也是 2 不是 1。同样的，如果有两一个客户端执行了 <code>SUBSCRIBE channel.10</code> 和 <code>PSUBSCRIBE channel.?*</code> 的话，向 <code>channel.10</code> 发送命令该客服端也会收到两条消息（但是是两种类型：<code>message</code> 和 <code>pmessage</code>），同时 <code>PUBLISH</code> 命令会返回 2。</p>
</blockquote>
<p><code>PUNSUBSCRIBE</code> 命令可以退订指定的规则，用法是 ：</p>
<pre class=" language-bash"><code class="language-bash">$ PUNSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>如果没有参数则会退订所有规则。</p>
<blockquote>
<p><strong>注意</strong>    使用 <code>PUNSUBSCRIBE</code> 命令只会退订通过 <code>PSUBSCIBE</code> 命令订阅的规则，不会影响直接通过 <code>SUBSCRIBE</code> 命令订阅的频道；同样 <code>UNSUBSCRIBE</code> 命令也不会影响通过 <code>PSUBSCRIBE</code> 命令订阅的规则。另外容易出错的一点是使用 <code>PUNSUBSCIBE</code> 命令退订某个规则时，不会将其中的通配符展开，而是进行严格的字符串匹配，所有 <code>PUNSUBSCRIBE *</code> 无法退订 <code>channel.*</code> 规则，而是必须使用 <code>PUNSUBSCRIBE channel.*</code> 才能退订。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/posts/a455.html</url>
    <content><![CDATA[<blockquote>
<p>在微博中，用户之间是 “关注” 和 “被关注”的关系。如果要使用 Redis 存储这样的关系可以使用集合类型。思路是对每个用户使用两个集合类型键，分别名为 <code>user:用户ID:followers</code> 和 <code>user:用户ID:following</code> ，用来存储<strong>关注该用户的用户集合</strong> 和 <strong>该用户关注的集合</strong>。</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">follow</span><span class="token punctuation">(</span>$currentUser<span class="token punctuation">,</span> $targetUser<span class="token punctuation">)</span>
SADD user<span class="token punctuation">:</span>$currentUser<span class="token punctuation">:</span>following<span class="token punctuation">,</span> $targetUser
SADD user<span class="token punctuation">:</span>$taegetUser<span class="token punctuation">:</span>followers<span class="token punctuation">,</span> $currentUser</code></pre>
<p>如 ID 为 1 的用户 A 想关注 ID 为 2 的用 B，只需要执行 follow(1, 2) 即可。然而在实现该功能的时候发现了一个问题：完成关注操作需要一次执行两条 Redis 命令，如果在第一条命令执行完后，因为某种原因导致第二条命令没有执行。就会出现一个奇怪的现象：A 查看自己关注的用户列表时会发现其中有 B，而 B 查看关注自己的用户列表时却没有 A 。换句话说就是，A 虽然关注了 B ，却不是 B 的粉丝。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 中的事务（transaction） 是一组命令的集合。事务同命令一样都是 Redis 的最小执行单位，一个事务中的命令要么都执行，要么都不执行。</p>
<p>事务的原理是先将属于一个事务的命令发送给 Redis，然后将 Redis 依次执行这些命令。如：</p>
<pre class=" language-bash"><code class="language-bash">$ MULTI
OK
$ SADD <span class="token string">"user:1:following"</span> 2
QUEUED
$ SADD <span class="token string">"user:2:followers"</span> 1
QUEUED
$ EXEC
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre>
<p>首先使用 MULTI 命令告诉 Redis：“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来。” Redis 回答：“OK”。</p>
<p>而后我们发送了两个 SADD 命令来实现关注和被关注操作，可以看到 Redis 遵守了承诺，没有执行这些命令，而是返回 QUEUED 表示这两条命令已经进入等待执行的事务队列中了。</p>
<p>当把所有要在同一个事务中执行的命令都发给 Redis 后，我们使用 Exec 命令告诉 Redis 将等待执行的事务队列中的所有命令（即刚才所有返回 QUEUE 的命令）按照发送顺序依次执行。EXEC 命令的返回值就是这些命令的返回值组成的列表，返回值顺序和命令的顺序相同。</p>
<p>Redis 保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送 EXEC 命令前客户端断线了，则 Redis 会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了 EXEC 命令，所有的命令都会被执行，即使此后客户端断线也没关系，因为 Redis 中已经记录了所有要执行的命令。</p>
<p>除此之外，Redis 的事务还能保证一个事务内的命令一次执行而不被其它命令插入。试想客户端 A 需要执行几条命令，同时客户端 B 发送了一条命令，如果不使用事务，则客户端 B 的命令可能会插入到 客户端 A 的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>一个事务中的某个命令出错，针对错误的不同，Redis 会有不同的不同。</p>
<ul>
<li>语法错误。语法错误指命令不存在或者命令参数的个数不对。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ MULTI
OK
$ SET key value
QUEUED
$ SET key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR wrong number of arguments <span class="token keyword">for</span> <span class="token string">'set'</span> <span class="token function">command</span>
$ ERRORCOMMAND key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR unknown <span class="token function">command</span> <span class="token variable"><span class="token variable">`</span>ERRORCOMMAND<span class="token variable">`</span></span>, with args beginning with: <span class="token variable"><span class="token variable">`</span>key<span class="token variable">`</span></span>,
$ EXEC
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> EXECABORT Transaction discarded because of previous errors.</code></pre>
<p>只要有一个命令语法错误，执行 EXEC 命令后 Redis 就会直接返回错误，连语法正确的命令也不会执行。</p>
<ul>
<li>运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ MULTI
OK
$ SET key 1
QUEUED
$ SADD key 2
QUEUED
$ <span class="token keyword">set</span> key 3
QUEUED
$ EXEC
1<span class="token punctuation">)</span> OK
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> WRONGTYPE Operation against a key holding the wrong kind of value
3<span class="token punctuation">)</span> OK</code></pre>
<p>可见，如果事务里的一条命名出现了运行错误，事务里其它的命令依然会继续执行。</p>
<p>Redis 的事务没有回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的烂摊子（将数据库复原回事务执行前的状态等）。</p>
<h3 id="WATCH-命令"><a href="#WATCH-命令" class="headerlink" title="WATCH 命令"></a>WATCH 命令</h3><p><code>WATCH</code> 命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到 <code>EXEC</code> 命令。</p>
<pre class=" language-bash"><code class="language-bash">$ SET key 1
OK
$ WATCH key
OK
$ SET key 2
OK
$ MULTI
OK
$ SET key 3
QUEUED
$ EXEC
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
$ GET key
<span class="token string">"2"</span></code></pre>
<p>上例中在执行 <code>WATCH</code> 命令后、事务执行前修改了 key 的值（即 SET key 2) ，所以最后事务中的命令 <code>SET key 3</code> 没有执行， <code>EXEC</code> 返回空结果。</p>
<blockquote>
<p>由于 <code>WATCH</code> 命令的作用只是当被监控的键值被修改后，阻止之后一个事务的执行，而不能保证其它客户端不修改这以键值，所以我们需要在 <code>EXEC</code> 执行失败后，重新执行整个函数。</p>
</blockquote>
<p>执行 EXEC 命令会取消对所有键的监控。</p>
<p>可以使用 UNWATCH 命令来保证下一个事务的执行不会收到影响。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis位操作</title>
    <url>/posts/5969.html</url>
    <content><![CDATA[<h3 id="位操作命令"><a href="#位操作命令" class="headerlink" title="位操作命令"></a>位操作命令</h3><pre class=" language-bash"><code class="language-bash">$ GETBIT key offset
$ SETBIT key offset value
$ BITCOUNT key <span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token punctuation">[</span>end<span class="token punctuation">]</span>
$ BITOP operation destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>一个字节由 8 个二进制位组成，Redis 提供了 4 个命令可以直接对二进制位进行操作。为了演示，我们首先将 foo 赋值为 bar：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK</code></pre>
<p>bar 的 3 个字母 “b”, “a” 和 “r” 对应的 ASCII 码分别为98、97 和 114，转换为二进制后分别为 1100010、1100001 和 1110010，所以 foo 键中的二进制位结构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/14771610958236_.pic_hd.jpg"></p>
<p><code>GETBIT</code> 命令可以获得一个字符串类型键指定位置的二进制位的值（0 或 1），索引从 0 开始：</p>
<pre class=" language-bash"><code class="language-bash">$ GETBIT foo 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
$ GETBIT foo 6
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>如果需要获取的二进制位的索引超出了键值的二进制为的实际长度则默认值是0：</p>
<pre class=" language-bash"><code class="language-bash">$ GETBIT foo 10000
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p><code>SETBIT</code> 命令可以设置字符串类型键指定位置的二进制位的值，返回值是该位置的旧值。如我们要将 foo 键值设置为 arr，可以通过位操作将 foo 键的二进制位的索引第 6 位设为0，第 7 位设为1：</p>
<pre class=" language-bash"><code class="language-bash">$ SETBIT foo 6 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ SETBIT foo 7 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
$ GET foo
<span class="token string">"aar"</span></code></pre>
<p>如果要设置的位置超过了键值的二进制位的长度，<code>SETBIT</code> 命令会自动将中间的二进制位设置为 0。</p>
<p><code>BITCOUNT</code> 命令可以获得字符串类型键中值是1的二进制位个数，如：</p>
<pre class=" language-bash"><code class="language-bash">$ BITCOUNT foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10</code></pre>
<p>可以通过参数来限制统计的字节范围，如我们只希望统计前两个字节（即 “aa” ）:</p>
<pre class=" language-bash"><code class="language-bash">$ BITCOUNT foo 0 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6</code></pre>
<p><code>BITOP</code> 命令可以对多个字符串类型键进行位运算，并将结果存储在 destkey 参数指定的键中。<code>BITOP</code> 命令支持的运算操作有 AND、OR、XOR 和 NOT。</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo1 bar
OK
$ SET foo2 aar
OK
$ BITOP OR res foo1 foo2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ GET res
<span class="token string">"car"</span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/14841610959643_.pic_hd.jpg"></p>
<p><code>BITPOS</code>  命令可以获得指定键的第一个位置是 0 或者 1 的位置。还是以 ”bar“这个键值位例，如果想获取键值中的第一个二进制位为 1 的偏移量，则可以执行：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK
$ BITPOS foo 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p><code>BITOPS</code> 命令的第二个和第三个参数分别可以用来指定要查询的起始字节和结束字节。注意这里的单位不再是二进制位，而是字节。如果我们想查询的第二个字节到第三个字节之间（即 ”a“ 和 ”r“）出现的第一个值位 1 的二进制位的偏移量，则可以执行：</p>
<pre><code>$ BITPOS foo 1 1 2
(integer) 9</code></pre>
<p>这里的返回结果的偏移量是从头开始算起的，与起始字节无关。</p>
<blockquote>
<p>如果不设置结束字节且键值的所有二进制位都是 1 ，则当要查询值为 0 的二进制位偏移量时，返回结果会是键值长度的下一个字位的偏移量。这是因为 Redis 会认为键值长度之后的二进制位都是 0。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/posts/f2a0.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis 支持两种方式的持久化，一种是 RDB 方式，另一种是 AOF 方式。前者会根据指定的规则 “定时” 将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。两种持久化方式可以单独使用其中一种，但更多情况下是将二者结合使用。</p>
<h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>RDB 方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即为“快照”。Redis 会在一下几种情况下对数据进行快照：</p>
<ul>
<li>根据配置规则进行自动快照</li>
</ul>
<p>Redis 允许用户自定义快照条件，当符合快照条件时，Redis 会自动执行快照条件。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：<strong>时间窗口 M 和 改动的键的个数 N。</strong>每当时间 M 内被更改键的个数大于 N 时，即符合自动快照条件。例如 Redis 安装目录中包含的样例配置文件中预置的3个条件：</p>
<pre class=" language-shell"><code class="language-shell">save 900 1
save 300 10
save 60 10000</code></pre>
<p>每条快照条件占一行，并且以 save 参数开头。同样可以存在多个条件，条件之间是 “或” 的关系。就这个例子而言，<code>save 900 1</code> 的意思是在 15 分钟（900秒）内由一个或一个以上的键被更改则进行快照。同理，<code>save 300 10</code> 表示在 300 秒内至少有10个键被修改则进行快照。</p>
<ul>
<li>用户执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令</li>
</ul>
<p>除了让 Redis 自动进行快照外，当进行服务重启、手动迁移以及备份时我们也会需要手动执行快照操作。Redis 提供了两个命令来完成这一任务。</p>
<ol>
<li><code>SAVE</code> 命令</li>
</ol>
<p>当执行 SAVE 命令时，Redis 同步地进行快照操作，在快照执行过程中会阻塞所有来自客户端地请求。当数据库中的数据比较多时，这一过程导致 Redis 较长时间不响应，所以要尽量避免在生产环境使用这一命令。</p>
<ol start="2">
<li><code>BGSAVE</code> 命令</li>
</ol>
<p>需要手动执行快照时推荐使用 <code>BGSAVE</code> 命令。<code>BGSAVE</code> 命令可以在后台异步地进行快照操作，快照的同时服务器还可以继续相应来自客户端的请求。执行 <code>BGSAVE</code> 后 Redis 会立即返回 OK 表示开始执行快照操作，如果想知道快照是否完成，可以通过 <code>LASTSAVE</code> 命令获取最近一次成功执行快照的时间，返回结果是一个 Unix 时间戳，如：</p>
<pre class=" language-bash"><code class="language-bash">$ LASTSAVE
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1611125890</code></pre>
<ul>
<li>执行 <code>FLUSHALL</code> 命令</li>
</ul>
<p>当执行 FLUSHALL 命令时，Redis 会清除数据库中的所有数据。需要注意的是，不论清空数据的操作是否出发了自动快照条件，只要自动快照条件不为空，Redis 就会执行一次快照操作。</p>
<p>当没有定义快照条件时，执行 <code>FLUSHALL</code> 则不会进行快照。</p>
<ul>
<li>执行复制（replication） 时</li>
</ul>
<p>当设置了主从模式时，Redis 会在复制初始化时自动进行自动快照。即使没有定义自动快照条件，并且手动没有执行过快照操作，也会生成 RDB 快照文件。</p>
<h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>理清 Redis 实现快照的过程对我们了解快照文件的特性有很大的帮助。Redis 默认会将快照文件存储在 Redis 当前进程的工作目录中的 <code>dump.rdb</code> 文件中，可以通过配置 <code>dir</code> 和 <code>dbfilename</code> 两个参数分别指定快照文件的存储路径和文件名。快照的过程如下：</p>
<ol>
<li>Redis 使用 fork 函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li>父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li>当子进程写入完所有数据后会用该临时文件替换旧的 RDB 文件，至此一次快照操作完成。</li>
</ol>
<blockquote>
<p><strong>提示</strong>    在执行 fork 的时候，操作系统（类 Unix 操作系统）会使用写时复制（copy-on-write）策略，即 fork 函数发生的一刻，父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保子进程的数据不受影响，所以新的 RDB 文件存储的是执行 fork 一刻的内存数据。</p>
<p>写时复制策略也保证了在 fork 的时刻，虽然看上去生成了两份内存副本，但实际上内存的占用量并不会增加一倍。这意味着当系统内存只有 2GB ，而 Redis 数据库的内存有 1.5GB，执行 fork 后内存使用量并不会增加到 3GB（超过物理内存）。为此需要确保 Linux 系统允许应用程序申请超过可用内存（物理内存和交换区）的空间，方法是在 <code>/etc/sysctl.conf</code> 文件加入 <code>vm.overcommit_memory = 1</code>，然后重启系统或者执行<code>sysctl vm.overcommit_memeoty = 1</code> 确保设置生效。</p>
<p>另外需要注意的是，当进行快照的过程中，如果写入操作较多，造成 fork 前后数据差异较大，是会使得内存使用量显著超过实际数据大小的，因为内存中不仅保存了当前的数据库数据，而且还保存着 fork 时刻的内存数据。进行内存用量估算时很容易忽略这一问题，造成内存用量超限。</p>
</blockquote>
<p>通过上述过程可以发现 Redis 在进行快照的过程中不会修改 RDB 文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候 RDB 文件都是完整的。这使得我们可以通过定时备份 RDB 文件来实现 Redis 数据库备份。 RDB 文件是讲过压缩的二进制格式（可以配置 <code>rdbcompression</code> 参数以禁用压缩节省 CPU 占用），所以占用的空间会小于内存中的数据大小，更加利于传输。</p>
<p>Redis 启动后会读取 RDB 快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录 1000 万个字符串类型键、大小为 1GB 的快照文件载入到内存中需要花费 20~30 秒。</p>
<p>通过 RDB 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。例如，使用 Redis 存储缓存数据时，丢失最近几秒的数据或者丢失最近更新的几十个键并不会有很大的影响。如果数据相对重要，希望将损失降到最小，则可以使用 AOF 的方式进行持久化。</p>
<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>当使用 Redis 存储非临时数据时，一般需要打开 AOF 持久化来降低进程终止导致的数据损失。AOF 可以将 Redis 执行的每一条写命令追加到硬盘文件中，这一过程显然会降低 Redis 的性能，但是大部分情况下这个影响是可以接受的，另外使用较快的硬盘可以提高 AOF 的性能。</p>
<ul>
<li>开启 AOF</li>
</ul>
<p>默认情况下，Redis 没有开启 AOF（append only file） 方式的持久化，可以通过 <code>appendonly</code>   参数启用：</p>
<pre class=" language-shell"><code class="language-shell">appendonly yes</code></pre>
<p>开启 AOF 持久化后没执行一条会更改 Redis 中的数据的命令，Redis 就会将命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>，可以通过 <code>appendfilename</code> 参数修改：</p>
<pre class=" language-sehll"><code class="language-sehll">appendonlyname appendonly.aof</code></pre>
<h3 id="AOF实现"><a href="#AOF实现" class="headerlink" title="AOF实现"></a>AOF实现</h3><p>AOF 文件以纯文本的形式记录了 Redis 执行的写命令，例如在开启 AOF 持久化的情况下执行了如下 4 个命令：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">set</span> foo 1
OK
$ <span class="token keyword">set</span> foo 2
OK
$ <span class="token keyword">set</span> foo 3
OK
$ get foo
<span class="token string">"3"</span></code></pre>
<p>此时 AOF 文件中的内容如下：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> appendonly.aof
*2
<span class="token variable">$6</span>
SELECT
<span class="token variable">$1</span>
0
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$1</span>
1
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$1</span>
2
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$1</span>
3</code></pre>
<p>可见 AOF 文件的内容正是 Redis 客户端 向 Redis 发送的原始通信协议的内容，从中可见 Redis 确实只记录了前 3 条命令。然后这时有一个问题是前 2 条命令其实都是冗余的，因为这两条的执行结果会被第三条命令覆盖。随着执行的命令越来越多，AOF 文件的大小也会越来越大，即使内存中实际的数据并没有多少。</p>
<p>很自然地，我们希望 Redis 可以自动优化 AOF 文件，就上例而言，就是将前两条无用地记录删除，只保留第三条。实际上 Redis 也正是这样做的，每当达到一定条件时，Redis 就会自动重写AOF 文件, 这个条件可以在配置文件中设置：</p>
<pre class=" language-shell"><code class="language-shell">auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb</code></pre>
<p>auto-aof-rewrite-percentage 参数的意义是当前的 AOF 文件大小超过上一次重写时的 AOF 文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的 AOF 文件大小为依据。</p>
<p>auto-aof-rewrite-min-size 参数限制了允许重写的最小 AOF 文件大小，通常在 AOF 文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。</p>
<p>除了让 Redis 自动执行重写外，我们还可以主动使用 <code>BGREWRITEAOF</code> 命令手动执行 AOF 重写。</p>
<h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>虽然每次执行更改数据库内容的操作时，AOF 都会将命令记录在 AOF 文件中，但是事实上，由于操作系统的缓存机制，数据没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每 30 秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30 秒的过程如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用 AOF 持久化的应用都无法容忍这样的损失，这就需要 Redis 在写入 AOF 文件后主动要求系统将缓存内容同步到硬盘中。在 Redis 中我们可以通过 <code>appendfsync</code> 参数设置同步的时机：</p>
<pre class=" language-shell"><code class="language-shell"># appendfsync always
appendfsync everysec
# appendfsync no</code></pre>
<p>默认情况下 Redis 采用 <code>everysec</code> 规则，即每秒执行一次同步操作。<code>always</code> 表示每次执行写入都会执行同步，这是最安全也是最慢的方式。<code>no</code> 表示不主动进行同步操作，而是完全交由操作系统来做（即每 30 秒一次），这是最快但最不安全的方式。一般情况下使用 <code>everysec</code> 足够了，即兼顾了性能又保证了安全。</p>
<blockquote>
<p>Redis 允许同时开启 AOF 和 RDB，即保证了数据安全又使得进行备份等操作十分容易。此时重新启动 Redis 后， Redis会使用 AOF 文件来恢复数据，因为 AOF 方式的持久化可能丢失的数据更少。 </p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的SORT命令</title>
    <url>/posts/7886.html</url>
    <content><![CDATA[<p><code>SORT</code> 命令可以对列表类型、集合类型和有序集合类型键进行排序。</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH myList 4 2 6 1 3 7
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
$ LRANGE myList 0 -1
1<span class="token punctuation">)</span> <span class="token string">"7"</span>
2<span class="token punctuation">)</span> <span class="token string">"3"</span>
3<span class="token punctuation">)</span> <span class="token string">"1"</span>
4<span class="token punctuation">)</span> <span class="token string">"6"</span>
5<span class="token punctuation">)</span> <span class="token string">"2"</span>
6<span class="token punctuation">)</span> <span class="token string">"4"</span>
$ SORT myList
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span>
5<span class="token punctuation">)</span> <span class="token string">"6"</span>
6<span class="token punctuation">)</span> <span class="token string">"7"</span></code></pre>
<p>在对有序集合排序时会忽略元素的分数，只针对元素自身的值进行排序。比如：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD myzset 50 2 40 3 20 1 60 5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
$ SORT myzset
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"5"</span></code></pre>
<p>除了可以排列数字外，SORT 命令还可以通过 ALPHA 参数实现按照字典顺序排列非数字元素，就像这样：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH myList z c d a e h j b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 8
$ SORT myList
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR One or <span class="token function">more</span> scores can<span class="token string">'t be converted into double
$ SORT myList ALPHA
1) "a"
2) "b"
3) "c"
4) "d"
5) "e"
6) "h"
7) "j"
8) "z"
$ ZADD myzset 77 asiaMa 90 xiu 68 min
(integer) 3
$ SORT myzset
(error) ERR One or more scores can'</span>t be converted into double
$ SORT myzset ALPHA
1<span class="token punctuation">)</span> <span class="token string">"asiaMa"</span>
2<span class="token punctuation">)</span> <span class="token string">"min"</span>
3<span class="token punctuation">)</span> <span class="token string">"xiu"</span></code></pre>
<p>从这段示例中可以看到如果没有加 <code>ALPHA</code> 参数的话，<code>SORT</code> 命令会尝试将所有元素转换成双精度数来比较，如果无法转换则会提示错误。</p>
<p><code>SORT</code> 命令还支持 <code>LIMIT</code> 参数来返回指定范围的记过。用法同 SQL 语句一样，<code>LIMIE offset count</code>, 表示跳过前 offset 个元素并获取之后的 count 个元素。</p>
<pre class=" language-bash"><code class="language-bash">$ SORT tag:ruby:posts DESC LIMIT 1 2</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的安装与启动</title>
    <url>/posts/dc55.html</url>
    <content><![CDATA[<h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wget</span> https://download.redis.io/releases/redis-6.0.10.tar.gz
$ <span class="token function">tar</span> xzf redis-6.0.10.tar.gz
$ <span class="token function">cd</span> redis-6.0.10
$ <span class="token function">make</span></code></pre>
<p>Redis 没有其它外部依赖，安装过程很简单。编译后在<strong>Redis源代码目录的 src 文件夹</strong>中可以找到若干个可执行程序，最好在编译后直接执行 <code>make install</code> 命令来将这些可执行程序复制到 <code>/user/local/bin</code> 目录中以便以后执行程序时不用输入完整的路径。</p>
<p>在实际运行 Redis 前推荐使用 <code>make test</code> 命令测试 Redis 是否编译正确，尤其是在编译一个不稳定版本的 Redis  时。</p>
<h3 id="启动和停止-Redis"><a href="#启动和停止-Redis" class="headerlink" title="启动和停止 Redis"></a>启动和停止 Redis</h3><p>在这之前需要了解 Redis 包含的可执行文件有哪些，如下：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>redis-server</td>
<td>Redis服务器</td>
</tr>
<tr>
<td>redis-cli</td>
<td>Redis命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>Redis性能测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>AOF文件修复工具</td>
</tr>
<tr>
<td>redis-check-rdb</td>
<td>RDB文件检查工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>Sentinel服务器</td>
</tr>
</tbody></table>
<p>如果在编译后执行了 <code>make install</code> 命令，这些程序会被复制到 <code>/usr/local/bin</code> 目录内，所以在命令行中直接输入程序名称即可执行。</p>
<h4 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h4><p>启动 Redis 有直接启动和通过初始化脚本启动两种方式，分别适用于开发环境和生产环境。</p>
<ul>
<li>直接启动</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ redis-server</code></pre>
<p>Redis 服务器默认会使用 6379 端口，通过 –port 参数可以自定义端口号：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-server --port 6380</code></pre>
<ul>
<li>通过初始化脚本启动 redis</li>
</ul>
<p>在 Linux 系统中可以通过初始化脚本启动 Redis, 使得 Redis 能随系统自动运行，在生产环境中推荐使用此方法运行Redis，这 <strong>Redis 源代码目录得 utils 文件夹中有一个名为 redis_init_script 的初始化脚本文件</strong>，内容如下：</p>
<pre class=" language-shell"><code class="language-shell">#!/bin/sh
#
# Simple Redis init.d script conceived to work on Linux systems
# as it does use of the /proc filesystem.

### BEGIN INIT INFO
# Provides:     redis_6379
# Default-Start:        2 3 4 5
# Default-Stop:         0 1 6
# Short-Description:    Redis data structure server
# Description:          Redis data structure server. See https://redis.io
### END INIT INFO

REDISPORT=6379    # 端口号
EXEC=/usr/local/bin/redis-server # redis-server 启动脚本的位置
CLIEXEC=/usr/local/bin/redis-cli # redis-cli 客户端启动脚本的位置

PIDFILE=/var/run/redis_${REDISPORT}.pid
CONF="/etc/redis/${REDISPORT}.conf"    # redis.conf 配置文件的位置

case "$1" in
    start)
        if [ -f $PIDFILE ]
        then
                echo "$PIDFILE exists, process is already running or crashed"
        else
                echo "Starting Redis server..."
                $EXEC $CONF
        fi
        ;;
    stop)
        if [ ! -f $PIDFILE ]
        then
                echo "$PIDFILE does not exist, process is not running"
        else
                PID=$(cat $PIDFILE)
                echo "Stopping ..."
                $CLIEXEC -p $REDISPORT shutdown
                while [ -x /proc/${PID} ]
                do
                    echo "Waiting for Redis to shutdown ..."
                    sleep 1
                done
                echo "Redis stopped"
        fi
        ;;
    *)
        echo "Please use start or stop as first argument"
        ;;
esac</code></pre>
<p>我们需要配置 Redis 的运行方式和持久化文件、日志文件的存储位置等，具体步骤如下。</p>
<ol>
<li>配置初始化脚本。首先将初始化脚本复制到 <code>/etc/init.d</code> 目录中，文件名<strong>redis_端口号</strong>，其中端口号表示要让 Redis 监听的端口号，客户端通过该端口连接 Redis 。然后修改脚本第14行的  <code>REDISPORT</code>  变量的值为同样的端口号。</li>
<li>建立需要的文件夹：</li>
</ol>
<table>
<thead>
<tr>
<th>目录名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/redis</td>
<td>存放 Redis 的配置文件</td>
</tr>
<tr>
<td>/var/redis/端口号</td>
<td>存放 Redis 的持久化文件</td>
</tr>
</tbody></table>
<ol start="3">
<li>修改配置文件。首先将配置文件模板（ Redis 提供了一个配置文件的模板 <code>redis.conf</code>，位于源代码目录的根目录中）复制到 /etc/redis 目录中，以端口号命名（如“6379.conf“），然后对其中的部分参数进行编辑：</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes</td>
<td>使 Redis 以守护进程模式运行</td>
</tr>
<tr>
<td>pidfile</td>
<td>/var/run/redis_端口号.pid</td>
<td>设置 Redis 的 PID 文件位置</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
<td>设置 Redis 监听的端口号</td>
</tr>
<tr>
<td>dir</td>
<td>/var/redis/端口号</td>
<td>设置持久化文件存放位置</td>
</tr>
<tr>
<td>bind</td>
<td>0.0.0.0</td>
<td>允许远程连接</td>
</tr>
<tr>
<td>requirepass</td>
<td>“123456”</td>
<td>设置连接密码123456</td>
</tr>
</tbody></table>
<p>现在就可以使用如下命令来启动 Redis 了：</p>
<pre class=" language-bash"><code class="language-bash">$ /etc/init.d/redis_端口号 start</code></pre>
<p>设置开机自启动：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">chkconfig</span> redis_6379 on</code></pre>
<blockquote>
<p>系统开机启动时会去加载/etc/init.d/下面的脚本，通常而言每个脚本文件会自定义实现程序的启动；若想将新的程序开机自启动，只需在该目录下添加一个自定义启动程序的脚本，然后设置相应规则即可。<br>如在这里我们在/etc/init.d/下新建一个 redis_端口号 的脚本，开机启动时会去加载执行该脚本。</p>
</blockquote>
<h3 id="停止Redis"><a href="#停止Redis" class="headerlink" title="停止Redis"></a>停止Redis</h3><p>考虑到 Redis 有可能正在将内存中的数据同步到硬盘中，强制终止 Redis 进行可能会导致数据丢失。正确停止 Redis 的方式应该是向 Redis 发送 SHUTDOWN 命令，方法为：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli SHUTDOWN</code></pre>
<p>当 Redis 收到 <code>SHUTDOWN</code> 命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>
<p>Redis 可以妥善处理 SIGTERM （signal termination） 信号，所以使用 kill Redis 进行的 PID 也可以正常结束 Redis，效果与发送 SHTUDOWN 命令一样。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis管理</title>
    <url>/posts/3687.html</url>
    <content><![CDATA[<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Redis 的作者 <code>Salvatore Sanfilippo</code> 曾经发表过 Redis 宣言，其中提到 Redis 以简洁为美。同样在安全层面 Redis 也没有做太多的工作。 </p>
<h3 id="可信的环境"><a href="#可信的环境" class="headerlink" title="可信的环境"></a>可信的环境</h3><p>Redis 的安全设计是在 “ Redis 运行在可信环境” 这个前提下做出的。在生产环境运行时不能允许外界直接连接到 Redis 服务器上，而应该通过应用程序中转，运行在可信的环境中是保证 Redis 安全的最重要方法。</p>
<p>如只允许本机应用连接 Redis ，可以将 bind 参数改成：</p>
<pre class=" language-bash"><code class="language-bash">bind 127.0.0.1</code></pre>
<p>bind 参数只能绑定一个地址，如果想更自由的设置绑定规则需要通过防火墙来完成。</p>
<h3 id="数据库密码"><a href="#数据库密码" class="headerlink" title="数据库密码"></a>数据库密码</h3><p>可以通过配置文件中的 <code>requirepass</code> 参数为 Redis 设置一个密码。例如：</p>
<pre class=" language-shell"><code class="language-shell">requirepass 123456</code></pre>
<p>客户端每次连接到 Redis 时都需要发送密码，否则 Redis 会拒绝执行客户端发来的命令。</p>
<p>例如：</p>
<pre class=" language-bash"><code class="language-bash">$ GET foo
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR operation not permitted.</code></pre>
<p>发送密码需要使用 AUTH 命令，就像这样：</p>
<pre class=" language-bash"><code class="language-bash">$ AUTH 123456
OK</code></pre>
<p>之后就可以执行任何命令了。</p>
<p>由于 Redis 的性能极高，并且输入错误密码后 Redis 并不会进行主动延迟（考虑到 Redis 的单线程模型），所以攻击者可以通过穷举法破解 Redis 的密码（ 1 秒内能够尝试十几万个密码 ），因此在设置时一定要选择负责的密码。</p>
<blockquote>
<p><strong>提示</strong>    配置 Redis 复制的时候如果主数据库设置了密码，需要在从数据库的配置文件中通过 <code>masterauth</code> 参数设置主数据库的密码，以使从数据库连接主数据库时自动使用 AUTH 命令认证。</p>
</blockquote>
<h3 id="命名命令"><a href="#命名命令" class="headerlink" title="命名命令"></a>命名命令</h3><p>Redis 支持在配置文件中将命令重命名，比如将 <code>FLUASHALL</code> 命令重命名成一个比较复杂的名字，以保证自己的应用可以使用该命令。就像这样：</p>
<pre><code>rename-command FLUSHALL oyfekmjumwar5a8c0it2k</code></pre>
<p>如果希望直接禁用某个命令可以将命令重命名成空字符串：</p>
<pre class=" language-bash"><code class="language-bash">rename-command FLUSHALL <span class="token string">""</span></code></pre>
<blockquote>
<p><strong>注意</strong>    无论设置密码还是重命名命令，都需要保证配置文件的安全性，否则就没有任何意义了。</p>
</blockquote>
<h3 id="Redis-cli"><a href="#Redis-cli" class="headerlink" title="Redis-cli"></a>Redis-cli</h3><h4 id="耗时命令日志"><a href="#耗时命令日志" class="headerlink" title="耗时命令日志"></a>耗时命令日志</h4><p>当一条命令执行时间超过限制时，Redis 会将该命令的执行时间等信息加入耗时命令日志（show log）以供开发者查看。可以通过配置文件的 <code>slowlog-log-slower-than</code> 参数设置这一限制，要注意单位是微秒（1000000微妙相当于 1 秒），默认值是 10 000。耗时命令日志存储在内存中，可以通过配置文件的 <code>slowlog-max-len</code>参数来限制记录的条数。</p>
<p>使用 SLOWLOG GET 命令来获得当前的耗时命令日志，如：</p>
<pre class=" language-bash"><code class="language-bash">redis<span class="token operator">></span> SLOWLOG GET
   1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1611295121
   3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"set"</span>
      2<span class="token punctuation">)</span> <span class="token string">"foo"</span>
      3<span class="token punctuation">)</span> <span class="token string">"bar"</span></code></pre>
<p>每条日志都由以下 4  个部分组成：</p>
<ul>
<li>该日志唯一 ID</li>
<li>该命令执行的 Unix 时间</li>
<li>该命令的耗时时间，单位是微秒</li>
<li>命令及其参数。</li>
</ul>
<blockquote>
<p><strong>提示</strong>    为了产生一些耗时命令日志作为演示，这里将 <code>slowlog-log-slower-than</code> 参数设置为 0，即记录所有命令。如果设置为负数则会关闭耗时命令日志。</p>
</blockquote>
<h4 id="命令监控"><a href="#命令监控" class="headerlink" title="命令监控"></a>命令监控</h4><p>Redis 提供了 MONITOR 命令来监控 Redis 执行的所有命令，redis-cli 同样支持这个命令，如在 redis-cli 中执行 MONITOR：</p>
<pre class=" language-bash"><code class="language-bash">$ MONITOR
OK</code></pre>
<p>这时 Redis 执行的任何命令都会在 redis-cli 中打印出来，如我们打开另一个 redis-cli 执行 <code>SET foo bar</code> 命令，在之前的 redis-cli 中会输出以下内容：</p>
<pre class=" language-bash"><code class="language-bash">1611295421.146357 <span class="token punctuation">[</span>0 127.0.0.1:37122<span class="token punctuation">]</span> <span class="token string">"keys"</span> <span class="token string">"*"</span></code></pre>
<p>MONITOR 命令非常影响 Redis 的性能，一个客户端使用 MONITOR 命令会降低 Redis 将近一半的负载能力。所以 MONITOR 命令只适合用来调试和纠错。</p>
<h3 id="Rdbtools"><a href="#Rdbtools" class="headerlink" title="Rdbtools"></a>Rdbtools</h3><p>Rdbtools 是一个 Redis 的快照文件解析器，它可以根据快照文件导出 JSON 数据文件、分析 Redis 中每个键的占用空间情况等。</p>
<h4 id="安装-Rdbtools"><a href="#安装-Rdbtools" class="headerlink" title="安装 Rdbtools"></a>安装 Rdbtools</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/sripathikrishnan/redis-rdb-tools
<span class="token function">cd</span> redis-rdb-tools
<span class="token function">sudo</span> python3 setup.py <span class="token function">install</span></code></pre>
<h4 id="生成快照文件"><a href="#生成快照文件" class="headerlink" title="生成快照文件"></a>生成快照文件</h4><p>如果没有启用 RDB 持久化，可以使用 SAVE 命令手动使 Redis 生成快照文件。</p>
<h4 id="将快照导出为-JSON-格式"><a href="#将快照导出为-JSON-格式" class="headerlink" title="将快照导出为 JSON 格式"></a>将快照导出为 JSON 格式</h4><p>快照文件时二进制格式，不利于查看，可以使用 Rdbtools 来将其导出为 JSON 格式，命令如下：</p>
<pre class=" language-bash"><code class="language-bash">$ rdb --command json /path/to/dump.rdb <span class="token operator">></span> output_filename.json</code></pre>
<p>其中 <code>/path/to/dump.rdb</code> 是快照文件的路径，<code>output_filename.json</code> 为要导出的文件路径。</p>
<h4 id="生成空间使用情况报告"><a href="#生成空间使用情况报告" class="headerlink" title="生成空间使用情况报告"></a>生成空间使用情况报告</h4><p>Rdbtools 能够将快照文件中记录的每个键的存储情况导出为 CSV 文件，可以将该 CSV 文件导入到 Excel 等数据分析工具中分析来了解 Redis 的使用情况。命令如下：</p>
<pre class=" language-bash"><code class="language-bash">$ rdb -c memory /path/to/dump.rdb --bytes 128 -f memory.csv</code></pre>
<p>导出的 CSV 文件的字段如下所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>存储该键的数据库索引</td>
</tr>
<tr>
<td>type</td>
<td>键类型（使用 TYPE 命令获得）</td>
</tr>
<tr>
<td>key</td>
<td>键名</td>
</tr>
<tr>
<td>size_in_bytes</td>
<td>键大小（字节）</td>
</tr>
<tr>
<td>encoding</td>
<td>内部编码（使用 OBJECTENCODING 命令获得）</td>
</tr>
<tr>
<td>num_elements</td>
<td>键的元素数</td>
</tr>
<tr>
<td>len_largest_element</td>
<td>最大元素的长度</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream中flatmap使用</title>
    <url>/posts/9fb2.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><p>map：map方法返回的是一个object，map将流中的当前元素替换为此返回值；</p>
<p>flatMap：flatMap方法返回的是一个stream，flatMap将流中的当前元素替换为此返回流拆解的流元素；</p>
<h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><blockquote>
<p>map:Returns a stream consisting of the results of applying the given function to the elements of this stream.</p>
</blockquote>
<p>返回一个流，包含给定函数应用在流中每一个元素后的结果</p>
<blockquote>
<p>flatmap:Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.</p>
</blockquote>
<p>返回一个流，包含将此流中的每个元素替换为通过给定函数映射应用于每个元素而生成的映射流的内容</p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>有二箱鸡蛋，每箱5个，现在要把鸡蛋加工成煎蛋，然后分给学生。</p>
<p>map做的事情：把二箱鸡蛋分别加工成煎蛋，还是放成原来的两箱，分给2组学生；</p>
<p>flatMap做的事情：把二箱鸡蛋分别加工成煎蛋，然后放到一起【10个煎蛋】，分给10个学生；</p>
<h3 id="用例一"><a href="#用例一" class="headerlink" title="用例一"></a>用例一</h3><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> data <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"好,好,学"</span><span class="token punctuation">,</span> <span class="token string">"习,天,天"</span><span class="token punctuation">,</span> <span class="token string">"向,上"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> dataArray <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">:</span> dataArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果： [好, 好, 学] [习, 天, 天] [向, 上] */</span>

List<span class="token operator">&lt;</span>String<span class="token operator">></span> dataList <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Stream<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">apply</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dataList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** 输出结果： [好, 好, 学, 习, 天, 天, 向, 上] */</span></code></pre>
<h3 id="用例二"><a href="#用例二" class="headerlink" title="用例二"></a>用例二</h3><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamIndia <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Virat"</span><span class="token punctuation">,</span> <span class="token string">"Dhoni"</span><span class="token punctuation">,</span> <span class="token string">"Jadeja"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamAustralia <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Warner"</span><span class="token punctuation">,</span> <span class="token string">"Watson"</span><span class="token punctuation">,</span> <span class="token string">"Smith"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamEngland <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> <span class="token string">"Bell"</span><span class="token punctuation">,</span> <span class="token string">"Broad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamNewZeland <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Kane"</span><span class="token punctuation">,</span> <span class="token string">"Nathan"</span><span class="token punctuation">,</span> <span class="token string">"Vettori"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamSouthAfrica <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"AB"</span><span class="token punctuation">,</span> <span class="token string">"Amla"</span><span class="token punctuation">,</span> <span class="token string">"Faf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamWestIndies <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Sammy"</span><span class="token punctuation">,</span> <span class="token string">"Gayle"</span><span class="token punctuation">,</span> <span class="token string">"Narine"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamSriLanka <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Mahela"</span><span class="token punctuation">,</span> <span class="token string">"Sanga"</span><span class="token punctuation">,</span> <span class="token string">"Dilshan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> teamPakistan <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Misbah"</span><span class="token punctuation">,</span> <span class="token string">"Afridi"</span><span class="token punctuation">,</span> <span class="token string">"Shehzad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> playersInWorldCup2016 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamIndia<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamAustralia<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamEngland<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamNewZeland<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamSouthAfrica<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamWestIndies<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamSriLanka<span class="token punctuation">)</span><span class="token punctuation">;</span>
playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>teamPakistan<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// java8之前</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> listOfAllPlayers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> team <span class="token operator">:</span> playersInWorldCup2016<span class="token punctuation">)</span><span class="token punctuation">{</span>
  listOfAllPlayers<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>team<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Players playing in world cup 2016"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listOfAllPlayers<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// java8 使用flatmap</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> flatMapList <span class="token operator">=</span> playersInWorldCup2016<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>pList <span class="token operator">-</span><span class="token operator">></span> pList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"List of all Players using Java 8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flatMapList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
   * 输出结果：
   * Players playing in world cup 2016
   * [Virat, Dhoni, Jadeja, Warner, Watson, Smith, Alex,Bell, Broad, Kane, Nathan, Vettori, AB, Amla, Faf, Sammy, Gayle, Narine, Mahela, Sanga, Dilshan, Misbah, Afridi, Shehzad]
   * List of all Players using Java 8
   * [Virat, Dhoni, Jadeja,Warner, Watson, Smith, Alex, Bell, Broad, Kane, Nathan, Vettori, AB, Amla, Faf, Sammy, Gayle,Narine, Mahela, Sanga, Dilshan, Misbah, Afridi, Shehzad]
   */</span></code></pre>
<h3 id="用例3"><a href="#用例3" class="headerlink" title="用例3"></a>用例3</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>KlassGroup<span class="token operator">></span> groupList <span class="token operator">=</span>
        Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">KlassGroup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Klass</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Klass<span class="token operator">>></span> result <span class="token operator">=</span>
        groupList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it<span class="token punctuation">.</span><span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> result2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>KlassGroup group <span class="token operator">:</span> groupList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result2<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>group<span class="token punctuation">.</span><span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result2 = "</span> <span class="token operator">+</span> result2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> result3 <span class="token operator">=</span>
        groupList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it<span class="token punctuation">.</span><span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result3 = "</span> <span class="token operator">+</span> result3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Klass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> field<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Klass</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>field <span class="token operator">=</span> field<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">"field="</span> <span class="token operator">+</span> field<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">KlassGroup</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">KlassGroup</span><span class="token punctuation">(</span>Klass<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> objList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>Klass item <span class="token operator">:</span> objList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Klass<span class="token operator">></span> <span class="token function">getKlassList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> group<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream中reduce使用</title>
    <url>/posts/801f.html</url>
    <content><![CDATA[<p>reduce方法用于对stream中元素进行聚合求值，最常见的用法就是将stream中一连串的值合成为单个值，比如为一个包含一系列数值的数组求和。</p>
<p>reduce方法有三个重载的方法，方法签名如下：</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">reduce</span><span class="token punctuation">(</span>BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span>
T <span class="token function">reduce</span><span class="token punctuation">(</span>T identity<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>U<span class="token operator">></span> U <span class="token function">reduce</span><span class="token punctuation">(</span>U identity<span class="token punctuation">,</span>
                 BiFunction<span class="token operator">&lt;</span>U<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> U<span class="token operator">></span> accumulator<span class="token punctuation">,</span>
                 BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="第一个签名方法"><a href="#第一个签名方法" class="headerlink" title="第一个签名方法"></a>第一个签名方法</h3><p>接受一个BinaryOperator类型的lambada表达式， 常规应用方法如下：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>代码实现了对numList中的元素累加。lambada表达式的a参数是表达式的执行结果的缓存，也就是表达式这一次的执行结果会被作为下一次执行的参数，而第二个参数b则是依次为stream中每个元素。如果表达式是第一次被执行，a则是stream中的第一个元素。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a="</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">",b="</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在表达式中假如打印参数的代码，打印出来的内容如下：</p>
<pre class=" language-java"><code class="language-java">a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span>
a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span>
a<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">4</span>
a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">5</span></code></pre>
<p>表达式被调用了4次， 第一次a和b分别为stream的第一和第二个元素，因为第一次没有中间结果可以传递， 所以 reduce方法实现为直接将第一个元素作为中间结果传递。</p>
<h3 id="第二个签名方法"><a href="#第二个签名方法" class="headerlink" title="第二个签名方法"></a>第二个签名方法</h3><pre class=" language-java"><code class="language-java">T <span class="token function">reduce</span><span class="token punctuation">(</span>T identity<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>与第一个签名的实现的唯一区别是它首次执行时表达式第一次参数并不是stream的第一个元素，而是通过签名的第一个参数identity来指定。我们来通过这个签名对之前的求和代码进行改进：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>  a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>其实这两种实现几乎差别，第一种比第一种仅仅多了一个字定义初始值罢了。 此外，因为存在stream为空的情况，所以第一种实现并不直接方法计算的结果，而是将计算结果用Optional来包装，我们可以通过它的get方法获得一个Integer类型的结果，而Integer允许null。第二种实现因为允许指定初始值，因此即使stream为空，也不会出现返回结果为null的情况，当stream为空，reduce为直接把初始值返回。</p>
<h3 id="第三个签名方法"><a href="#第三个签名方法" class="headerlink" title="第三个签名方法"></a>第三个签名方法</h3><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>U<span class="token operator">></span> U <span class="token function">reduce</span><span class="token punctuation">(</span>U identity<span class="token punctuation">,</span>
                 BiFunction<span class="token operator">&lt;</span>U<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> U<span class="token operator">></span> accumulator<span class="token punctuation">,</span>
                 BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>第三种签名的用法相较前两种稍显复杂，由于前两种实现有一个缺陷，它们的计算结果必须和stream中的元素类型相同，如上面的代码示例，stream中的类型为int，那么计算结果也必须为int，这导致了灵活性的不足，甚至无法完成某些任务， 比入我们咬对一个一系列int值求和，但是求和的结果用一个int类型已经放不下，必须升级为long类型，此实第三签名就能发挥价值了，它不将执行结果与stream中元素的类型绑死。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>0L<span class="token punctuation">,</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>  a <span class="token operator">+</span> b<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> 0L <span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>如上代码所示，它能见int类型的列表合并成long类型的结果。<br> 当然这只是其中一种应用罢了，由于摆脱了类型的限制我们还可以通过他来灵活的完成许多任务，比入将一个int类型的ArrayList转换成一个String类型的ArrayList。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> numList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"element-"</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>执行结果为：</p>
<pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>element<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> element<span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span></code></pre>
<p>这个示例显得有点鸡肋，一点不实用，不过在这里我们的主要目的是说明代码能达到什么样的效果，因此代码示例也不必取自实际的应用场景。</p>
<p>从上面两个示例可以看出第三个reduce比前面两个强大的多，它的功能已经完全覆盖前面两个的实现，如果我们不考虑代码的简洁性，甚至可以抛弃前面两个。</p>
<p>另外，还需要注意的是这个reduce的签名还包含第三个参数，一个BinaryOperator&lt;U&gt;类型的表达式。在常规情况下我们可以忽略这个参数，敷衍了事的随便指定一个表达式即可，目的是为了通过编译器的检查，因为在常规的stream中它并不会被执行到，然而， 虽然此表达式形同虚设，可是我们也不是把它设置为null，否者还是会报错。 在并行stream中，此表达式则会被执行到，在这里我们不进行讲解，因为我自己也没用过。</p>
<pre><code>numList.parallelStream()</code></pre>
<p>可获得并行stream。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/3eeb.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>kotlin如何实现空安全</title>
    <url>/posts/b698.html</url>
    <content><![CDATA[<ol>
<li><p>通过静态代码检查，编译插件检查，在编译器避免空指针异常</p>
</li>
<li><p>每次引用对象的时候，都去进行对象判空，在运行期间避免对象空指针</p>
</li>
</ol>
<blockquote>
<p>将一个对象的两种类型（可以为空的类型与不可以为空的类型）做一个彻底的分离。如果是不可能为空的对象，在编译期会禁止赋一个null值（编译期避免）；如果是有可能为空的对象，那么在对这个对象进行调用的时候，都会进行的非空判断（运行期避免）。</p>
</blockquote>
<h3 id="可空对象"><a href="#可空对象" class="headerlink" title="可空对象"></a>可空对象</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> a<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> s<span class="token operator">?</span><span class="token punctuation">.</span>length
<span class="token punctuation">}</span></code></pre>
<p>进行反编译，可以看到kotlin生成的class文件中进行了非空判断。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>Metadata<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>NotNull<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Nullable<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Metadata</span><span class="token punctuation">(</span>mv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"\000\020\n\000\n\002\020\016\n\002\b\002\n\002\020\002\n\000\032\020\020\000\032\0020\0012\b\020\002\032\004\030\0010\001\032\006\020\003\032\0020\004\006\005"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"getValue"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">"main"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"my-kotlin"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HelloKt</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String a <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">;</span>
    String str1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@NotNull</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="不可空对象"><a href="#不可空对象" class="headerlink" title="不可空对象"></a>不可空对象</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> a<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">"abc"</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">getValue</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> s<span class="token punctuation">.</span>length
<span class="token punctuation">}</span></code></pre>
<p>进行反编译，可以看到kotlin生成的class文件中直接进行了断言（断言对象不会为null）</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>Metadata<span class="token punctuation">;</span>
<span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>Intrinsics<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>NotNull<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Metadata</span><span class="token punctuation">(</span>mv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> bv <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> d1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"\000\020\n\000\n\002\020\016\n\002\b\002\n\002\020\002\n\000\032\016\020\000\032\0020\0012\006\020\002\032\0020\001\032\006\020\003\032\0020\004\006\005"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"getValue"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">,</span> <span class="token string">"main"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"my-kotlin"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HelloKt</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    String str1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@NotNull</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Intrinsics<span class="token punctuation">.</span><span class="token function">checkNotNullParameter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">"1"</span> <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin泛型</title>
    <url>/posts/3e59.html</url>
    <content><![CDATA[<p>通过<code>where</code>关键字，对泛型参数限定满足所有条件</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Test<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">where</span> T <span class="token operator">:</span> Callback<span class="token punctuation">,</span> T <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">add</span><span class="token punctuation">(</span>t<span class="token operator">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        t<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">open</span> <span class="token keyword">class</span> A <span class="token operator">:</span> Runnable <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> B<span class="token operator">:</span> Callback<span class="token punctuation">,</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"callback"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>


<span class="token keyword">interface</span> Callback <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> test <span class="token operator">=</span> Test<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token comment" spellcheck="true">// val test2 = Test&lt;A>() Type argument is not within its bounds. Expected: Callback</span>
<span class="token punctuation">}</span></code></pre>
<p>kotlin的真泛型</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span>  <span class="token keyword">fun</span>  <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">></span> Gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> T<span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">fromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> T<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本介绍</title>
    <url>/posts/68d3.html</url>
    <content><![CDATA[<h3 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h3><p>据说，第二次世界大战后，美军为了有效管理大量的资料，便把所有的信息都集中在一个基地里，这个集中了所有信息的基地就称为数据库。“数据库”一词便由此诞生。</p>
<p>现在，<code>数据库表示“具有某种数据规则的集合”</code>。但提到数据库时，我们一般都默认它具备对数据进行<code>添加、查询和提取</code>等用于管理数据的功能。所以只是随便收集起来的数据的集合不能称为数据库。只有具备了<code>有效运用这些数据的管理功能</code>，才能称为数据库。</p>
<p>使用最广泛的数据库是<code>关系数据库</code>（Relational DataBase, RDB）。其中，一条数据称为记录（record），各个项目称为列（column）。</p>
<p><code>管理关系数据库的系统称为RDBMS</code>（Relational DataBase Management System）。MySQL也是RDBMS的一种。RDBMS是以IBM公司的埃德加·弗兰克·科德（Edgar F.Codd）与1970年发表的关系数据库相关论文为基础发展起来的。</p>
<h3 id="主流数据库"><a href="#主流数据库" class="headerlink" title="主流数据库"></a>主流数据库</h3><table>
<thead>
<tr>
<th>名称</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>Oracle</td>
<td>世界上最常用的商用RDBMS</td>
</tr>
<tr>
<td>Access</td>
<td>微软公司Office系列的RDBMS</td>
</tr>
<tr>
<td>Microsoft SQL Servier</td>
<td>微软公司的商用RDBMS</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>和MySQL一样是开源的RDBMS，在日本很受欢迎</td>
</tr>
<tr>
<td>MySQL</td>
<td>世界上最常用的开源RDBMS</td>
</tr>
</tbody></table>
<h3 id="MySQL新功能的添加历史"><a href="#MySQL新功能的添加历史" class="headerlink" title="MySQL新功能的添加历史"></a>MySQL新功能的添加历史</h3><table>
<thead>
<tr>
<th>功能</th>
<th>添加该功能时的MySQL版本</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>4.0（从版本3.23.38开始可以使用该功能）</td>
</tr>
<tr>
<td>合并</td>
<td>4.0</td>
</tr>
<tr>
<td>子查询</td>
<td>4.1</td>
</tr>
<tr>
<td>视图</td>
<td>5.0</td>
</tr>
<tr>
<td>存储过程</td>
<td>5.0</td>
</tr>
<tr>
<td>存储函数</td>
<td>5.0</td>
</tr>
<tr>
<td>触发器</td>
<td>5.0</td>
</tr>
<tr>
<td>默认存储引擎变为InnoDB</td>
<td>5.5</td>
</tr>
<tr>
<td>半同步复制</td>
<td>5.5</td>
</tr>
<tr>
<td>无损半同步复制</td>
<td>5.7</td>
</tr>
</tbody></table>
<h3 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h3><p>SQL原本是IBM公司开发的语言，但现在这门语言基本可以在所有的数据库上使用。不过麻烦的是，各个数据库使用的SQL语法稍有不同。</p>
<p>编写查询需要遵循SQL（Structured Query Language）的规则。SQL直译过来就是结构化查询语言，用于对数据库进行操作。<code>SQL是数据库的窗口，充当用户与数据库交互的媒介</code>。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>var与val</title>
    <url>/posts/318f.html</url>
    <content><![CDATA[<h3 id="声明一个变量的完整语法"><a href="#声明一个变量的完整语法" class="headerlink" title="声明一个变量的完整语法"></a>声明一个变量的完整语法</h3><p>var &lt;propertyName&gt;[:&lt;PropertyType&gt;]  [= &lt;property_initializer&gt;]</p>
<p>​        [&lt;gettter&gt;]</p>
<p>​        [&lt;setter&gt;]</p>
<p>变量名：变量类型 = 变量初始值</p>
<p>​    getter</p>
<p>​    setter</p>
<h3 id="var-与-val"><a href="#var-与-val" class="headerlink" title="var 与 val"></a>var 与 val</h3><p>var 与 val 声明的变量，最本质的区别是：val 不能有setter。</p>
<p>var变量的声明：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Hello <span class="token punctuation">{</span>
    <span class="token keyword">var</span> str<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> field <span class="token operator">+</span> <span class="token string">"hello"</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            field <span class="token operator">=</span> value <span class="token operator">+</span> <span class="token string">"set"</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> hello <span class="token operator">=</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>str<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// nullhello </span>

    hello<span class="token punctuation">.</span>str <span class="token operator">=</span> <span class="token string">"world"</span>
    <span class="token function">print</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>str<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// worldsethello</span>
<span class="token punctuation">}</span></code></pre>
<p>val变量的声明：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Hello <span class="token punctuation">{</span>
      <span class="token keyword">val</span> str2<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> field <span class="token operator">+</span> <span class="token string">"hello"</span>
        <span class="token punctuation">}</span>
              <span class="token comment" spellcheck="true">/**
        set(value) { // 编译报错： A 'val'-property cannot have a setter
            field = value + "set"
        } */</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="val-常量"><a href="#val-常量" class="headerlink" title="val == 常量?"></a>val == 常量?</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">var</span> birthYear<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> age<span class="token operator">:</span> Int
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Calendar<span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span> <span class="token operator">-</span> birthYear
        <span class="token punctuation">}</span>

    <span class="token keyword">fun</span> <span class="token function">plusYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        birthYear<span class="token operator">++</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> person <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 20</span>

    person<span class="token punctuation">.</span><span class="token function">plusYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 19</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到，val与常量是不等价的。</p>
<h3 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h3><p>const 只能修饰 object 的属性，或 top-level 变量。</p>
<p>const变量的值必须在编译期间确定下来，所以它的类型只能是String或基本类型。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Perfect</span><span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">/**
    const val  TOP = 1; // 编译报错：Const 'val' are only allowed on top level or in objects
    */</span>
<span class="token punctuation">}</span>

object Perfect<span class="token punctuation">{</span>
    <span class="token keyword">const</span> val  TOP <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Perfect</span> <span class="token punctuation">{</span>
    companion object <span class="token punctuation">{</span>
        <span class="token keyword">const</span> val TOP <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// top-level</span>
<span class="token keyword">const</span> val TOP <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">// OK</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装YApi</title>
    <url>/posts/b5f9.html</url>
    <content><![CDATA[<h3 id="启动MongoDB"><a href="#启动MongoDB" class="headerlink" title="启动MongoDB"></a>启动MongoDB</h3><ol>
<li>默认安装mongo</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker run -d --name mongo-yapi mongo</code></pre>
<ol start="2">
<li>挂载宿主目录安装mongo</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建挂载目录</span>
<span class="token function">mkdir</span> -p /data/yapi/mongodata </code></pre>
<ol start="3">
<li>运行mongo映射主机目录/data/yapi/mongodata</li>
</ol>
<pre><code>docker run --restart always -v /data/yapi/mongodata:/data/db  -d --name mongo-yapi mongo</code></pre>
<h3 id="获取YApi镜像"><a href="#获取YApi镜像" class="headerlink" title="获取YApi镜像"></a>获取YApi镜像</h3><ol>
<li>从阿里云镜像仓库拉取</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi</code></pre>
<ol start="2">
<li>初始化 Yapi 数据库索引及管理员账号</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker run -it --rm --link mongo-yapi:mongo   --entrypoint <span class="token function">npm</span>  --workdir /api/vendors  registry.cn-hangzhou.aliyuncs.com/anoy/yapi   run install-server</code></pre>
<blockquote>
<p>自定义配置文件挂载到目录 <code>/api/config.json</code>，官方自定义配置文件 -&gt; <a href="https://github.com/YMFE/yapi/blob/master/config_example.json">传送门</a></p>
</blockquote>
<ol start="3">
<li>启动 Yapi 服务</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker run -d   --name yapi  --link mongo-yapi:mongo  --workdir /api/vendors   -p 3000:3000   registry.cn-hangzhou.aliyuncs.com/anoy/yapi   server/app.js</code></pre>
<h3 id="使用YApi"><a href="#使用YApi" class="headerlink" title="使用YApi"></a>使用YApi</h3><p>访问 <code>http://localhost:3000</code> 登录账号 <code>admin@admin.com</code>，密码 <code>ymfe.org</code></p>
<p>至此，帅气的 Yapi 就可以轻松使用啦！</p>
<h3 id="其它相关操作"><a href="#其它相关操作" class="headerlink" title="其它相关操作"></a>其它相关操作</h3><ol>
<li>关闭yapi</li>
</ol>
<pre class=" language-bash"><code class="language-bash">docker stop yapi</code></pre>
<ol start="2">
<li>开启yapi</li>
</ol>
<pre><code>docker start yapi</code></pre>
<ol start="3">
<li>升级yapi</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、停止并删除旧版容器</span>
docker <span class="token function">rm</span> -f yapi

<span class="token comment" spellcheck="true"># 2、获取最新镜像</span>
docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi

<span class="token comment" spellcheck="true"># 3、启动新容器</span>
docker run -d  --name yapi  --link mongo-yapi:mongo  --workdir /api/vendors  -p 3000:3000   registry.cn-hangzhou.aliyuncs.com/anoy/yapi   server/app.js</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>YApi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git之前需要做的最小配置</title>
    <url>/posts/5174.html</url>
    <content><![CDATA[<h3 id="配置user-name-和-user-email"><a href="#配置user-name-和-user-email" class="headerlink" title="配置user.name 和 user.email"></a>配置user.name 和 user.email</h3><p>全局配置「对当前用户所有仓库有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --global user.email <span class="token string">"your_email"</span></code></pre>
<p>缺省等同于local「只对某个仓库有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --local user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --local user.email <span class="token string">"your_email"</span></code></pre>
<p>系统配置「对系统所有登录的用户有效」</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --system user.name <span class="token string">"your_name"</span>
$ <span class="token function">git</span> config --system user.email <span class="token string">"your_email"</span></code></pre>
<h3 id="显示config的配置"><a href="#显示config的配置" class="headerlink" title="显示config的配置"></a>显示config的配置</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --list --local
$ <span class="token function">git</span> config --list --global
$ <span class="token function">git</span> config --list --system</code></pre>
<h3 id="查看某一个属性"><a href="#查看某一个属性" class="headerlink" title="查看某一个属性"></a>查看某一个属性</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name</code></pre>
<h3 id="移除设置"><a href="#移除设置" class="headerlink" title="移除设置"></a>移除设置</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --unset --global user.email</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Redis实现任务队列</title>
    <url>/posts/4c47.html</url>
    <content><![CDATA[<h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><p>说到队列很自然就能想到 Redis 的列表类型。如果要实现任务队列，只需要让生产者将任务使用 LPUSH 命令加入到某个键中，另一边让消费者不断地使用 RPOP 命令从该键中取出任务即可。</p>
<p>比如完成发邮件的任务，需要知道收件地址、邮件主题和邮件正文。所以生产者需要将这3个信息组成对象并序列化成字符串，然后将其加入到任务队列中。而消费者则循环从队列中拉取任务，就像如下伪代码：</p>
<pre class=" language-shell"><code class="language-shell"># 无限循环读取任务队列中的内容
loop
 $task = RPOP queue
 if $task
     # 如果任务队列有任务则执行它
     execute($task)
 else 
     # 如果没有则等待 1 秒 以免过于频繁的请求数据
     wait 1 second</code></pre>
<p>到此一个使用 Redis 实现的简单的任务队列就写好了。不过还有一点不完美的地方：当任务队列中没有任务时，消费者都会每秒调用一次 <code>RPOP</code> 命令来查看是否有新任务。如果可以实现一旦有新任务加入任务队列就通知消费者就好了。其实借助 <code>BPOP</code> 命令就可以实现这样的需求。</p>
<p><code>BRPOP</code> 命令与 <code>RPOP</code> 命令相似，唯一的区别是当列表中没有元素时 BRPOP 命令会一直阻塞住连接，知道有新元素接入。如上代码可改写为：</p>
<pre class=" language-shell"><code class="language-shell">loop
    # 如果任务队列没有新任务，BRPOP 命令会一直阻塞，不会执行 execute()。
    $task = BRPOP queue 0
    # 返回值是一个数组，数组第二个元素是我们需要的任务。
    execute($task[1])</code></pre>
<p><code>BRPOP</code> 命令接受两个参数，第一个是键名，第二个是超时时间，单位是秒。当超过了此时间仍然没有获得新元素的话就会返回 nil。超时时间如果设置为 “0”，表示不限制等待的时间，即如果没有新元素加入列表就会永远阻塞下去。</p>
<p>当获得一个元素后 <code>BRPOP</code> 命令返回两个值，分别是键名和元素值。为了测试 <code>BRPOP</code> 命令，我们可以打开两个 redis-cli 实例，在实例 A 中：</p>
<pre class=" language-bash"><code class="language-bash">$ BRPOP queue 0</code></pre>
<p>键入回车后实例 A 会处于阻塞状态，这时在实例 B 中向 queue 中加入一个元素：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH queue task
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>在 <code>LPUSH</code> 命令执行后，实例 A 马上就返回了结果：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"queue"</span>
2<span class="token punctuation">)</span> <span class="token string">"task"</span>
<span class="token punctuation">(</span>27.33s<span class="token punctuation">)</span></code></pre>
<p>同时会发现 queue 中的元素已经被取走：</p>
<pre class=" language-bash"><code class="language-bash">$ LLEN queue
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>除了 <code>BRPOP</code> 命令外，Redis 还提供了 <code>BLPOP</code>，和 <code>BRPOP</code> 的区别在于从队列取元素时 <code>BLPOP</code> 会从队列左边取。</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><code>BLPOP</code> 命令可以同时接受多个键，其完整的命令格式为：</p>
<pre class=" language-bash"><code class="language-bash">$ BLPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span></code></pre>
<p>如果没有键都没有元素则阻塞，如果其中一个键有元素则会从该键中弹出元素。例如打开两个 redis-cli 实例，在实例 A 中：</p>
<pre class=" language-bash"><code class="language-bash">$ BLPOP queue:1 queue:2 queue:3 0</code></pre>
<p>在实例 B 中：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH queue:2 task
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>则在实例 A 中会返回：</p>
<pre class=" language-bash"><code class="language-bash">1<span class="token punctuation">)</span> <span class="token string">"queue:2"</span>
2<span class="token punctuation">)</span> <span class="token string">"task"</span>
<span class="token punctuation">(</span>38.74s<span class="token punctuation">)</span></code></pre>
<p>如果多个键都有元素，则按照从左到右的顺序取第一键的一个元素。我们现在 queue:2  和 queue:3 中各加入一个元素：</p>
<pre class=" language-bash"><code class="language-bash">$ RPUSH queue:2 task1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ RPUSH queue:3 task2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>然后执行 BLPOP 命令</p>
<pre class=" language-bash"><code class="language-bash">$ BLPOP queue:1 queue:2 queue:3 0
1<span class="token punctuation">)</span> <span class="token string">"queue:2"</span>
2<span class="token punctuation">)</span> <span class="token string">"task1"</span></code></pre>
<p>借此特性可以实现区分优先级的任务队列。我们分别使用 <code>queue:confirmation.email</code> 和 <code>queue:notification.email</code> 两个键存储发送确认邮件和发送通知邮件两种任务，然后将消费者的代码改为：</p>
<pre class=" language-shell"><code class="language-shell">loop
    $task =
        BLPOP queue:confirmation.email
              queue:notification.email
              0
    execute($task[1])</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/posts/f609.html</url>
    <content><![CDATA[<p>函数式编程的核心概念如下：</p>
<ul>
<li>头等函数：把函数（一小段行为）当作值使用，可以用变量保存它，把它当作参数传递，或者当作其它函数的返回值。</li>
<li>不可变性：使用不可变对象，这保证了它们的状态在其创建之后不能再变化。</li>
<li>无副作用：使用的是纯函数。此类函数在输入相同时会产生同样的结果，并且不会修改其它对象的状态，也不会和外面的世界交互。</li>
</ul>
<p>优点：</p>
<ol>
<li>简洁</li>
</ol>
<p>函数式风格的代码比相应的命令式风格的代码更优雅、更简练，因为把函数当作值可以让你获得更强大的抽象能力，从而避免重复代码。假设你有两段类似的代码，实现相似的任务（例如，在集合中寻找一个匹配的元素），但具体细节略有不同（如何判断元素式匹配的）。可以轻易地将这段逻辑公共部分提取到一个函数中，并将其它不同的部分作为参数传递给它。这些参数本身也是函数，但你可以使用一种简洁的语法来表示这些匿名函数，它被称作lambda表达式。</p>
<ol start="2">
<li>多线程安全</li>
</ol>
<p>多线程程序中最大的错误来源之一就是，在没有采取适当同步机制的情况下，在不同的线程上修改同一份数据。如果你使用的是不可变数据结构和纯函数，就能保证这样不安全的修改根本不会发生，也就不需要考虑为其设计股灾的同步方案。</p>
<ol start="3">
<li>易测试性</li>
</ol>
<p>没有副作用的函数可以独立地进行测试，因为不需要写大量的设置代码来构造它们所依赖的整个环境。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收 Spring Bean</title>
    <url>/posts/581e.html</url>
    <content><![CDATA[<p>Bean垃圾回收（GC）</p>
<ul>
<li>关闭Spring 容器（应用上下文）</li>
<li>执行GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Disposable#destroy() : Employee 销毁中... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前对象 Employee 对象正在被回收..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略setter getter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanGarbageCollectionDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class 配置类</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanGarbageCollectionDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 强制出发 GC</span>
    System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    Disposable#destroy() : Employee 销毁中... 
    当前对象 Employee 对象正在被回收... */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>实例化Spring Bean</title>
    <url>/posts/b731.html</url>
    <content><![CDATA[<h3 id="常规的四种方式"><a href="#常规的四种方式" class="headerlink" title="常规的四种方式"></a>常规的四种方式</h3><h4 id="通过构造器"><a href="#通过构造器" class="headerlink" title="通过构造器"></a>通过构造器</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：com.asia.User@4dfa3a9d */</span></code></pre>
<p>如果添加私有（<code>private</code>）无参构造函数或添加带参构造函数时，IoC容器启动时，因无法调用到该类的公共无参构造函数，会导致IoC容器初始化失败，并抛出<code>NoSuchMethodException</code>，因为这是一个致命问题。类似的报错信息提示如下：</p>
<blockquote>
<p>Failed to instantiate [com.asia.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.asia.User.&lt;init&gt;()</p>
</blockquote>
<h4 id="通过静态工厂方法"><a href="#通过静态工厂方法" class="headerlink" title="通过静态工厂方法"></a>通过静态工厂方法</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
     <span class="token comment" spellcheck="true">&lt;!--    静态方法实例化 Bean--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user-by-static-method<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.User<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>createUser<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> User <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>
                <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>
                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
                <span class="token string">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user-by-static-method"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过Bean工厂方法"><a href="#通过Bean工厂方法" class="headerlink" title="通过Bean工厂方法"></a>通过Bean工厂方法</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!--    实例方法实例化 Bean--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user-by-instance-method<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>createUser<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.factory.DefaultFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/** 去掉了static */</span>
  <span class="token keyword">public</span> User <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span> <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span> <span class="token string">'}'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserFactory</span> <span class="token punctuation">{</span>
  <span class="token keyword">default</span> User <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFactory</span> <span class="token keyword">implements</span> <span class="token class-name">UserFactory</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user-by-instance-method"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过FactoryBean"><a href="#通过FactoryBean" class="headerlink" title="通过FactoryBean"></a>通过FactoryBean</h4><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token comment" spellcheck="true">&lt;!--    FactoryBean实例化 Bean--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user-by-factory-bean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.factory.UserFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> User <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token keyword">return</span> User<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"classpath:/META-INF/my-spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    User user <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user-by-factory-bean"</span><span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="特殊的三种方式"><a href="#特殊的三种方式" class="headerlink" title="特殊的三种方式"></a>特殊的三种方式</h3><h4 id="通过ServiceLoaderFactoryBean"><a href="#通过ServiceLoaderFactoryBean" class="headerlink" title="通过ServiceLoaderFactoryBean"></a>通过ServiceLoaderFactoryBean</h4><ol>
<li>创建META-INF/Services文件夹</li>
<li>在这个文件夹下面创建一个文件，文件名是接口的全类名</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/Snipaste_2021-01-16_09-25-59.png"></p>
<ol start="3">
<li>把这个接口的实现类逐一的写入这个文件中，不要写id，只需要类名</li>
</ol>
<pre><code>com.asia.factory.DefaultFactory</code></pre>
<p>使用方式一：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">demoServiceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demoServiceLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ServiceLoader<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> serviceLoader <span class="token operator">=</span>
        ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>UserFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> iterator <span class="token operator">=</span> serviceLoader<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      UserFactory userFactory <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果 User{age=27, name='AsiaMa'} */</span></code></pre>
<p>使用方式二：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userFactoryServiceLoader<span class="token punctuation">"</span></span>
          <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>serviceType<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.factory.UserFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory beanFactory <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>
            <span class="token string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    ServiceLoader<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> userFactoryServiceLoader <span class="token operator">=</span>
        beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userFactoryServiceLoader"</span><span class="token punctuation">,</span> ServiceLoader<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">displayServiceLoader</span><span class="token punctuation">(</span>userFactoryServiceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayServiceLoader</span><span class="token punctuation">(</span>ServiceLoader<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> serviceLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Iterator<span class="token operator">&lt;</span>UserFactory<span class="token operator">></span> iterator <span class="token operator">=</span> serviceLoader<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      UserFactory userFactory <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果 User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过AutowireCapableBeanFactory"><a href="#通过AutowireCapableBeanFactory" class="headerlink" title="通过AutowireCapableBeanFactory"></a>通过AutowireCapableBeanFactory</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    ApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>
            <span class="token string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 通过 Application 获取 AutowireCapableBeanFactory</span>
    AutowireCapableBeanFactory beanFactory <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getAutowireCapableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建 UserFactory 对象， 通过 AutowireCapableBeanFactory</span>
    UserFactory userFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">createBean</span><span class="token punctuation">(</span>DefaultFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userFactory<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果 User{age=27, name='AsiaMa'} */</span></code></pre>
<h4 id="通过BeanDefinitionRegistry"><a href="#通过BeanDefinitionRegistry" class="headerlink" title="通过BeanDefinitionRegistry"></a>通过BeanDefinitionRegistry</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpecialBeanInstantiationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    GenericXmlApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericXmlApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 通过BeanDefinition注册API实现</span>
    <span class="token comment" spellcheck="true">// 命名Bean的注册方式</span>
    <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">,</span> <span class="token string">"asia-user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非命名Bean的注册方式</span>
    <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>
            <span class="token string">"User 类型的所有beans"</span> <span class="token operator">+</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanDefinitionBuilder beanDefinitionBuilder <span class="token operator">=</span>
            BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">addPropertyValue</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">addPropertyValue</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"AsiaMa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 判断如果BeanName参数存在时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 注册BeanDefinition</span>
      registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      BeanDefinitionReaderUtils<span class="token punctuation">.</span><span class="token function">registerWithGeneratedName</span><span class="token punctuation">(</span>
              beanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">registerUserBeanDefinition</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User 类型的所有beans{
            asia-user=User{age=27, name='AsiaMa'}, 
            com.asia.User#0=User{age=27, name='AsiaMa'}} */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>层次性依赖查找</title>
    <url>/posts/e798.html</url>
    <content><![CDATA[<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>superUser<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.domain.SuperUser<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">primary</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>北京<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.domain.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>金士顿快乐健康<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>objectFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>targetBeanName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperUser</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HierarchicalDependencyLookupDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册配置类</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>HierarchicalDependencyLookupDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// ConfigurableListableBeanFactory -> ConfigurableBeanFactory -> HierarchicalBeanFactory</span>
    ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 设置 Parent BeanFactory</span>
    DefaultListableBeanFactory parentBeanFactory <span class="token operator">=</span> <span class="token function">createBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    beanFactory<span class="token punctuation">.</span><span class="token function">setParentBeanFactory</span><span class="token punctuation">(</span>parentBeanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">displayLocalBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">displayLocalBean</span><span class="token punctuation">(</span>parentBeanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">displayContainsBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">displayContainsBean</span><span class="token punctuation">(</span>parentBeanFactory<span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayContainsBean</span><span class="token punctuation">(</span>HierarchicalBeanFactory beanFactory<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>
        <span class="token string">"当前 BeanFactory 是否包含 bean [name : %s] : %s \n"</span><span class="token punctuation">,</span>
        beanName<span class="token punctuation">,</span> <span class="token function">containsBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">containsBean</span><span class="token punctuation">(</span>HierarchicalBeanFactory beanFactory<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BeanFactory parentBeanFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getParentBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentBeanFactory <span class="token keyword">instanceof</span> <span class="token class-name">HierarchicalBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      HierarchicalBeanFactory parentHierarchicalBeanFactory <span class="token operator">=</span>
          <span class="token punctuation">(</span>HierarchicalBeanFactory<span class="token punctuation">)</span> parentBeanFactory<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token function">containsBean</span><span class="token punctuation">(</span>parentHierarchicalBeanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">containsLocalBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayLocalBean</span><span class="token punctuation">(</span>HierarchicalBeanFactory beanFactory<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>
        <span class="token string">"当前 BeanFactory 是否包含 Local bean [name : %s] : %s \n"</span><span class="token punctuation">,</span>
        beanName<span class="token punctuation">,</span> beanFactory<span class="token punctuation">.</span><span class="token function">containsLocalBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> DefaultListableBeanFactory <span class="token function">createBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    DefaultListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    XmlBeanDefinitionReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XmlBeanDefinitionReader</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// XML 配置文件 ClassPath 路径</span>
    String location <span class="token operator">=</span> <span class="token string">"classpath:/META-INF/dependency-lookup-context.xml"</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 加载配置</span>
    reader<span class="token punctuation">.</span><span class="token function">loadBeanDefinitions</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> beanFactory<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    当前 BeanFactory 是否包含 Local bean [name : user] : false 
    当前 BeanFactory 是否包含 Local bean [name : user] : true 
    当前 BeanFactory 是否包含 bean [name : user] : true 
    当前 BeanFactory 是否包含 bean [name : user] : true */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin常用作用域函数</title>
    <url>/posts/c396.html</url>
    <content><![CDATA[<h3 id="let-和-run"><a href="#let-和-run" class="headerlink" title="let 和 run"></a>let 和 run</h3><p>let 和 run 都会返回闭包的执行结果，区别在于let有闭包参数，而run没有闭包参数。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> letResult<span class="token operator">:</span> String <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> user<span class="token operator">:</span> User <span class="token operator">-></span>
        <span class="token string">"let:: <span class="token interpolation"><span class="token delimiter variable">${</span>user<span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span>
    <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">/** 
         简化写法
         val letResult: String = user.let {
        "let:: ${it.javaClass.simpleName}"
    } 
   */</span>

    <span class="token function">println</span><span class="token punctuation">(</span>letResult<span class="token punctuation">)</span>

    <span class="token keyword">val</span> runResult <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">run</span> <span class="token punctuation">{</span>
        <span class="token string">"run:: <span class="token interpolation"><span class="token delimiter variable">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span>runResult<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/** 输出结果：let:: User
                         run:: User */</span></code></pre>
<h3 id="also-和-apply"><a href="#also-和-apply" class="headerlink" title="also 和 apply"></a>also 和 apply</h3><p>also与apply都不返回闭包的执行结果，区别在于also有闭包参数，而apply没有闭包参数。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    user<span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"also::<span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    user<span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"apply::<span class="token interpolation"><span class="token delimiter variable">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 在这个例子中，also 和 apply 会继续返回user这个对象，因为我们可以这么使用</span>
        user<span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"also::<span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"apply::<span class="token interpolation"><span class="token delimiter variable">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>javaClass<span class="token punctuation">.</span>simpleName<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Bob"</span>

    <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">/** 输出结果：User(name=Bob) */</span></code></pre>
<h3 id="takeIf-和-takeUnless"><a href="#takeIf-和-takeUnless" class="headerlink" title="takeIf 和 takeUnless"></a>takeIf 和 takeUnless</h3><p>takeIf 的闭包返回一个判断结果，为false时，takeIf函数会返回空。</p>
<p>takeUnless 与 takeIf 刚好相反，闭包的判断结果，为true时函数会返回空。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    user<span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{</span>
        it<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为: <span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?:</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为空"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：姓名为: AsiaMa */</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    user<span class="token punctuation">.</span><span class="token function">takeUnless</span> <span class="token punctuation">{</span>
        it<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为: <span class="token interpolation"><span class="token delimiter variable">${</span>it<span class="token punctuation">.</span>name<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token operator">?:</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名为空"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：姓名为: AsiaMa */</span></code></pre>
<h3 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h3><p>重复执行当前闭包</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/**
输出结果：
    AsiaMa0
    AsiaMa1
    AsiaMa2
    AsiaMa3
    AsiaMa4
*/</span></code></pre>
<h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><p>with比较特殊，不是以扩展方法的形式存在，而是一个顶级函数。可用于对象的通用属性赋值。</p>
<pre class=" language-java"><code class="language-java">fun <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    val user <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token string">"AsiaMa"</span><span class="token punctuation">)</span>

    <span class="token function">with</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Tom"</span>
    <span class="token punctuation">}</span>
    <span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>

  <span class="token comment" spellcheck="true">/** 与with相似    
    user.apply {
        this.name = "Rose"
    }
  */</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：User(name=Tom) */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟初始化 Spring Bean</title>
    <url>/posts/861c.html</url>
    <content><![CDATA[<h3 id="Bean延迟初始化-（Lazy-Initialization）"><a href="#Bean延迟初始化-（Lazy-Initialization）" class="headerlink" title="Bean延迟初始化 （Lazy Initialization）"></a>Bean延迟初始化 （Lazy Initialization）</h3><ul>
<li>XML配置：&lt;bean lazy-init=”true”&gt;</li>
<li>Java注解：@Lazy(true)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略 getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册Configuration Class (配置类)</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非延迟初始化在 Spring 应用上下文启动完成后，被初始化</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Spring 应用上下文已启动..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Employee employee <span class="token operator">=</span> annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>employee<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token annotation punctuation">@Lazy</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    Spring 应用上下文已启动...
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    com.asia.Employee@19dc67c2 */</span>

<span class="token comment" spellcheck="true">//非延迟初始化 @Lazy(value = false)</span>
    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
  <span class="token annotation punctuation">@Lazy</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    Spring 应用上下文已启动...
    com.asia.Employee@19dc67c2 */</span></code></pre>
<p>其实延迟加载和非延迟加载在定义的时候，也就是Bean注册的时候是没有区别的，按照你的需要来注册，但是在依赖查找和依赖注入的时候，它的区别就体现出来了。非延迟查找是在上下文初始化完成之前，就已经初始化了；延迟加载必须在上下文初始化完成之后来进行加载。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>探讨复杂的 if-else 语句“优雅处理”的思路</title>
    <url>/posts/afc9.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际开发中，往往不是简单 if-else 结构，我们通常会不经意间写下如下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// -------------------- 理想中的 if-else  --------------------</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isWeekend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"玩游戏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上班!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// -------------------- 现实中的 if-else  --------------------</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黄金会员 8折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> money <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白金会员 优惠50元，再打7折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> <span class="token punctuation">(</span>money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//省略 n 个 if-else ......</span></code></pre>
<p>毫不夸张的说，我们都写过类似的代码，回想起被 if-else 支配的恐惧，我们常常无所下手，甚至不了了之。</p>
<p>下面分享一下我遇到复杂的 if-else 语句“优雅处理”思路。如有不妥，欢迎大家一起交流学习。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>假设有这么一个需求：</p>
<p>一个电商系统，当用户消费满1000 金额，可以根据用户VIP等级，享受打折优惠。根据用户VIP等级，计算出用户最终的费用。</p>
<ul>
<li>普通会员 不打折</li>
<li>白银会员 优惠50元</li>
<li>黄金会员 8折</li>
<li>白金会员 优惠50元，再打7折</li>
</ul>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> result <span class="token operator">=</span> money<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黄金会员 8折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> money <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白金会员 优惠50元，再打7折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> <span class="token punctuation">(</span>money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result <span class="token operator">=</span> money<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>为了方便演示，代码上我进行了简单实现，但实际上 if - else 会进行复杂的逻辑计费。从功能上来说，基本完成，但是对于我这种有代码洁癖的人来说，代码质量上不忍直视。我们开始着手 优化一下我们的第一版代码吧。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>看到如上代码，聪明的朋友首先想到的是，这不是典型的策略模式吗？</p>
<p>你可真是个机灵鬼，我们先尝试用策略模式来优化一下代码吧。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>可能有的朋友还不清楚，什么是策略模式。策略模式是定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p>比如上述需求，有返利、有打折、有折上折等等。这些算法本身就是一种策略。并且这些算法可以相互替换的，比如今天我想让 白银会员优惠50，明天可以替换为 白银会员打9折。</p>
<p>说了那么多，不如编码来得实在。</p>
</blockquote>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 计费方法</span>
    <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 普通会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrdinaryStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 白银会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SilverStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 黄金会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GoldStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span><span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"黄金会员 8折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 白金会员策略</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlatinumStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白金会员 优惠50元，再打7折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>我们定义来一个 Strategy 接口，并且定义 四个子类，实现接口。在对应的 compute方法 实现自身策略的计费逻辑。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> result <span class="token operator">=</span> money<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SilverStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GoldStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlatinumStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrdinaryStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>然后对应 getResult 方法，根据 type 替换为对应的 用户VIP 策略。这里代码上出现了重复的调用 compute ，我们可以尝试进一步优化</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Strategy strategy<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SilverStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>GOLD_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GoldStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> UserType<span class="token punctuation">.</span>PLATINUM_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlatinumStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrdinaryStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们在这里把 money &lt; 1000 的情况提前 return。更关注于满1000逻辑 ,也可以减少不必要的缩进。</p>
<h3 id="深思"><a href="#深思" class="headerlink" title="深思"></a>深思</h3><p>我曾一度 以为 策略模式不过如此。以为代码优化到这已经可以了。</p>
<p>但是还有一个恐怖的事情，if-else 依然存在 ：）</p>
<p>我尝试翻阅了许多书籍，查看如何消除 策略模式中的 if-else</p>
<p>书中大部分的方法是，使用简单工厂 + 策略模式。把 if - else 切换为 switch 创建一个工厂方法而已。</p>
<p>但是这远远没有达到我想要的效果，打倒 if - else</p>
<p>直到某一天夜里，我大佬在群里分享一个 Java8 小技巧时，从此打开新世界。</p>
<h3 id="工厂-策略"><a href="#工厂-策略" class="headerlink" title="工厂 + 策略"></a>工厂 + 策略</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 返回 type</span>
    <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrdinaryStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通会员 不打折"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 添加 type 返回</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SilverStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"白银会员 优惠50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> money <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// type 返回</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> UserType<span class="token punctuation">.</span>SILVER_VIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//....省略剩下 Strategy</span></code></pre>
<p>我们先在 Strategy 新增一个 getType 方法，用来表示 该策略的 type 值。代码相对简单，这里就不过多介绍了</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyFactory</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Strategy<span class="token operator">></span> map<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">StrategyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        List<span class="token operator">&lt;</span>Strategy<span class="token operator">></span> strategies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OrdinaryStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SilverStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GoldStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        strategies<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PlatinumStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 看这里 看这里 看这里！</span>
        map <span class="token operator">=</span> strategies<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>Strategy<span class="token operator">:</span><span class="token operator">:</span>getType<span class="token punctuation">,</span> strategy <span class="token operator">-</span><span class="token operator">></span> strategy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* 等同上面
        map = new HashMap&lt;>();
        for (Strategy strategy : strategies) {
            map.put(strategy.getType(), strategy);
        }*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> StrategyFactory instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StrategyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> StrategyFactory <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Holder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Strategy <span class="token function">get</span><span class="token punctuation">(</span>Integer type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>静态内部类单例，单例模式实现的一种，不是本文重点，如不了解，可以自行 google</p>
<p>我们再着手创建一个 StrategyFactory 工厂类。StrategyFactory 这里我使用的是静态内部类单例，在构造方法的时候，初始化好 需要的 Strategy，并把 list 转化为 map。</p>
<p>这里 转化就是“灵魂”所在。</p>
<h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><p>我们先来看看 Java8 语法中的小技巧。通常情况下，我们遍历 List，手动put到 Map 中。</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>  before <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Strategy strategy <span class="token operator">:</span> strategies<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>strategy<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>  after Java8 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

map <span class="token operator">=</span> strategies<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>Strategy<span class="token operator">:</span><span class="token operator">:</span>getType<span class="token punctuation">,</span> strategy <span class="token operator">-</span><span class="token operator">></span> strategy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>toMap 第一个参数是一个Function，对应 Map 中的 key，第二个参数也是一个Function，strategy -&gt; strategy， 左边strategy 是遍历 strategies 中的每一个strategy，右边strategy则是 Map 对应 value 值。</p>
<p>若是不了解 Java8 语法的朋友，强烈建议看 《Java8 实战》，书中详细的介绍了 Lambda表达式、Stream等语法。</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token keyword">long</span> money<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>money <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Strategy strategy <span class="token operator">=</span> StrategyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>strategy <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"please input right type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>至此，通过一个工厂类，在我们在 getResult（）调用的时候，根据传入 type，即可获取到 对应 Strategy</p>
<p>再也没有可怕的 if-else 语句。</p>
<p>完结撒花撒花 : )</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续代码优化上，若是 Java 项目，可以尝试使用自定义注解，注解 Strategy 实现类。</p>
<p>这样可以简化原来需在工厂类 List 添加一个 Stratey 策略。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略</tag>
        <tag>工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义中缀表达式</title>
    <url>/posts/8a52.html</url>
    <content><![CDATA[<p>一个函数只有用与两个角色类似的对象时才将其声明为中缀函数。</p>
<p>推荐示例：and、to、zip        反例：add</p>
<p>如果一个方法会改动其接受者，那么不要声明为中缀形式。</p>
<p>定义自己的中缀表达式：</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">sealed</span> <span class="token keyword">class</span> CompareResult <span class="token punctuation">{</span>
    <span class="token keyword">object</span> LESS <span class="token operator">:</span> <span class="token function">CompareResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"小于"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">object</span> MORE <span class="token operator">:</span> <span class="token function">CompareResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"大于"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">object</span> EQUAL <span class="token operator">:</span> <span class="token function">CompareResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"等于"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

infix <span class="token keyword">fun</span> Int<span class="token punctuation">.</span><span class="token function">vs</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> CompareResult <span class="token operator">=</span>
    <span class="token keyword">when</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span> <span class="token operator">-</span> num <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
            CompareResult<span class="token punctuation">.</span>MORE
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span> <span class="token operator">-</span> num <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
            CompareResult<span class="token punctuation">.</span>LESS
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token operator">-></span> <span class="token punctuation">{</span>
            CompareResult<span class="token punctuation">.</span>EQUAL
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token number">5</span> vs <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：小于 */</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin自定义操作符</title>
    <url>/posts/8051.html</url>
    <content><![CDATA[<h3 id="自定义Convert操作符"><a href="#自定义Convert操作符" class="headerlink" title="自定义Convert操作符"></a>自定义Convert操作符</h3><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">myOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">myOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list<span class="token operator">:</span> List<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
    list<span class="token punctuation">.</span><span class="token function">covert</span> <span class="token punctuation">{</span>
        it <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> E<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">covert</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> E<span class="token punctuation">)</span><span class="token operator">:</span> Iterable<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> T <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">action</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> list
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：23456 */</span></code></pre>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>在最近的这个项目中，需要导出Excel，产品经理希望导出的时候在每一行的行首都增加一个行号，从1开始，这个时候自定义集合操作符就派上用场了。</p>
<pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// rowIndex 导出excel时使用</span>
<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">var</span> rowIndex<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> u1 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"AsiaMa"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> u2 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Xiu"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> u3 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Ghost"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> u4 <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Lost"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> userList <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span>u1<span class="token punctuation">,</span> u2<span class="token punctuation">,</span> u3<span class="token punctuation">,</span> u4<span class="token punctuation">)</span>
    userList<span class="token punctuation">.</span><span class="token function">covert</span> <span class="token punctuation">{</span>
        it
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">inline</span> <span class="token keyword">fun</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">covert</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> <span class="token operator">-></span> User<span class="token punctuation">)</span><span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">,</span> item<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">withIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 设置行号</span>
        <span class="token function">action</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">.</span>rowIndex <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">action</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 
    输出结果：
        User(rowIndex=1, name=AsiaMa, age=23)
        User(rowIndex=2, name=Xiu, age=30)
        User(rowIndex=3, name=Ghost, age=11)
        User(rowIndex=4, name=Lost, age=16) 
*/</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第一天</title>
    <url>/posts/56b.html</url>
    <content><![CDATA[<h2 id="五种基本句型"><a href="#五种基本句型" class="headerlink" title="五种基本句型"></a>五种基本句型</h2><p>主语：动作的发起者，位于句首。</p>
<p>谓语：核心部分，一定是动词，紧跟在主语之后。</p>
<p>宾语：动作的承受者。</p>
<p>连续动词：不能组成一个完整的意思，没有实际意义，一般是be动词。</p>
<p>表语：对主语的修饰、描述。</p>
<p>宾语补语：对宾语的修饰、描述。</p>
<h3 id="主-连系动词-表语"><a href="#主-连系动词-表语" class="headerlink" title="主+连系动词+表语"></a>主+连系动词+表语</h3><ul>
<li>I am cold.</li>
<li>The food is delicious.</li>
<li>We are friends.</li>
<li>Make is a nice person.</li>
</ul>
<h3 id="主-谓"><a href="#主-谓" class="headerlink" title="主+谓"></a>主+谓</h3><ul>
<li>He died.</li>
<li>He smiled.</li>
<li>He cried.</li>
</ul>
<h3 id="主-谓-宾"><a href="#主-谓-宾" class="headerlink" title="主+谓+宾"></a>主+谓+宾</h3><ul>
<li>I visited him.</li>
<li>He killed a bear.</li>
<li>We love her.</li>
</ul>
<h3 id="主-谓-双宾"><a href="#主-谓-双宾" class="headerlink" title="主+谓+双宾"></a>主+谓+双宾</h3><ul>
<li>My father bought me a car.</li>
<li>Mary give me an apple.</li>
<li>He wrote her a letter.</li>
</ul>
<h3 id="主-谓-宾-宾语补语"><a href="#主-谓-宾-宾语补语" class="headerlink" title="主+谓+宾+宾语补语"></a>主+谓+宾+宾语补语</h3><ul>
<li>They named him Jamie.</li>
<li>She makes me laugh.</li>
<li>I painted the wall white.</li>
<li>She pushed the door open.</li>
<li>He asked me to call Tom.</li>
<li>I wish you to be happy.</li>
</ul>
<h2 id="人称代词"><a href="#人称代词" class="headerlink" title="人称代词"></a>人称代词</h2><h3 id="主格"><a href="#主格" class="headerlink" title="主格"></a>主格</h3><table>
<thead>
<tr>
<th></th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody><tr>
<td>第一人称</td>
<td>i</td>
<td>we</td>
</tr>
<tr>
<td>第二人称</td>
<td>you</td>
<td>you</td>
</tr>
<tr>
<td>第三人称</td>
<td>he/she/it</td>
<td>they</td>
</tr>
</tbody></table>
<h3 id="宾格"><a href="#宾格" class="headerlink" title="宾格"></a>宾格</h3><table>
<thead>
<tr>
<th></th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody><tr>
<td>第一人称</td>
<td>me</td>
<td>us</td>
</tr>
<tr>
<td>第二人称</td>
<td>you</td>
<td>you</td>
</tr>
<tr>
<td>第三人称</td>
<td>him/her/it</td>
<td>them</td>
</tr>
</tbody></table>
<h2 id="定语和状语"><a href="#定语和状语" class="headerlink" title="定语和状语"></a>定语和状语</h2><p>定语：主要增加修饰名词的细节。对名词起修饰限定作用，主要是形容词。</p>
<ul>
<li>She is a beautiful girl.</li>
<li>She is a tall and thin server-year-old girl.</li>
</ul>
<p>状语：主要增加动词的细节。表示方式，程度，时间，地点，原因，目的…可以修饰动词，形容词和副词。</p>
<ul>
<li>He woke up at midnight.（时间状语）</li>
<li>Tim studied at home.（地点状语）</li>
<li>She talk loudy.（方式状语）</li>
<li>He walks in a funny way.</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第三天</title>
    <url>/posts/9968.html</url>
    <content><![CDATA[<h3 id="动名词作主语"><a href="#动名词作主语" class="headerlink" title="动名词作主语"></a>动名词作主语</h3><ul>
<li>Eating an apple a day keeps you healthy.</li>
<li>Running five miles is the first thing he does in the morning.</li>
</ul>
<h3 id="不定式作主语"><a href="#不定式作主语" class="headerlink" title="不定式作主语"></a>不定式作主语</h3><ul>
<li>To study abroad is my greatest desire.</li>
<li>To travel around the world is my plan for this year.</li>
</ul>
<p>动名词作主语不讨论这件事做或没做。不定式做主语，这件事情还没有做。</p>
<p>动词要做主语，不能用原词。可以用动名词，也可以用不定式。如果是不定式，这个动作要没做才可以。</p>
<blockquote>
<p>不定式和动名词作主语时，常出现主语过长的情况，可以用代词it代替，作形式主语放在句首，而把真正的主语，即不定式或动名词短语放在句尾。动名词移至句尾时，常改为不定式。</p>
</blockquote>
<p>Collecting stamps is one of his hobbies.</p>
<p><code>It</code> is one of his hobbies <code>to collect stamps</code>.</p>
<p>Eating an apple a day keeps you healthy.</p>
<p><code>It</code> keeps you healthy <code>to eat an appale</code>.</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>hear from 收到….的信</p>
<p>hear sb do sth 听见某人做某事 </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第二天</title>
    <url>/posts/9511.html</url>
    <content><![CDATA[<h3 id="为什么会有五种句型"><a href="#为什么会有五种句型" class="headerlink" title="为什么会有五种句型"></a>为什么会有五种句型</h3><p>这个句子有没有动词，没有动作就一般是主系表。如果有一个动作，我们把这个动作视为核心动词「谓语动词」。根据这个动词的种类不一样，这个动作涉及到别的对象呢，还是自己就能完成。涉及到别人是涉及到一个对象还是两个对象呢？这样子会划分为四种不同的类型。</p>
<p>定状语：状语增加动作的细节。定语增加名词的细节。动作是什么，怎么做出来的，在哪里做的，目的是什么。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>She bought a new bag.        <code>she</code> 主语    <code>bought</code> 谓语     <code>a new bag</code> 宾语；名词词组，冠词+形容词+名词=名词。</p>
<p>I am happy.         <code>i</code> 主语     <code>am</code> 连系动词     <code>happy</code> 表语</p>
<p>We love music.        <code>we</code> 主语     <code>love</code>谓语     <code>music</code> 宾语</p>
<p>We love swimming.         <code>we</code>主语     <code>love</code>谓语     <code>swimming</code>宾语</p>
<p>We love eating hotpot.         <code>we</code> 主语     <code>love</code>谓语     <code> eating hotpot</code>宾语（吃火锅视为一件事情）</p>
<p>He made me sad.         <code>He</code>主语     <code>made</code>谓语     <code>me</code>宾语    <code>sad</code>宾补</p>
<p>They invited me to dance.        <code>they</code>主语    <code>invited</code>谓语    <code>me</code>宾语    <code>to dance</code>宾补</p>
<p>My brother passed me the salt.    <code>my brother</code>主语    <code>passed</code>谓语    <code>me</code>宾语     <code>the salt</code>宾语</p>
<p>He sighed deeply.    <code>He</code> 主语    <code>sighed</code>谓语     <code>deeply</code>状语  叹气是不及物动词，涉及不到别人的动作。</p>
<p>He asked me to help him.    <code>He</code>主语    <code>asked</code>谓语    <code>me</code>宾语    <code>to help him</code>宾补</p>
<p>I worry about him.    <code>i</code>主语    <code>worry about</code>谓语    <code>him</code>宾语</p>
<p>He is looking at you.    <code>he</code>主语    <code>is looking at</code>谓语    <code>you</code>宾语</p>
<p>Playing basketball is my biggest time.    <code>playing basketball</code>主语    <code>is</code>系动词    <code>my biggest time</code>表语</p>
<p>He told me a joke.    <code>he</code>主语    <code>told</code>谓语    <code>me</code>宾语    <code>a joke</code>宾语</p>
<h3 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h3><p>动作的发出者，或者描述的对象。一般在开头。</p>
<ol>
<li>名词<ul>
<li>Pineapple is a kind of tropical fruit. <code>a kind of tropica</code>定语，意群。</li>
<li>Success requires persistence.</li>
<li>Monday is a workday.</li>
<li>A good night’s sleep is the best rest.</li>
</ul>
</li>
<li>代词</li>
<li>动名词</li>
<li>不定式</li>
<li>主语从句</li>
</ol>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ol>
<li>Hotpot  [ˈhɒtpɒt]    火锅</li>
<li>Invited  [ɪnˈvaɪtɪd]  邀请</li>
<li>Pepper [ˈpepər]  胡椒粉</li>
<li>Shaker  [ˈʃeɪkər] 振动器；混和器；调酒器</li>
<li>sighed  叹息</li>
<li>Pastime  [ˈpæstaɪm]  娱乐，消遣</li>
<li>Persistence   [pərˈsɪstəns]  坚持不懈；毅力 </li>
<li>Pineapple  [ˈpaɪnæpl]  菠萝</li>
<li>tropical  [ˈtrɑːpɪkl]  热带的</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第五天</title>
    <url>/posts/3517.html</url>
    <content><![CDATA[<h3 id="名词作宾语"><a href="#名词作宾语" class="headerlink" title="名词作宾语"></a>名词作宾语</h3><p>When you’re the bos s, you can make up your own rules.</p>
<p>She loves her Snow White costume.</p>
<p>她喜欢她的白雪公主戏服。</p>
<h3 id="代词作宾语"><a href="#代词作宾语" class="headerlink" title="代词作宾语"></a>代词作宾语</h3><p>I didn’t notice him.</p>
<p>Thomas brags about this every single day.</p>
<p>I forgive you.</p>
<h3 id="动名词作宾语"><a href="#动名词作宾语" class="headerlink" title="动名词作宾语"></a>动名词作宾语</h3><p>I hate riding bicycle.</p>
<p>I can’t imagine going on a date with him.</p>
<h3 id="不定式作宾语"><a href="#不定式作宾语" class="headerlink" title="不定式作宾语"></a>不定式作宾语</h3><p>I want to see him now.</p>
<p>I like to go swimming on a hot day like this.</p>
<h3 id="it-作形式宾语"><a href="#it-作形式宾语" class="headerlink" title="it 作形式宾语"></a>it 作形式宾语</h3><p>She found it difficult to convince him.</p>
<p>He made it a rule to do an hour’s work in the garden every day.</p>
<h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><ul>
<li>that</li>
</ul>
<p>I think that we should cooperate.</p>
<p>They feel that it’s impossible to win the game.</p>
<ul>
<li>whether</li>
</ul>
<p>I wonder whether he can do it.</p>
<p>I don’t know whether the typhoon will come.</p>
<ul>
<li>特殊疑问词</li>
</ul>
<p>I don’t believe what he said.</p>
<p>I forget where he lives.</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>forbid [fərˈbɪd]] 禁止</p>
<p>ban [bæn] 禁止</p>
<p>dessert [dɪˈzɜːrt] 餐后甜点</p>
<p>costume [ˈkɑːstuːm] 服装</p>
<p>cooperate [koʊˈɑːpəreɪt] 合作</p>
<p>typhoon [aɪˈfuːn] 台风</p>
<p>act [ækt] 行动</p>
<p>argue [ˈɑːrɡjuː] 争论</p>
<p>Competent [ˈkɑːmpɪtənt] 胜任</p>
<p>brags about 吹牛</p>
<p>going on date with sb 与某人约会</p>
<p>take it for granted 理所当然的</p>
<blockquote>
<p>the + 形容词 = 名词</p>
<p>The rick should help the poor.</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习第四天</title>
    <url>/posts/f7a9.html</url>
    <content><![CDATA[<h3 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h3><h4 id="that-陈述句"><a href="#that-陈述句" class="headerlink" title="that + 陈述句"></a>that + 陈述句</h4><ul>
<li>练习1</li>
</ul>
<p><code>He doesn't believe me.</code></p>
<p><code>It hurts my feeling.</code></p>
<p>That he doesn’t believe me hurts my feeling.</p>
<p>It hurts my feeling that he doesn’t believe me.</p>
<ul>
<li>练习2</li>
</ul>
<p><code>All the Chinese students are good at math.</code></p>
<p><code>It is a stereotype.</code></p>
<p>That all the Chinese students are good at math is a stereotype.</p>
<p>It is a stereotype that all the Chinese students are good at math.</p>
<h4 id="whether-一般疑问句"><a href="#whether-一般疑问句" class="headerlink" title="whether + 一般疑问句"></a>whether + 一般疑问句</h4><ul>
<li>练习1</li>
</ul>
<p><code>Is he married?</code></p>
<p><code>It is not our business.</code></p>
<p>Whether he is married is not our business.</p>
<ul>
<li>练习2</li>
</ul>
<p><code>Should i apologize?</code></p>
<p><code>This question keeps me awake at night.</code></p>
<p>Whether i should apologize keeps me awake at night.</p>
<ul>
<li>练习3</li>
</ul>
<p><code>Can he do it?</code></p>
<p><code>It is uncertain.</code></p>
<p>Whether he can do these is uncertain.</p>
<ul>
<li>练习4</li>
</ul>
<p><code>Does he like it?</code></p>
<p><code>It is unknown to us.</code></p>
<p>Where he like it is unknown us.</p>
<blockquote>
<p>Whether 后面还可以加不定式，做主语。</p>
<p>Whether to respond is not decided.</p>
<p>Whether to impeach the president is under debate.</p>
</blockquote>
<h4 id="特殊疑问句（调整为陈述句语序）"><a href="#特殊疑问句（调整为陈述句语序）" class="headerlink" title="特殊疑问句（调整为陈述句语序）"></a>特殊疑问句（调整为陈述句语序）</h4><ul>
<li>特殊疑问词引导的特殊疑问句，改为陈述句语序。</li>
</ul>
<p>What i want is a new dress.</p>
<p>我想要一个新裙子。</p>
<p>Why he left is not important.</p>
<p>他为什么离开不重要。</p>
<ul>
<li>特殊疑问词 + to do</li>
</ul>
<p>What to eat for dinner doesn’t matter.</p>
<p>晚饭吃什么不重要。</p>
<p>Where to go is still under discussion.</p>
<p>去哪里还在讨论中。</p>
<blockquote>
<p>主语从句往往过长，放到句尾，而用it做形式主语放在句首。</p>
<p>What to say is not important. It is the way talk that matters.</p>
<p>How to solve real problem is not taught in school. It’s learned from experience.</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p>stereotype [ˈsteriətaɪp] 陈腔烂调，老套；成见</p>
<p>occur [əˈkɜːr] 出现；发生</p>
<p>wonder [ˈwʌndər] 惊讶；奇迹</p>
<p>miracle [ˈmɪrəkl] 奇迹</p>
<p>survive  [sərˈvaɪv] 幸存</p>
<p>arrest [əˈrest] 逮捕</p>
<p>impeach [ɪmˈpiːtʃ] 弹劾</p>
<p>respond [rɪˈspɑːnd] 回答；做出反应</p>
<p>president [ˈprezɪdənt] 总统</p>
<p>debate [dɪˈbeɪt] 讨论</p>
<p>car crash 车祸</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>设置Redis中的key过期时间</title>
    <url>/posts/ae5.html</url>
    <content><![CDATA[<h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><p>在实际的开发中经常会遇到一些有时效的数据，比如现实优惠活动、缓存或验证码等，过了一定的时间就需要删除这些数据。在关系数据库中一般需要额外一个字段来记录到期时间，然后定期检测删除过期数据。而在 Redis 中可以使用 <code>EXPIRE</code> 命令来设置一个键的过期时间，到时间后，Redis 会自动删除它。</p>
<p><code>EXPIRE</code> 命令的使用方法为 <code>EXPIRE key seconds</code>，其中 seconds 参数表示键的过期时间，单位是秒。</p>
<p>如果想让 session:29e3d 键在 15 分钟后删除：</p>
<pre class=" language-bash"><code class="language-bash">$ SET session:29e3d uid1314
OK
$ EXPIRE session:29e3d 900
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>EXPIRE 命令返回 1 表示设置成功，返回0 则表示键不存在或设置失败。</p>
<p>如果想知道一个键还有多久的时间会被删除，可以使用 TTL 命令。返回值是键的剩余时间（单位是秒）:</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK
$ EXPIRE foo 20
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 15
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2</code></pre>
<p>可见随着时间的不同，<code>foo</code> 键的过期时间逐渐减少，20秒后 <code>foo</code> 键会被删除。当键不存在时，<code>TTL</code> 命令会返回 -2。</p>
<p>没有为键设置过期时间（即永久存在，这是建立一个键后的默认情况），<code>TTL</code> 命令会返回 -1。</p>
<p>如果想取消键的过期时间设置（即将键恢复成永久的），则可以使用 <code>PRESIST</code> 命令。如果过期时间被成功清除则返回 1；否则返回 0（因为键不存在或键本来就是永久的）。</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
OK
$ EXPIRE foo 20
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ PERSIST foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ TTL foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1</code></pre>
<p>除了 PERSIST 命令外，使用 SET 或 GETSET 命令为键值赋值也会同时清除键的过期时间。其它只对键值进行操作的命令（如 INCR、LPUSH、HSET、ZERM）均不会影响键的过期时间。</p>
<p><code>EXPIRE</code> 命令的 <code>seconds</code> 参数必须是整数，所以最小单位是 1 秒。如果想要更精确的控制键的过期时间应该使用 <code>PEXPIRE</code> 命令，<code>PEXPIRE</code> 命令与 <code>EXPIRE</code> 的唯一区别是前者的时间单位是毫秒，即 <code>PEXPIRE key 1000</code> 与 <code>EXPIRE key 1</code> 等价。对应地可以使用 PTTL 命令以毫秒为单位返回键的剩余时间。</p>
<blockquote>
<p>如果使用 <code>WATCH</code> 命令监测了一个拥有过期时间的键，该键到期自动删除并不会被 <code>WATCH</code> 命令认为该键被改变。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>实现访问频率限制</li>
</ol>
<p>为了减轻服务器的压力，需要限制每个用户（以IP计）一段时间的最大访问量。与时间有关的操作很容易想到 <code>EXPIRE</code> 命令。</p>
<p>例如要限制每分钟每个用户最多只能访问100个页面，思路是对每个用户使用一个名为 <code>rate.limiting:用户IP</code> 字符串类型键，每次用户访问则使用 <code>INCR</code> 命令来递增该键的键值，如果递增后的值是 1（第一次访问页面）,则同时还要设置该键的过期时间为 1 分钟。这样每次用户访问页面时都能读取该键的键值，如果超过 100 就表明该用户的访问频率超过了限制，需要提示用户稍后访问。该键每分钟会被自动删除，所以下一分钟用户的访问次数又会重新计算，也就达到了限制访问频率的目的。</p>
<ol start="2">
<li>实现缓存</li>
</ol>
<p>为了提高网站的负载能力，常常需要将一些访问频率较高但是对 CPU 或 IO 资源消耗较大的操作的结果缓存起来，并希望让这些缓存过一段时间自动过期。</p>
<blockquote>
<p>当服务器内存有限时，如果大量地使用缓存键且过期时间设置得过长就会导致 Redis 占满内存；另一方面如果为了防止 Redis 占用内存过大而将缓存键得过期时间设置得太短，就可能导致缓存命中率过低并且大量内存白白地闲置。</p>
<p>实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制 Redis 能够使用的最大内存，并让 Redis 按照一定的规则淘汰不需要的缓存键，这种方式只在 Redis 用作缓存系统时非常实用。</p>
<p>具体的设置方法为：修改配置文件的 <code>maxmemory</code> 参数，限制 Redis 最大可用内存大小（单位是字节）,当超出了这个限制时，Redis会依据 <code>maxmemory-policy</code> 参数指定的策略来删除不需要的键，直到 Redis 占用的内存小于指定内存。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>使用 LRU 算法删除一个键（只对设置了过期时间的键）</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>使用 LRU 算法删除一个键</td>
</tr>
<tr>
<td>volatile-random</td>
<td>随机删除一个键（只对设置了过期时间的键）</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>随机删除一个键</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>删除过期时间最近的一个键</td>
</tr>
<tr>
<td>noeviction</td>
<td>不删除键，只返回错误</td>
</tr>
</tbody></table>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>通过外部单体对象来注册 Spring Bean</title>
    <url>/posts/de54.html</url>
    <content><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 省略setter getter</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonBeanRegistrationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建一个外部 Employee 对象</span>
    Employee employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册外部的单例对象</span>
    beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"employee"</span><span class="token punctuation">,</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动 Spring 应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 通过依赖查找的方式来获取 Employee</span>
    Employee employeeByLookup <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"employee"</span><span class="token punctuation">,</span> Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"employee == employeeLookup : "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>employee <span class="token operator">==</span> employeeByLookup<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>销毁 Spring Bean</title>
    <url>/posts/bd02.html</url>
    <content><![CDATA[<h3 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@PreDestroy</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PreDestroy : Employee 销毁中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建BeanFactory 容器</span>
    AnnotationConfigApplicationContext applicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册 Configuration Class (配置类)</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 依赖查找</span>
    Employee employee <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring应用上下文</span>
    applicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    @PreDestroy : Employee 销毁中... */</span></code></pre>
<h3 id="自定义销毁方法"><a href="#自定义销毁方法" class="headerlink" title="自定义销毁方法"></a>自定义销毁方法</h3><ul>
<li>xml 配置：&lt;bean destroy=”destroy” …/&gt;</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.asia.Employee<span class="token punctuation">"</span></span> <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initEmployee<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doDestroy<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre>
<ul>
<li>Java注解：@Bean(destroy=”destroy”)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token annotation punctuation">@PreDestroy</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PreDestroy : Employee 销毁中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义销毁方法 doDestroy : Employee 销毁中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 省略getter setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册Configuration Class (配置类)</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非延迟初始化在 Spring 应用上下文启动完成后，被初始化</span>
    Employee employee <span class="token operator">=</span> annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">"doDestroy"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    @PreDestroy : Employee 销毁中...
    自定义销毁方法 doDestroy : Employee 销毁中 */</span></code></pre>
<ul>
<li>Java API: AbstractBeanDefinition#setDestroyMethodName(String)</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    AbstractBeanDefinition beanDefinition <span class="token operator">=</span>
        BeanDefinitionBuilder<span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setInitMethodName</span><span class="token punctuation">(</span><span class="token string">"initEmployee"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">setDestroyMethodName</span><span class="token punctuation">(</span><span class="token string">"doDestroy"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>
            <span class="token string">"myEmployee"</span><span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="实现DisposableBean接口的-destroy-方法"><a href="#实现DisposableBean接口的-destroy-方法" class="headerlink" title="实现DisposableBean接口的 destroy() 方法"></a>实现DisposableBean接口的 destroy() 方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> DisposableBean <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PostConstruct Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义初始化方法 initEmployee : Employee 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"InitializingBean#afterPropertiesSet : UserFactory 初始化中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@PreDestroy</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"@PreDestroy : Employee 销毁中..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Disposable#destroy() : Employee 销毁中... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义销毁方法 doDestroy : Employee 销毁中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanInitializationDemo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建 BeanFactory 容器</span>
    AnnotationConfigApplicationContext annotationConfigApplicationContext <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 注册Configuration Class (配置类)</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>BeanInitializationDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 非延迟初始化在 Spring 应用上下文启动完成后，被初始化</span>
    Employee employee <span class="token operator">=</span> annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 关闭Spring 应用上下文</span>
    annotationConfigApplicationContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>initMethod <span class="token operator">=</span> <span class="token string">"initEmployee"</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">"doDestroy"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> Employee <span class="token function">employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/** 输出结果：
    @PostConstruct Employee 初始化中...
    InitializingBean#afterPropertiesSet : UserFactory 初始化中...
    自定义初始化方法 initEmployee : Employee 初始化中...
    @PreDestroy : Employee 销毁中...
    Disposable#destroy() : Employee 销毁中... 
    自定义销毁方法 doDestroy : Employee 销毁中 */</span></code></pre>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>@PreDestroy ——&gt; DisposableBean ——&gt; 自定义销毁方法</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin集合常用操作符</title>
    <url>/posts/fb3b.html</url>
    <content><![CDATA[<h3 id="元素操作类"><a href="#元素操作类" class="headerlink" title="元素操作类"></a>元素操作类</h3><p>contanis        ——     判断是否有指定元素</p>
<p>elementAt     ——     返回对应的元素，越界会抛出IndexOutOfBoundsException</p>
<p>firstOrNull     ——     返回符合条件的第一个元素，没有返回null</p>
<p>lastOrNull     ——     返回符合条件的最后一个元素，没有返回null</p>
<p>indexOf         ——     返回指定元素的下标，没有返回-1</p>
<p>singleOrNull ——     返回符合条件的单个元素，如果没有符合或超过一个，返回null</p>
<h3 id="判断类"><a href="#判断类" class="headerlink" title="判断类"></a>判断类</h3><p>any        ——     判断集合中是否有满足条件的元素</p>
<p>all          ——     判断集合中的元素是否都满足条件</p>
<p>none     ——     判断集合中是否都不满足条件，是则返回true</p>
<p>count    ——     查询集合中满足条件的元素个数 </p>
<h3 id="过滤类"><a href="#过滤类" class="headerlink" title="过滤类"></a>过滤类</h3><p>filter                    ——     过滤出所有满足条件的元素</p>
<p>filterNot             ——     过滤出所有不满足条件的元素</p>
<p>filterNotNull      ——     过滤NULL</p>
<p>take                     ——     返回前n个元素</p>
<h3 id="转换类"><a href="#转换类" class="headerlink" title="转换类"></a>转换类</h3><p>map                     ——     转换成另一个集合</p>
<p>mapIndexed      ——     除了转换成另一个集合，还可以拿到Index(下标)</p>
<p>mapNotNull       ——     执行转换钱过滤掉为NULL的元素</p>
<p>flatMap               ——     自定义逻辑合并两个集合</p>
<p>groupBy              ——     按照某个条件分组，返回Map</p>
<h3 id="排序类"><a href="#排序类" class="headerlink" title="排序类"></a>排序类</h3><p>reversed                     ——     反序</p>
<p>sorted                         ——     升序</p>
<p>sortedBy                     ——    自定义排序</p>
<p>sortedDescending     ——     降序</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/posts/d0dd.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>如果是一个小型项目，使用一台 Redis 服务器就已经足够了，然而现实中的项目通常需要若干台Redis 服务器的支持。</p>
<ul>
<li>从结构上，单个 Redis 服务器会发生单点故障，同时一台服务器需要承受所有的请求负载。这就需要为数据生成多个副本并分配在不同的服务器上；</li>
<li>从容量上，单个 Redis 服务器的内存非常容易成为存储瓶颈，所以需要进行数据分片。</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>通过持久化功能，Redis 保证了即使在服务器重启的情况下也不会损失数据（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署不同的服务器上，这样即使有一台服务器出现故障，其它服务器依然可以继续提供服务。为此，Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。<strong>主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据</strong>。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15911611190540_.pic_hd.jpg"></p>
<p>在 Redis 中使用复制功能非常容易，只需要在从数据库的文件中加入：</p>
<pre class=" language-shell"><code class="language-shell">slaveof 主数据地址 主数据库端口</code></pre>
<p>主数据库无需任何配置。</p>
<p>为了能够更直观地展示复制的流程，下面将实现一个最简化的复制系统。我们要在一台服务器上启动两个 Redis 实例，监听不同端口，其中一个作为主数据库，另一个作为从数据库。首先我们不加任何参数来启动一个 Redis 实例作为主数据库：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 该实例默认监听 6379 端口</span>
$ redis-server</code></pre>
<p>然后加上 <code>slaveof</code> 参数启动另一个 Redis 实例作为从数据库，并让其监听 6380 端口：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># masterauth是连接 redis-server 所需要的密码</span>
redis-server --port 6380 --slaveof 127.0.0.1 6379 --masterauth 123456 --daemonize <span class="token function">yes</span></code></pre>
<p> 此时在主数据库中的任何数据变化都会自动同步到从数据库中。</p>
<p>我们打开 redis-cli 实例 A 并连接到主数据库：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -p 6379</code></pre>
<p>再打开 redis-cli 实例 B 并连接到从数据库：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -p 6380</code></pre>
<p>这时我们使用 INFO 命令来分别在实例 A 和实例 B 中获取 Replication 节的相关信息：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:1
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6380,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>504,lag<span class="token operator">=</span>0</code></pre>
<p>可以看到实例 A 的角色是 master，即主数据库，同时已连接的从数据库（上面输出中的 connected_slaves）的个数为 1。</p>
<p>同样在实例 B 中获取相应的信息为：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> info replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6379</code></pre>
<p>这里可以看到，实例 B 的 role 是 slave，即从数据库，同时主数据库的地址为 127.0.0.1，端口 6379。</p>
<p>在实例 A 中使用 SET 命令设置一个键的值：</p>
<pre class=" language-bash"><code class="language-bash">master redis A <span class="token operator">></span> SET foo bar
OK</code></pre>
<p>此时在实例 B 中就可以获得该值了：</p>
<pre class=" language-bash"><code class="language-bash">slave redis B <span class="token operator">></span> GET foo
<span class="token string">"bar"</span></code></pre>
<p>默认情况下，从数据库是只读的，如果直接修改从数据库的数据会出现错误：</p>
<pre class=" language-bash"><code class="language-bash">slave redis B <span class="token operator">></span> <span class="token keyword">set</span> foo hi
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> READONLY You can't <span class="token function">write</span> against a <span class="token function">read</span> only replica.</code></pre>
<p>可以通过<strong>设置从数据库的配置文件中的 <code>slave-read-only</code> 为 <code>no</code> 以使从数据库可写</strong>，但是因为对<strong>从数据库的任何更改都不会同步给任何其它数据库</strong>，并且一旦主数据库中更新了对应的数据就会覆盖从数据库中的改动，所以通常的场景下设置从数据库可写，以免导致易被忽略的潜在应用逻辑错误。</p>
<p>配置多台从数据库的方法也一样，在所有的从数据库配置文件中加上 <code>slaveof</code> 参数指向同一个主数据库即可。</p>
<p> 除了通过配置文件或命令行参数设置 <code>slaveof</code> 参数，还可以在运行时使用 <code>SLAVEOF</code> 命令修改：</p>
<pre class=" language-bash"><code class="language-bash">$ SLAVEOF 127.0.0.1 6379</code></pre>
<p>如果该数据库已经是其它主数据库的从数据库了，<code>SLAVEOF</code> 命令会停止和原来数据库的同步转而和新数据库同步。此外对于从数据库来说，还可以使用 <code>SLAVEOF NO ONE</code> 命令来使当前数据库通知接受其它数据库的同步并转换为主数据库。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当一个从数据库启动后，会向主数据库发送 <code>SYNC</code> 命令。同时主数据库接收到 <code>SYNC</code> 命令后会开始在后台保存快照（即 RDB 持久化的过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis 会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存命令。以上过程称为复制初始化。复制初始化结束后，主数据库每当收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致。</p>
<p> 当主从数据库之间的连接断开重连后，Redis 2.6 以及之前的版本会重新进行复制初始化（即主数据库重新保存快照并传送给从数据库），即使从数据库仅有几条命令没有收到，主数据库也必须要将数据库里的所有数据重新传送给从数据库。这使得主从数据库断开重连后的数据恢复过程效率很低下，在网络环境不好的时候这一问题尤其明显。Redis 2.8 版的一个重要改进就是断线重连能够支持有条件的增量数据传输，当从数据库重新连接上从数据库后，主数据库只需要将断线期间执行的命令传送给从数据库，从而大大提高 Redis 复制的实用性。</p>
<p>下面将从具体协议角度详细介绍复制初始化的过程。由于 Redis 服务器使用 TCP 协议通信，所以我们可以使用 telnet 工具伪装成一个从数据库来与主数据库通信。首先在命令行中连接主数据库（默认端口 6379， 假设目前没有任何从数据库连接）：</p>
<pre class=" language-bash"><code class="language-bash">$ telnet 127.0.0.1 6379
Trying 127.0.0.1<span class="token punctuation">..</span>.
Connected to 127.0.0.1.
Escape character is <span class="token string">'^]'</span><span class="token keyword">.</span></code></pre>
<p>然后作为从数据库，我们先要发送 PING 命令确定主数据库是否可以连接：</p>
<pre class=" language-bash"><code class="language-bash">PING
+PONG</code></pre>
<p>主数据库会回复 +PONG。如果没有收到主数据的回复，则向用户提示错误。如果主数据库需要密码才能连接，我们还有发送 AUTH 命令验证：</p>
<pre class=" language-bash"><code class="language-bash">AUTH 123456
+OK</code></pre>
<p>而后向主数据库发送 <code>REPLCONF</code> 命令说明自己的端口号（这里随便选择了一个）：</p>
<pre class=" language-bash"><code class="language-bash">REPLCONF listening-port 6381
+OK</code></pre>
<p>这时就可以开始同步的过程了：向主数据库发送 SYNC 命令开始同步，此时主数据库发送回快照文件和缓存的命令。目前主数据库中只有一个 foo 键，所以收到的内容如下（快照文件是二进制格式）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15921611196132_.pic_hd.jpg"></p>
<p>从数据库会将收到的内容写入到硬盘上的临时文件中，当写入完成后从数据库会用该临时文件替换 RDB 快照文件（RDB 快照文件的位置就是持久化时配置的位置，由 <code>dir</code> 和 <code>dbfilename</code> 两个参数确定），之后的操作就和 RDB 持久化时启动回复的过程一样了。需要注意的是在同步的过程中，从数据库并不会阻塞，而是继续可以处理客户端发来的命令。默认情况下，从数据库会用同步前的数据对命令进行响应。可以配置参数：</p>
<pre class=" language-shell"><code class="language-shell">replica-serve-stale-data no</code></pre>
<p>来使从数据库在同步完成前对所有命令（除了 INFO 和 SLAVEOF） 都返回错误：“SYNC with master in progress”。</p>
<p>复制初始化阶段结束后，主数据库执行的任何会导致数据变化的命令都会异步地传送给从数据库，这一过程为复制同步阶段。同步地内容和 Redis 通信协议一样，比如我们在主数据中执行 ：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo hi</code></pre>
<p>通过 telnet 我们收到了</p>
<pre class=" language-bash"><code class="language-bash">SELECT
<span class="token variable">$1</span>
0
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$3</span>
foo
<span class="token variable">$2</span>
hi
*1</code></pre>
<p>复制同步阶段会贯穿整个主从同步过程地始终，直到主从关系终止为止。</p>
<p>在复制的过程中，快照无论在主数据库还是从数据库中都起了很大的作用，只要执行复制就会进行快照，即使我们关闭了 RDB 方式的持久化（通过删除所有 save 参数。）Redis 2.8.18 之后支持了无硬盘复制。</p>
<blockquote>
<p><strong>乐观复制</strong>    Redis 采用了乐观复制（optimistic replication） 的复制策略，容忍在一定时间内主从数据库的内容是不同的，但是两者的数据会最终同步。具体来说，Redis 在主从数据库之间复制数据的过程本身是异步的，这意味着，主数据库执行完客户端请求的命令后会立即将命令在主数据库的执行结果返回给客户端，并异步地将命令同步给从数据库库，而不会等待从数据库接收到该命令后在返回给客户端。这一特性保证了启用复制后主数据库地性能不会受到影响，但另一方面也会产生一个主从数据库数据不一致地时间窗口，当主数据执行了一条写命令后，主数据地数据已经发生了变动，然而在主数据库将命令传送给从数据库之前，如果两个数据库之间的网络连接断开了，此时二者之间的数据就会是不一致的。从这个角度来看，主数据库是无法得知某个命令最终同步给了多少个从数据库的，不过 Redis 提供了两个配置选项来限制只有当数据至少同步给指定数量的从数据库时，主数据库才是可写的：</p>
<pre class=" language-bash"><code class="language-bash">min-replicas-to-write 3
min-replicas-max-lag 10</code></pre>
<p>上面的配置中，<code>min-replicas-to-write</code> 表示只有当 3 个 或 3 个以上的从数据库连接到主数据库时，主数据库才是可写的，否则返回错误，例如：</p>
<pre class=" language-bash"><code class="language-bash">$ SET foo bar
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOREPLICAS Not enough good slaves to write.</code></pre>
<p><code>min-replicas-max-lag</code> 表示允许从数据库最长失去连接的时间（单位秒），如果从数据库最后与主数据库联系（即发送 <code>REPLCONF ACK</code> 命令）的时间小于这个值，则认为从数据库还在保持与主数据库的连接。举个例子，按上面的配置，主数据库假设与3个从数据库相连，其中一个从数据库上一次与主数据库联系是 9 秒前，这是主数据库可以正常接受写入，一旦 1 秒过后这台从数据库依旧没有活动，则主数据则认为目前连接的从数据库只有两个，从而拒绝写入。这一特性默认是关闭的，在分布式系统中，打开并合理配置该选项后可以降低主从架构中因为网络分区导致的数据不一致问题。</p>
</blockquote>
<h4 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h4><p>从数据库库不仅可以接受主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15931611198795_.pic_hd.jpg"></p>
<p>数据库 A 的数据会同步到 B 和 C 中，而 B 中的数据会同步到 D 和 E 中。向 B 中写入数据不会同步到 A 或 C 中，只会同步到 D 和 E 中。</p>
<h4 id="读写分离一致性"><a href="#读写分离一致性" class="headerlink" title="读写分离一致性"></a>读写分离一致性</h4><p>通过复制可以实现读写分离，以提高服务器的负载能力。在常见的场景中（如电子商务网站），读的频率大于写，当单机的 Redis 无法应付大量的读请求时（尤其是较耗资源的请求，如 SORT 命令等）可以通过复制功能建立多个从数据库节点，主数据库只进行写操作，而从数据库负责读操作。这种一主多从的结构很适合读多写少的场景，而当单个的主数据库不能满足需求时，就需要使用 Redis 3.0 推出的集群功能。</p>
<h4 id="从数据库持久化"><a href="#从数据库持久化" class="headerlink" title="从数据库持久化"></a>从数据库持久化</h4><p>另一个相对耗时的操作是持久化，为了提高性能，可以通过复制功能建立一个（或若干个）从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃重启后，主数据库会自动将数据同步过来，所以无需担心数据丢失。</p>
<p>然而当主数据库崩溃时，情况就稍显复杂了。手动通过从数据库数据回复主数据库数据时，需要严格按照一下两步进行。</p>
<ul>
<li>在从数据库中使用 <code>SLAVEOF NO ONE</code> 命令将从数据提升成主数据库继续服务。</li>
<li>启动之前崩溃的主数据库，然后使用 <code>SLAVEOF</code> 命令将其设置成新的主数据库的从数据库，即可将数据同步回来。</li>
</ul>
<blockquote>
<p><strong>注意</strong>    当开启复制且主数据库关闭持久化功能时，一定不要使用 <code>Supervisor</code> 以及类似的进程管理工具令主数据库崩溃后自动重启。同样当主数据库所在的服务器因故关闭时，也要避免直接重新启动。这是因为当主数据库重新启动后，因为没有开启持久化功能，所以数据库中所有数据都被清空，这时从数据库依然会从主数据库中接受数据，使得所有从数据库也被清空，导致从数据库的持久化失去意义。</p>
</blockquote>
<p>无论哪种情况，手工维护从数据库或主数据库的重启以及数据恢复都相对麻烦，好在 Redis 提供了一种自动化哨兵来实现这一过程，避免了手动维护的麻烦和容易出错的问题。</p>
<h4 id="无硬盘复制"><a href="#无硬盘复制" class="headerlink" title="无硬盘复制"></a>无硬盘复制</h4><p>Redis 复制的工作原理是基于 RDB 方式的持久化实现的，即主数据库端在后台保存 RDB 快照，从数据库端则接收并载入快照文件。这样的实现优点是可以显著地简化逻辑，复用已有的代码，但是缺点也很明显。</p>
<ul>
<li>当主数据库禁用 RDB 快照时（即删除了所有地配置文件中地 save 语句），如果执行了复制初始化操作，Redis 依然会生成 RDB 快照，所以下次启动后主数据库会以快照恢复数据。因为复制发生的时间不能确定，这使得恢复的数据可能是任何时间点的。</li>
<li>因为复制初始化时需要在硬盘中创建 RDB 快照文件，所以如果硬盘性能很慢（如网络硬盘）时这一过程会对性能产生影响。举例来说，当使用 Redis 做缓存系统时，因为不需要持久化，所以服务器的硬盘读写速度可能较差。但是当该缓存系统使用一主多从的集权架构时，每次和从数据库同步，Redis 都会执行一次快照，同时对硬盘进行读写，导致性能降低。</li>
</ul>
<p>因此从 2.8.28 版本开始，Redis 引入了无硬盘复制选项，开启该选项时，Redis 在与从数据库进行复制初始化时，将不会将快照内容存储到硬盘上，而是直接通过网络发送给数据库，避免了硬盘的性能瓶颈。可以在配置文件中使用如下配置来开启该功能：</p>
<pre class=" language-bash"><code class="language-bash">repl-diskless-sync <span class="token boolean">true</span></code></pre>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>在介绍复制的原理时提到当主从数据库连接断开后，从数据库会发送 SYNC 命令来重新进行一次完整复制操作。这样即使断开期间数据库的变化很小（甚至没有），也需要将数据库中的所有数据重新快照并传送一次。在正常的网络应用环境中，这种实现方式显然不太理想。Redis 2.8 版相对 2.6 版的最重要更新至一就是实现了主从断线重连的情况下的增量复制。</p>
<p>增量复制时基于如下 3 点实现的。</p>
<ul>
<li>从数据库会存储主数据库的运行 ID（run id）。每个 Redis 运行实例均会拥有一个唯一的运行 ID，每当实例重启后，就会自动生成一个新的运行 ID。</li>
<li>在复制同步阶段，主数据库每将一个命令 传送给从数据库时，都会同时把该命令存放到一个积压队列（backlog）中，并记录下当前积压队列中存放的命令的偏移量范围。</li>
<li>同时，从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量。</li>
</ul>
<p>这 3 点是实现增量复制的基础。当主从连接准备就绪后，从数据库会发送一条 SYNC 命令来告诉主数据库可以把所有数据同步过来了。而 2.8 版本之后，不在发送 SYNC 命令，取而代之的是发送 PSYNC 命令，格式为：</p>
<pre class=" language-bash"><code class="language-bash">$ PSYNC 主数据的运行id 断开前最新的命令偏移量</code></pre>
<p>主数据库收到 PSYNC 命令后，会执行以下判断来决定此次重连是否可以执行增量复制。</p>
<ul>
<li>首先主数据库会判断从数据库传送来的运行 ID 是否和自己的运行 ID 相同。这一步骤的意义在于确保从数据库库之前确实是和自己同步的，以免从数据库拿到错误的数据（比如主数据库在短线期间重启过，会造成数据的不一致）。</li>
<li>然后判断从数据库库最后同步成功的命令偏移量是否在积压队列中，如果在则可以执行增量复制，并将积压队列中相应的命令发送给从数据库。<ul>
<li>如果此次重连不满足增量复制的条件，主数据库会进行一次全部同步。</li>
<li>大部分情况下，增量复制的过程对开发者来说是完全透明的，开发者不需要关心增量复制的具体细节。</li>
</ul>
</li>
</ul>
<p>积压队列在本质上是一个固定长度的循环队列，默认情况下积压队列的大小为 1MB，可以通过配置文件的 <code>repl-backlog-size</code>参数来调整：</p>
<pre class=" language-bash"><code class="language-bash">$ repl-backlog-size 1mb</code></pre>
<p>很容易理解的是，积压队列越大，其允许的主从数据库断线的时间就越长。根据主从数据库之间的网络状态，设置一个合理的积压队列很重要。因为积压队列存储的内容是命令本身，如 <code>SET foo bar</code>，所以估算计算队列的大小只需要估计主从数据库断线的时间中主数据库可能执行的命令大小即可。</p>
<p>与积压队列相关的另一个配置选项是 <code>repl-backlog-ttl</code>，即当所有从数据库与主数据库断开连接后，经过多久时间可以释放挤压队列的内存空间。默认时间是 1 小时。</p>
<pre class=" language-bash"><code class="language-bash">$ repl-backlog-ttl 3600</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵</title>
    <url>/posts/c807.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在一个典型的一主多从的Redis系统中，从数据库在整个系统中起到了数据冗余备份和读写分离的作用。当主数据库遇到异常中断服务后，开发者可以通过手动的方式选择一个从数据库来升级为主数据库，以使得系统能够继续提供服务。然而整个过程相对麻烦且需要人工介入，难以实现自动化。</p>
<p>为此，Redis 2.8 中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。</p>
<h4 id="什么是哨兵"><a href="#什么是哨兵" class="headerlink" title="什么是哨兵"></a>什么是哨兵</h4><p>顾名思义，哨兵的作用就是监控 Redis 系统的运行状况。它的功能包括以下两个。</p>
<ul>
<li>监控主数据库和从数据库是否正常运行。</li>
<li>主数据库出现故障时自动将从数据库转换为主数据库。</li>
</ul>
<p>哨兵是一个独立的进程，使用哨兵的一个典型架构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15971611207217_.pic_hd.jpg"></p>
<p>在一个一主多从的 Redis 系统中，可以使用多个哨兵进行监控任务以保证系统足够稳健。注意，此时不仅哨兵会同时监控主数据库和从数据库，哨兵之间也会互相监控。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15981611207382_.pic_hd.jpg"></p>
<h3 id="马上上手"><a href="#马上上手" class="headerlink" title="马上上手"></a>马上上手</h3><p>在理解哨兵的原理前，我们首先实际使用一下哨兵，来了解哨兵是如何工作的。首先建立起 3 个 Redis 实例，其中包括一个主数据库和两个从数据库。主数据库的端口为 6379，两个从数据库的端口分别为 6380 和 6381。我们使用 Redis 命令行客户端来获取复制状态，以保证复制配置正确。</p>
<p>首先是主数据库：</p>
<pre class=" language-bash"><code class="language-bash">redis 6379<span class="token operator">></span> info replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6380,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>56,lag<span class="token operator">=</span>0
slave1:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>56,lag<span class="token operator">=</span>0</code></pre>
<p>可见其连接了两个从数据库，配置正确。然后用同样的方法查看两个从数据库的配置：</p>
<pre class=" language-bash"><code class="language-bash">redis 6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1

redis 6381<span class="token operator">></span> info replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6379</code></pre>
<p>当出现的信息如上时，即证明一主而从配置已经成功了。</p>
<p>接下来开始配置哨兵。建立一个配置文件，如 <code>sentinel.conf</code>，内容为：</p>
<pre class=" language-shell"><code class="language-shell">sentinel monitor mymaster 127.0.0.1 6379 1</code></pre>
<p>其中 <code>mymaster</code> 表示要监视的主数据库名字，可以自己定义一个。这个名字必须仅由大小写字母、数字 和 “.-_”这3个字符组成。后两个参数表示主数据库的地址和端口号，这里我们要监控的主数据库 6379。最后的 1 表示最低通过票数，后面会介绍。接下来启动 sentinel 进程，并将上述配置文件的路径传递给哨兵：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-sentinel /path/to/sentinel.conf</code></pre>
<p> 需要注意的是，配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</p>
<p>启动哨兵后，哨兵输出一下内容：</p>
<pre class=" language-bash"><code class="language-bash">3839:X 21 Jan 2021 01:02:39.668 <span class="token comment" spellcheck="true"># Sentinel ID is 34e43f99b8460c86a0061c0e3325c5a5d94602b2</span>
3839:X 21 Jan 2021 01:02:39.668 <span class="token comment" spellcheck="true"># +monitor master mymaster 127.0.0.1 6379 quorum 1</span>
3839:X 21 Jan 2021 01:02:39.669 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
3839:X 21 Jan 2021 01:02:39.670 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379</code></pre>
<p>其中 +slave 表示新发现了从数据库，可见哨兵成功地发现了两个从数据库。现在哨兵已经在监控 3 个 Redis 实例了，这时我们将主数据库关闭（即运行在 639 端口上的 Redis 实例，杀死进程或使用 SHUTDOWN 命令）,等待指定时间后（可以配置，默认为 30 秒），哨兵会输出一下内容：</p>
<pre class=" language-shell"><code class="language-shell">3839:X 21 Jan 2021 01:10:29.111 # +sdown master mymaster 127.0.0.1 6379
3839:X 21 Jan 2021 01:10:29.111 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1</code></pre>
<p>其中 <code>+sdown</code> 表示哨兵主观认为主数据库停止服务了，而 <code>+odown</code> 则表示哨兵客观认为主数据库停止服务了，关于客观和主管的区别后文会详细介绍。此时哨兵开始执行故障恢复，即挑选一个从数据库，将其升格为主数据库。同时输出以下内容：</p>
<pre class=" language-shell"><code class="language-shell">3839:X 21 Jan 2021 01:10:29.111 # +try-failover master mymaster 127.0.0.1 6379
...
3839:X 21 Jan 2021 01:10:30.561 # +failover-end master mymaster 127.0.0.1 6379
3839:X 21 Jan 2021 01:10:30.561 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380</code></pre>
<p><code>+try-failover</code> 表示哨兵开始进行故障恢复，<code>+failover-end</code> 表示哨兵完成故障恢复，期间设计的内容比较复杂，包括领头哨兵的选举、备选从数据库的选择等。<code>+switch-master</code> 表示主数据库从 6379 端口迁移到 6380 端口，即 6380 端口的从数据库被升格为主数据库，同时两个 <code>+slave</code> 则列出了2个新的从数据库，端口分别为 6381 和 6379。</p>
<pre class=" language-shell"><code class="language-shell">3839:X 21 Jan 2021 01:10:30.561 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380
3839:X 21 Jan 2021 01:10:30.561 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380
3839:X 21 Jan 2021 01:11:00.587 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</code></pre>
<p>其中 6379 就是之前停止服务的主数据库，可见哨兵并没有彻底清除停止服务的实例的信息，这时因为停止服务的实例有可能会在之后的某个时间恢复服务，这时哨兵会让其重新加入进来，所以当实例停止服务后，哨兵会更新该实例的信息，使得当其重新重新加入后可以按照当时信息继续对外提供服务。此例中 6379 端口的主数据库实例停止服务了，而 6380 端口的从数据已经升格为主数据库，当 6379 端口的实例恢复服务后，会转变成 6380 端口实例的从数据库来运行，所以哨兵将 6379 端口实例的信息改成了 6380 端口实例的从数据库。</p>
<p>故障恢复完成后，可以使用 Redis 命令行客户端重新检查 6380 和 6381 两个端口上的实例的复制信息：</p>
<pre class=" language-bash"><code class="language-bash">redis 6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:1
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>59364,lag<span class="token operator">=</span>1

redis 6381<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6380</code></pre>
<p>可以看到 6380 端口上的实例已经确实升格为主数据库了，同时 6381 端口上的实例是其从数据库。整个故障恢复过程就此完成。</p>
<p>那么此时我们将 6379 端口上的实例重新启动，会发生什么情况呢？首先哨兵会监控到这一变化，并输出：</p>
<pre class=" language-bash"><code class="language-bash">3839:X 21 Jan 2021 01:37:10.815 <span class="token comment" spellcheck="true"># -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</span>
3839:X 21 Jan 2021 01:37:20.745 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380</code></pre>
<p><code>sdown</code> 表示实例 6379 已经恢复服务了（与 <code>+sdown</code> 相反），同时 <code>+convert-to-slave</code> 表示将 6379 端口的实例设置为 6380 端口实例的从数据库。这时使用 Redis 命令行客户端查看 6379 端口实例的复制信息为：</p>
<pre class=" language-bash"><code class="language-bash">redis 6379<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:6380</code></pre>
<p>同时 6380 端口实例的复制信息为：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> INFO replication
<span class="token comment" spellcheck="true"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6381,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>153516,lag<span class="token operator">=</span>1
slave1:ip<span class="token operator">=</span>127.0.0.1,port<span class="token operator">=</span>6379,state<span class="token operator">=</span>online,offset<span class="token operator">=</span>153516,lag<span class="token operator">=</span>0</code></pre>
<p>正如预期一样，6380 端口实例的从数据库变味了两个，6379 成功恢复服务。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>一个哨兵进程启动时会读取配置文件的内容，通过如下的配置找出需要监控的主数据库：</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor master-name ip redis-port quorum</code></pre>
<p>其中 master-name 是一个由大小写字母、数字和 “.-_” 组成的主数据库的名字，因为考虑到故障恢复后当前监控的系统的主数据库的地址和端口会产生变化，所以哨兵提供了命令可以通过主数据库的名字获取当前系统的主数据库地址和端口号。</p>
<p><code>ip</code> 表示当前系统中主数据库的地址，而 <code>redis-port</code> 则表示端口号。</p>
<p><code>quorum</code> 用来表示执行故障恢复操作前至少需要几个哨兵节点同意。一个哨兵节点可以同时监控多个 Redis 主从系统，只需要提供多个 <code>sentinel monitor</code> 配置即可，例如：</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor mymaster 127.0.0.0.1 6379 2
sentinel monitor othermaster 192.168.1.1 6380 4</code></pre>
<p>同时多个哨兵节点也可以同时监控一个 Redis 主从系统，从而形成网状结构。</p>
<p>配置文件中还可以定义其它监控相关的参数，每个配置选项都包含主数据库的名字使得监控不同主数据库时可以使用不同的配置参数。例如：</p>
<pre class=" language-bash"><code class="language-bash">sentinel down-after-milliseconds mymaster 60000
sentinel down-after-milliseconds othermaster 10000</code></pre>
<p>上面的两行配置分别配置了 <code>mymaster</code> 和 <code>othermaster</code> 的 down-after-milliseconds 选项分别为 60000 和 10000。</p>
<p>哨兵启动后，会与要监控的主数据库建立两条连接，这两个连接的建立方式与普通的 Redis 客户端无异。其中一条连接用来订阅该主数据库的 <code>_sentinel_:hello</code> 频道以获取其它同样监控该数据库的哨兵节点信息，另外哨兵也需要定期向主数据发送 INO 等命令来获取主数据库本身的信息。因为当客户端进入订阅模式时就不能再执行其它命令了，所以这时哨兵会使用另外一条连接来发送这些命令。</p>
<p>和主数据库的连接建立完成后，哨兵会定时执行下面 3 个操作：</p>
<ol>
<li>每 10 秒哨兵会向主数据库和从数据库发送 INFO 命令。</li>
<li>每 2 秒哨兵会向主数据库和从数据库的 <code>_sentinel_:hello</code> 频道发送自己的信息。</li>
<li>每 1 秒会向主数据库、从数据库和其它哨兵节点发送 PING 命令。</li>
</ol>
<p>这 3 个操作贯穿哨兵进程的整个生命周期中，非常重要，可以说了解了这 3 个操作的意义就能够了解哨兵工作原理的一般内容了。下面分别详细介绍。</p>
<p>首先，发送 INFO 命令使得哨兵可以获得当前数据库的相关信息（包括运行 ID 、复制信息等）从而实现新节点的自动发现。前面说配置哨兵监控 Redis 主从系统时只需要指定主数据库的信息即可，因为哨兵正是借助 INFO 命令来获取所有复制该主数据库的从数据库信息的。启动后，哨兵向主数据库发送 INFO 命令，通过解析返回结果来得知从数据库列表，而后对每个从数据库同样建立两个连接，两个连接的作用和刚刚介绍的与主数据库建立的两个连接完全一致。在此之后，哨兵会每 10 秒定时向已知的所有主从数据库发送 INFO 命令来获取信息并进行相应的更新操作，比如对新增的从数据库建立连接并加入监控列表，对主从数据库的角色变化（由故障恢复操作引起）进行信息更新等。</p>
<p>接下来哨兵向主从数据库的<code>_sentinel_:hello</code> 频道发送消息来与同样监控该数据库的哨兵分享自己的信息。发送的消息内容为：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>哨兵的地址<span class="token operator">></span>，<span class="token operator">&lt;</span>哨兵的端口<span class="token operator">></span>，<span class="token operator">&lt;</span>哨兵的运行ID<span class="token operator">></span>，<span class="token operator">&lt;</span>哨兵的配置版本<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的名字<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的地址<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的端口<span class="token operator">></span>，<span class="token operator">&lt;</span>主数据库的配置版本<span class="token operator">></span></code></pre>
<p>可以看到消息包括哨兵的基本信息，以及其监控的主数据库的信息。刚刚介绍过，哨兵会订阅每个监控的数据库<code>_sentinel_:hello</code> 频道，所以当其它哨兵收到消息后，会判断发消息的哨兵是不是新发现的哨兵。如果是则将其加入已发现的哨兵列表中并创建一个到其的连接（与数据库不同，哨兵与哨兵之间只会创建一条连接用来发送 PING 命令，而不需要创建另外一条连接来订阅频道，因为哨兵只需要订阅数据库的频道即可实现自动发现其它哨兵）。同时哨兵会判断信息中主数据库的配置版本，如果该版本比当前记录的主数据库的版本高，则更新主数据库中的数据。</p>
<p>实现了自动发现从数据库和其它哨兵节点后，哨兵要做的就是定时监控这些数据库和节点有没有停止服务。这是通过每隔一定时间向这些节点发送 PING 命令实现的。时间间隔与 <code>down-after-milliseconds</code> 选项有关，当  <code>down-after-milliseconds</code>  的值小于 1 秒时，哨兵会每隔  <code>down-after-milliseconds</code>  指定的时间发送一次 PING 命令，当  <code>down-after-milliseconds</code> 的值大于 1 秒时，哨兵会每隔 1 秒发送一次 PING 命令。例如：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 每隔 1 秒发送一次 PING 命令</span>
sentinel down-after-milliseconds mymaster 60000
<span class="token comment" spellcheck="true"># 每隔 600 毫秒发送一次 PING 命令</span>
sentinel down-after-milliseconds othermaster 500</code></pre>
<p>当超过 <code>down-after-milliseconds</code> 选项指定时间后，如果被 PING 的数据库或节点仍然未进行回复，则哨兵认为其<strong>主观下线（subjectively down）</strong>。主观下线表示从当前的哨兵进程看来，该节点已经下线。如果该节点是主数据库，则哨兵会进一步判断是否需要对其进行故障恢复：哨兵发送 <code>SENTINEL is-master-down-by-addr</code> 命令询问其它哨兵节点以了解它们是否也认为该主数据库主观下线，如果达到指定数量时，哨兵会认为其<strong>客观下线（objectively down）</strong>，并选举领头的哨兵节点对主从系统发起故障恢复。这个指定数量即为前文介绍的 quorum 参数。例如，下面的配置：</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor mymaster 127.0.0.1 6379 2</code></pre>
<p>该配置表示只有当至少两个 Sentinel 节点（包括当前节点）认为该主数据库主观下线时，当前哨兵节点才会认为该主数据库客观下线。进行接下来的选举领头哨兵步骤。</p>
<p>虽然当前哨兵节点发现了主数据库客观下线，需要故障恢复，但是故障恢复需要由领头的哨兵来完成，这样可以保证同一时间只有一个哨兵节点来执行故障恢复。选举领头哨兵的过程使用了 Raft 算法，具体过程如下：</p>
<ol>
<li>发现主数据库客观下线的哨兵节点（下面称作 A）向每个哨兵节点发送命令，要求对方选自己为领头哨兵。</li>
<li>如果目标哨兵节点没有选过其它人，则会同意将 A 设置成领头哨兵。</li>
<li>如果 A 发现有超过半数且超过 quorum 参数值的哨兵节点同意选自己成为领头哨兵，则 A 成功成为领头哨兵。</li>
<li>当有多个哨兵节点同时参选领头哨兵，则会出现没有任何节点当选的可能。此时每个参选节点将等待一个随机时间重新发起参数请求，进行下一轮选举，直到选举成功。</li>
</ol>
<p>因为要成为领头哨兵必须有超过半数的哨兵节点支持，所以每次选举最多只会选出一个领头哨兵。选出领头哨兵后，领头哨兵将会开始对主数据库进行故障恢复。故障恢复的过程相对简单，具体如下：</p>
<p>首先领头哨兵将从停止服务的主数据库的从数据库中挑选一个来充当新的主数据库。挑选的依据如下：</p>
<ol>
<li>所有在线的从数据库中，选择优先级别最高的从数据库。优先级可以通过 <code>slave-priority</code> 选项来设置。</li>
<li>如果有多个最高优先级的从数据库，则复制的命令偏移量越大（即复制越完成）越优先，</li>
<li>如果以上条件都一样，则选择运行 ID 较小的从数据库。</li>
</ol>
<p>选出一个从数据库后，领头哨兵将向从数据库发送 <code>SLAVE NO ONE</code> 命令使其升格为主数据库。而后领头哨兵向其它从数据库发送 <code>SLAVEOF</code> 命令来使其成为新主数据库的从数据库。最后一步则是更新内部的记录，将已经停止服务的旧的主数据库更新为新的主数据库的从数据库，使得当其恢复服务时自动以从数据库的身份继续服务。</p>
<h3 id="哨兵的部署"><a href="#哨兵的部署" class="headerlink" title="哨兵的部署"></a>哨兵的部署</h3><p>哨兵以独立进程的方式对一个主从系统进行监控，监控效果的好坏与否取决于哨兵的视角是否有代表性。如果一个主从系统中配置的哨兵较少，哨兵对整个系统的判断的可靠性就会降低。极端情况下，当只有一个哨兵时，哨兵本身就很有可能发生单点故障。整体来讲，相对稳妥的哨兵部署方案是使得哨兵的视角尽可能地与每个节点的视角一致，即：</p>
<ul>
<li>为每个节点（无论是主数据库还是从数据库）部署一个哨兵</li>
<li>使每个哨兵与其对应的节点的网络环境相同或相近</li>
</ul>
<p>这样的部署方案可以保证哨兵的视角拥有较高的代表性和可靠性。举一个例子：当网络分区后，如果哨兵认为某个分区是主要分区，即意味着从每个节点观察，该分区均为主分区。</p>
<p>同时设置 quorum 的值为 <code>N / 2 + 1</code> (其中 N 为哨兵节点数量)，这样使得只有大部分哨兵节点同意后才会进行故障恢复。</p>
<p>当系统中的节点较多时，考虑到每个哨兵都会和系统中的所有节点建立连接，为每个节点分配一个哨兵会产生较多连接，尤其当进行客户端分片时使用多个哨兵节点监控多个主数据库会因为 Redis 不支持连接复用而产生大量冗余连接，同时如果 Redis  节点负载较高，会在一定程度上影响其对哨兵的回复和同机的哨兵与其它节点的通信。所以配置哨兵时还需根据实际的生产环境进行选择。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用数据类型</title>
    <url>/posts/f08d.html</url>
    <content><![CDATA[<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串类型是 Redis 中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。你可以用其存储用户的邮箱、JSON化的对象甚至是一张图片。一个字符串类型键允许村塾的数据的最大容量是521MB。</p>
<ol>
<li>赋值与取值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SET key value
$ GET key</code></pre>
<ol start="2">
<li>递增数字</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ INCR num</code></pre>
<p>字符串类型可以存储任何形式的字符串，当存储的字符串是整数形式时，Redis 提供了一个实用的命令 INCR，其作用是让当前键值递增，并返回递增后的值。</p>
<pre class=" language-bash"><code class="language-bash">$ INCR num
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ INCR num
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p>当要操作的键不存在时，会默认值为 0 ，所以第一次递增后的结果是 1。当键值不是整数时 Redis 会提示错误。</p>
<ol start="3">
<li>增加指定的整数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ INCRBY key increment</code></pre>
<p>与 <code>INCR</code> 命令基本一样，只不过可以通过 <code>increment</code> 参数指定一次增加的数值。如：</p>
<pre class=" language-bash"><code class="language-bash">$ INCRBY bar 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ INCRBY bar 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5</code></pre>
<ol start="4">
<li>减少指定的整数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ DECR key
$ DECRBY key increment</code></pre>
<ol start="5">
<li>增加指定的浮点数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ INCRBYFLOAT key increment</code></pre>
<p>类似 <code>INCRBY</code> 命令，差别是可以递增一个双精度浮点数。</p>
<pre class=" language-bash"><code class="language-bash">$ INCRBYFLOAT foo 2.7
<span class="token string">"2.7"</span>
$ INCRBYFLOAT foo 5E+4
<span class="token string">"50002.69999999999999929"</span></code></pre>
<ol start="6">
<li>向尾部追加值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ APPEND key value</code></pre>
<p><code>APPEND</code> 作用是向键值的末尾追加 value。如果键不存在则该键的值为 value，即相当于 SET key value。返回值是追加后字符串的长度。如：</p>
<pre class=" language-bash"><code class="language-bash">$ SET key hello
OK
$ APPEND key <span class="token string">" world!"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 12</code></pre>
<p>此时 key 的值是“hello world!”。APPEND 命令的第二个参数加了双引号，原因是该参数包含空格，在 redis-cli 中需要输入双引号以示区别。</p>
<ol start="7">
<li>获取字符串长度</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ STRLEN key</code></pre>
<ol start="8">
<li>同时获得/设置多个键值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ MGET key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ MSET key value <span class="token punctuation">[</span>key value <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>散列类型（hash）的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其它数据类型。换句话说，散列类型不能嵌套其它的数据类型。一个散列类型键可以包含至多<code>2的32次方-1</code>个字段。</p>
<blockquote>
<p>提示    除了散列类型，Redis 的其它数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。</p>
</blockquote>
<ol>
<li>赋值与取值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HSET key field value
$ HGET key field
$ HMSET key field value <span class="token punctuation">[</span>field value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ HMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ HGETALL key</code></pre>
<p><code>HSET</code> 命令用来给字段赋值，而 <code>HGET</code> 命令用来获得字段的值。</p>
<pre class=" language-bash"><code class="language-bash">$ HSET car price 500
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ HSET car name BMW
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ HGET car name
<span class="token string">"BMW"</span></code></pre>
<p><code>HSET</code>  命令的方便之处在于不区分插入和更新操作，这意味着修改数据时不用实现判断字段是否存在来决定要执行的是插入操作（update） 还是更新操作（insert）。当执行的是插入操作时（即之前字段不存在） <code>HSET</code>命令会返回 1 ，当执行的是更新操作时（即之前字段已经存在） <code>HSET</code> 命令会返回 0 。</p>
<p>如果想获取键中所有字段和字段值却不知道键中有哪些字段时，应该使用 HGETALL 命令。</p>
<pre class=" language-bash"><code class="language-bash">$ HGETALL car
1<span class="token punctuation">)</span> <span class="token string">"price"</span>
2<span class="token punctuation">)</span> <span class="token string">"500"</span>
3<span class="token punctuation">)</span> <span class="token string">"name"</span>
4<span class="token punctuation">)</span> <span class="token string">"BMW"</span></code></pre>
<p>返回的结果是字段和字段值组成的列表，不是很直观。</p>
<ol start="2">
<li>判断字段是否存在</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HEXISTS key field</code></pre>
<p>存在返回 1 ，否则返回 0 。</p>
<ol start="3">
<li>当字段不存在时赋值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HSETNX key field value</code></pre>
<p><code>HSETNX</code> 命令与  <code>HSET</code> 命令类似，区别在于如果字段已经存在，<code>HSETNX</code> 命令将不执行任何操作。<code>HSETNX</code> 命令是原子操作。</p>
<ol start="4">
<li>增加数字</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HINCRBY key field increment</code></pre>
<p>与字符串类型命令<code>INCRBY</code>, <code>HINCRBY</code> 命令与之类似，可以是字段值增加指定的整数。散列类型没有 <code>HINCR</code> 命令，但是可以通过 <code>HINCRBY key field 1</code> 来实现。</p>
<pre class=" language-bash"><code class="language-bash">$ HINCRBY person score 60
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 60</code></pre>
<p>之前 person 键不存在， <code>HINCRBY</code> 命令会自动建立该键并默认 score 字段在执行命令前的值为 “0”。命令的返回值是增值后的字段值。</p>
<ol start="5">
<li>删除字段</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HDEL key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>HDEL</code> 命令可以删除一个或多个字段。返回值是被删除的字段个数。</p>
<pre class=" language-bash"><code class="language-bash">$ HDEL car price
<span class="token punctuation">(</span>integer 1<span class="token punctuation">)</span></code></pre>
<ol start="6">
<li>只获取字段名或字段值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HKEYS key
$ KVALS key</code></pre>
<ol start="7">
<li>获取字段数量</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ HLEN key</code></pre>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表类型（List）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。</p>
<p>列表类型的内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度是 O(1)，获取越接近两端的元素速度就越快。这种特性使列表类型能非常快速地完成关系数据库难以应付的场景：如社交网站的新鲜事，我们关心的只是最新的内容，使用列表类型存储，即使新鲜事的总数达到几千万个，获取其中最新的100条数据也是极快的。</p>
<p>与散列类型键最多能容纳的字段数量相同，一个列表类型键最多能容纳<code>2的32次方-1</code>个元素。</p>
<ol>
<li>向列表两端添加元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ RPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>LPUSH</code> 命令用来向列表左边增加元素，返回值表示增加元素后列表的长度。</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH numbers 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>这时 numbers 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15121611018139_.pic_hd.jpg"></p>
<p><code>LPUSH</code> 命令还支持同时增加多个元素：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH numbers 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre>
<p><code>LPUSH</code> 会先向列表左边加入 “2”，然后再加入 “3”，所以此时 numbers 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15131611018159_.pic_hd.jpg"></p>
<p>向列表右边增加元素的话则使用 <code>RPUSH</code> 命令，其用法和 <code>LPUSH</code> 命令一样：</p>
<pre class=" language-bash"><code class="language-bash">$ RPUSH numbers 0 -1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5</code></pre>
<p>此时 numbers 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15141611018309_.pic_hd.jpg"></p>
<ol start="2">
<li>从列表两端弹出元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LPOP key
$ RPOP key</code></pre>
<p><code>LPOP</code> 命令可以从列表左边弹出一个元素。 <code>LPOP</code> 命令执行两步操作：第一步是将列表左边的元素从列表中移除，第二步是返回被移除元素的值。</p>
<pre class=" language-bash"><code class="language-bash">$ LPOP numbers
<span class="token string">"3"</span>
$ RPOP numbers
<span class="token string">"-1"</span></code></pre>
<p>此时 number 键中的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/15171611018928_.pic_hd.jpg"></p>
<p>结合上面提到的 4 个命令可以使用列表类型来模拟栈和队列的操作：如果想把列表当成栈，则搭配使用 **<code>LPUSH</code> 和 <code>RPOP</code> **或 **<code>RPUSH</code> 和 <code>LPOP</code>**。</p>
<ol start="3">
<li>获取列表中元素的个数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">LLEN key</code></pre>
<p>当键不存在时 <code>LLEN</code> 会返回 0。</p>
<pre class=" language-bash"><code class="language-bash">$ LLEN numbers
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre>
<p><code>LLEN</code> 命令的功能类似 SQL 语句 <code>SELECT COUNT(*) FROM table_name</code>，但是 LLEN 的时间复杂度为 O(1)，使用时 Redis 会直接读取现成的值，而不像部分关系数据库（如使用 InnoDB 存储引擎的 MySQL 表）那样需要遍历一遍数据表来统计条目数量。</p>
<ol start="4">
<li>获得列表片段</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LRANGE key start stop</code></pre>
<p><code>LRANGE</code> 命令是列表类型最常用的命令之一，它能够获得列表中的某一片段。<code>LRANGE</code> 命令将返回索引从 start 到 top 之间的所有元素 （包含两端的元素）。Redis 的列表起始索引为 0：</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers 0 2
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span></code></pre>
<p><code>LRANGE</code> 命令也支持负索引，表示从右边开始计算序数，如 “-1” 表示最右边第一个元素，“-2” 表示最右边第二个元素，依次类推：</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers -2 -1</code></pre>
<p>显然，<code>LRANGE numbers 0 -1</code> 可以获取列表中的所有元素。另外一些特殊情况如下：</p>
<ul>
<li>如果 start 的索引位置比 stop 的索引位置靠后，则会返回空列表。</li>
<li>如果 stop 大于实际的索引范围，则会返回到列表最右边的元素。</li>
</ul>
<ol start="5">
<li>删除列表中指定的值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LREM key count value</code></pre>
<p><code>LREM</code> 命令会删除列表中前 count 个值为 value 的元素，返回值是实际删除的元素个数。根据 count 值的不同，<code>LREM</code> 命令的执行方式会略有差异。</p>
<ul>
<li><p>当 count &gt; 0 时，<code>LREM</code> 命令会从列表左边开始删除前 count 个值为 value 的元素。</p>
</li>
<li><p>当 count &lt; 0 时，<code>LREM</code> 命令会从列表右边开始删除前 count 个值为 value 的元素。</p>
</li>
<li><p>当 count = 0 时，<code>LREM</code> 命令会删除所有值为 value 的元素。</p>
</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ RPUSH numbers 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2,"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span>
4<span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token comment" spellcheck="true"># 从右边开始删除第一个值为 “2” 的元素</span>
$ LREM numbers -1 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span></code></pre>
<ol start="6">
<li>获得/设置指定索引的元素值</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LINDEX key index
$ LSET key index value</code></pre>
<p>如果要将列表类型当作数组来用，<code>LINDEX</code> 命令是必不可少的。<code>LINDEX</code> 命令用来返回指定索引的元素，索引从 0 开始。如：</p>
<pre class=" language-bash"><code class="language-bash">$ LINDEX numbers 2
<span class="token string">"0"</span></code></pre>
<p>如果 index 是负数则表示从右边开始计算的索引，最右边元素的索引是 -1。例如：</p>
<pre class=" language-bash"><code class="language-bash">$ LINDEX numbers -1
<span class="token string">"0"</span></code></pre>
<p><code>LSET</code> 是一个通过索引操作列表的命令，它会将索引为 index 的元素赋值为 value。如：</p>
<pre class=" language-bash"><code class="language-bash">$ LSET numbers 1 7
OK
$ LINDEX numbers 1
<span class="token string">"7"</span></code></pre>
<ol start="8">
<li>只保留列表指定片段</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LTRIM key start end</code></pre>
<p><code>LTRIM</code> 命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和 <code>LRANGE</code> 命令相同。就像这样:</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2,"</span>
2<span class="token punctuation">)</span> <span class="token string">"7"</span>
3<span class="token punctuation">)</span> <span class="token string">"0"</span>
$ LTRIM numbers 0 1
OK
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"7"</span></code></pre>
<p><code>LTRIM</code> 命令常和 <code>LPUSH</code> 命令一起使用来限制列表中元素的数量，比如记录日志时，我们希望只保留最近的 100 条日志，则每次接入新元素时调用一次 LTRIM 命令即可：</p>
<pre class=" language-bash"><code class="language-bash">$ LPUSH logs <span class="token variable">$newLOg</span>
$ LTRIM log 0 99</code></pre>
<ol start="9">
<li>向列表中插入元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ LINSET key BEFORE<span class="token operator">|</span>AFTER pivot value</code></pre>
<p><code>LINSERT</code> 命令首先会在列表中从左到右查找值为 pivot 的元素，然后根据第二个参数是 BEFORE 还是 AFTER 来决定将 value 插入到该元素的前面还是后面。</p>
<pre class=" language-bash"><code class="language-bash">$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"7"</span>
$ LINSERT numbers BEFORT 2 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ LRANGE numbers 0 -1
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"7"</span></code></pre>
<ol start="10">
<li>将元素从一个列表转到另一个列表</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ RPOPLPUSH <span class="token function">source</span> destination</code></pre>
<p><code>RPOPLPUSH</code> 是个很有意思的命令，从名字就可以看出它的功能：先执行 <code>RPOP</code> 命令再执行 <code>LPUSH</code> 命令。<code>RPOPLPUSH</code> 命令会先从 source 列表类型键的右边弹出一个元素，然后将其加入到 destination 列表类型键的左边，并返回这个元素的值，这个过程是原子的。</p>
<blockquote>
<p>当 source 和 destination 相同时， RPOPLPUSH 命令会不断地将对尾的元素移到队首。借助这个特性我们可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用 RPOPLPUSH 命令循环取出一个网址来测试可用性。这里使用 RPOPLPUSH 命令的好处在于程序执行过程中仍然可以不断地向网址列表中加入新网址，而且整个系统容易扩展，允许多个客户端同时处理队列。</p>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>一个集合类型（set）键可以存储至多 <code>2的31次方-1</code> 个字符串。集合类型和列表类型有相似之处，但很容易将它们区分开来：</p>
<table>
<thead>
<tr>
<th></th>
<th>集合类型</th>
<th>列表类型</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>至多 <code>2的31次方-1</code> 个字符串</td>
<td>至多 <code>2的31次方-1</code> 个字符串</td>
</tr>
<tr>
<td>有序性</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>唯一性</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在 Redis 内部是使用值为空的散列表（hash table） 实现的，所以这些操作的时间复杂度都是 O(1)。最方便的是多个集合类型键之间还可以进行并集、交集和差集运算。</p>
<ol>
<li>增加/删除元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>SADD</code> 命令用来向集合中增加一个或多个元素，如果键不存在则会自动创建。因为在一个集合中不能有相同的元素，所以如果要加入的元素已经存在与集合中就会忽略这个元素。本命令的返回值是成功加入的元素数量（忽略的元素不计算在内）。</p>
<pre class=" language-bash"><code class="language-bash">$ SADD letters a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ SASS letters a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p><code>SREM</code> 命令用来从集合中删除一个或多个元素，并返回删除成功的个数：</p>
<pre class=" language-bash"><code class="language-bash">$ SREM letters c d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<ol start="2">
<li>获得集合中的所有元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SMEMBERS key</code></pre>
<ol start="3">
<li>判断元素是否在集合中</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SISMEMBER key member</code></pre>
<p>当值存在时，<code>SISMEMBER</code> 命令返回 1，当值不存在或键不存在时返回 0。</p>
<pre class=" language-bash"><code class="language-bash">$ SISMEMBER letters a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<ol start="4">
<li>集合间运算</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SDIEF key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<ul>
<li><code>SDIFF</code> 命令用来对多个集合执行差集运算。代表所有属于A且不属于B的元素构成的集合。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ SADD setA 1 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ SADD setB 2 3 4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ SDIFF setA setB
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
$ SDIFF setB setA
1<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<p><code>SDIFF</code> 命令支持同时传入多个键：</p>
<pre class=" language-bash"><code class="language-bash">$ SADD setC 2 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ SDIFF setA setB setC
1<span class="token punctuation">)</span> <span class="token string">"1"</span></code></pre>
<p>计算顺序是先计算 <code>setA - setB</code> ，再计算与 <code>setC</code> 的差集。</p>
<ul>
<li><code>SINTER</code> 命令是用来对多个集合执行交集运算。 代表所有属于 A 且 属于 B 的元素构成的集合。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ SINTER setA setB
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p><code>SINTER</code> 命令同样支持同时传入多个键：</p>
<pre class=" language-bash"><code class="language-bash">$ SINTER setA setB setC
1<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<ul>
<li><code>SUNION</code> 命令用来对多个集合执行并集运算。代表所有属于 A 或 属于 B 的元素构成的集合。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ SUNION setA setB
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<p><code>SUNION</code> 命令同样支持同时传入多个键：</p>
<pre class=" language-bash"><code class="language-bash">$ SUNION setA setB setC
1<span class="token punctuation">)</span> <span class="token string">"1"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"3"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<ol start="5">
<li>获得集合中元素个数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SCARD key</code></pre>
<ol start="6">
<li>进行集合运算并将结果存储</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
$ SUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>SDIFFSTORE</code> 命令和 <code>SDIFF</code> 命令功能一样，唯一的区别就是前者不会直接返回运算结果，而是将结果存储在 destination 键中。</p>
<p><code>SDIFFSTORE</code> 命令通常用与需要进行多步集合运算的场景中，如需要先计算差集再将结果和其他键计算交集。</p>
<p><code>SINTERSTORE</code> 和 <code>SUNIONSTORE </code> 命令与之类似。</p>
<ol start="7">
<li>随机获得集合中的元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span></code></pre>
<p><code>SRANDMEMBER</code> 命令用来随机获取集合中的一个元素，还可以传递 count 参数来一次随机获得多个元素。根据 count 的正负不同，具体表现也不同。</p>
<ul>
<li>当 count 为整数时，<code>SRANDCOUNT</code> 会随机从集合里获得 count 个不重复元素。如果 count 的值大于集合中元素的个数，则 <code>SRANDCOUNT</code> 会返回集合中的全部元素。</li>
<li>当 count 为负数时，<code>SRANDCOUNT</code> 会随机从集合里获得 count 个元素，这些元素可能相同。</li>
</ul>
<ol start="8">
<li>从集合中弹出一个元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ SPOP key</code></pre>
<p>由于集合是无序的，所以 <code>SPOP</code> 命令会从集合中随机选择一个元素弹出。</p>
<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前 N 个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中的每个元素都是不同的，但是它们的分数却可以相同。</p>
<p>有序集合类型在某些方面和列表类型有些相似。</p>
<ul>
<li>二者都是有序的。</li>
<li>二者都可以获得某一范围的元素。</li>
</ul>
<p>但是二者有着很大的区别，这使得他们的应用场景也是不同的。</p>
<ul>
<li>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。</li>
<li>有序集合类型是使用散列表和跳表（Skip list）实现的，所以即使读取位于中间部分的数据，速度也很快。（时间复杂度是 O(log(N)) ）。</li>
<li>列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。</li>
<li>有序集合类型要比列表类型更耗费内存。</li>
</ul>
<ol>
<li>增加元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZADD key score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p><code>ZADD</code> 命令用来向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。<code>ZADD</code> 命令的返回值是新加入到集合中的元素的个数（不包含之前已经存在的元素）。</p>
<p>假设我们用有序集合模拟计分板，现在要记录 Tom、Peter 和 David 三名运动员的分数（分别是 89 分、67分 和 100 分）：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD scoreboard 89 Tom 67 Peter 100 David
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3</code></pre>
<p>这是我们发现 Peter 的分数录入有误，实际分数应该是 76 分，可以用 <code>ZADD</code> 命令修改 Peter 的分数：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD scoreboard 76 Peter
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>分数不仅可以是整数，还支持双精度浮点数：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD testboard 5E+3 a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ ZADD testboard 1.6 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ ZADD testboard +inf c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
$ ZADD testboard -inf d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<p>其中 <code>+inf</code> 和 <code>- inf</code> 分别表示正无穷和负无穷。</p>
<ol start="2">
<li>获得元素的分数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZSCORE key member</code></pre>
<ol start="3">
<li>获得排名在某个范围的元素列表</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>
$ ZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span></code></pre>
<p><code>ZRANGE</code> 命令会按照元素分数从小到大的顺序返回索引从 start 到 stop 之间的所有元素（包含两端的元素）。<code>ZRANGE</code> 命令与 <code>LRANGE</code> 命令十分相似，如果索引都是从 0 开始，负数代表从后向前查找（-1 表示最后一个元素）。</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGE scoreboard 0 2
1<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
2<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
3<span class="token punctuation">)</span> <span class="token string">"David"</span>
$ ZRANGE scoreboard 1 -1
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
2<span class="token punctuation">)</span> <span class="token string">"David"</span></code></pre>
<p>如果需要同时获得元素的分数的话，可以在 <code>ZRANGE</code> 命令尾部加上  <code>WITHSCORES</code> 参数：</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGE scoreboard 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
2<span class="token punctuation">)</span> <span class="token string">"76"</span>
3<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
4<span class="token punctuation">)</span> <span class="token string">"89"</span>
5<span class="token punctuation">)</span> <span class="token string">"David"</span>
6<span class="token punctuation">)</span> <span class="token string">"100"</span></code></pre>
<p><code>ZRANGE</code> 命令的时间复杂读为 O(log n+m)。其中 n 为有序集合的基数，m 为返回的元素个数。</p>
<p>如果两个元素的分数相同，Redis 会按照字典顺序（即 “0” &lt; “9” &lt; “A” &lt; “Z” &lt; “a” &lt; ‘“z” 这样的顺序）来进行排列。</p>
<p>如果元素的值是中文，则排序取决于中文的编码方式。如使用 UTF-8 编码：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD chineseName 0 亚洲 0 非洲 0 欧洲 0 南美洲
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
$ ZRANGE chineseName 0 -1
1<span class="token punctuation">)</span> <span class="token string">"\xe4\xba\x9a\xe6\xb4\xb2"</span>
2<span class="token punctuation">)</span> <span class="token string">"\xe5\x8d\x97\xe7\xbe\x8e\xe6\xb4\xb2"</span>
3<span class="token punctuation">)</span> <span class="token string">"\xe6\xac\xa7\xe6\xb4\xb2"</span>
4<span class="token punctuation">)</span> <span class="token string">"\xe9\x9d\x9e\xe6\xb4\xb2"</span></code></pre>
<p>可见此时 Redis 依然按照字典顺序排列这些元素。</p>
<p><code>ZREVRANGE</code> 命令和 <code>ZRANGE</code> 的唯一不同在于 <code>ZREVRANGE</code> 命令是按照元素分数从大到小的顺序给出结果的。</p>
<ol start="4">
<li>获得指定分数范围的元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span></code></pre>
<p>该命令按照元素分数从小到大的顺序返回分数在 min 和 max 之间（包含 min 和 max）的元素：</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE scoreboard 80 100
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
2<span class="token punctuation">)</span> <span class="token string">"David"</span></code></pre>
<p>如果希望的分数范围不包含端点值，可以在分数前加上<code>"("</code>符号。</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSOCRE socreboard 80 <span class="token punctuation">(</span>100
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span></code></pre>
<p>min 和 max 还支持无穷大，同 <code>ZADD</code> 命令一样，<code>-inf</code> 和 <code>+inf</code> 分别表示负无穷和正无穷。</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE scoreboard <span class="token punctuation">(</span>80 +inf
1<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
2<span class="token punctuation">)</span> <span class="token string">"David"</span></code></pre>
<p>WITHSCORES 参数的用户与 ZRANGE 命令一样。LIMIT offset count 与 SQL 中的用法基本相同。</p>
<p>为了便于演示，我们先向 scoreboard 键中再增加些元素：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD scoreboard 56 Jerry 92 Wendy 67 Yvonne
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
<span class="token comment" spellcheck="true"># 现在 scoreboard 键中的所有元素</span>
$ ZRANGE scoreboard 0 -1 WITHSCORES
 1<span class="token punctuation">)</span> <span class="token string">"Jerry"</span>
 2<span class="token punctuation">)</span> <span class="token string">"56"</span>
 3<span class="token punctuation">)</span> <span class="token string">"Yvonne"</span>
 4<span class="token punctuation">)</span> <span class="token string">"67"</span>
 5<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
 6<span class="token punctuation">)</span> <span class="token string">"76"</span>
 7<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
 8<span class="token punctuation">)</span> <span class="token string">"89"</span>
 9<span class="token punctuation">)</span> <span class="token string">"Wendy"</span>
10<span class="token punctuation">)</span> <span class="token string">"92"</span>
11<span class="token punctuation">)</span> <span class="token string">"David"</span>
12<span class="token punctuation">)</span> <span class="token string">"100"</span></code></pre>
<p>想获得分数高于 60 分的从第二个人开始的 3 个人：</p>
<pre class=" language-bash"><code class="language-bash">$ ZRANGEBYSCORE scoreboard 60 +inf Limit 1 3
1<span class="token punctuation">)</span> <span class="token string">"Peter"</span>
2<span class="token punctuation">)</span> <span class="token string">"Tom"</span>
3<span class="token punctuation">)</span> <span class="token string">"Wendy"</span></code></pre>
<ol start="5">
<li>增加某个元素的分数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">ZINCRBY key increment member</code></pre>
<p><code>ZINCRBY</code> 命令可以增加一个元素的分数，返回值是更改后的分数。</p>
<pre class=" language-bash"><code class="language-bash">$ ZINCRBY scoreboard 4 Jerry
<span class="token string">"60"</span></code></pre>
<p>increment 也可以是个负数表示减分：</p>
<pre class=" language-bash"><code class="language-bash">$ ZINCRBY scoreboard -4 Jerry
<span class="token string">"56"</span></code></pre>
<p>如果指定的元素不存在，Redis 再执行命令前会先建立它并将它的分数赋为 0 再执行操作。</p>
<ol start="6">
<li>获得集合中元素的数量</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZCARD key</code></pre>
<ol start="7">
<li>获得指定分数范围内的元素个数</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZCOUNT key min max</code></pre>
<ol start="8">
<li>删除一个或多个元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>
<p>ZREM 命令的返回值的成功删除的元素数量</p>
<pre class=" language-bash"><code class="language-bash">$ ZREM scoreboard Wendy
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<ol start="9">
<li>按照排名范围删除元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZREMRANGEBYRANK key start stop</code></pre>
<p>ZREMRANGEBYRANK 命令按照元素分数从小到大的顺序（即索引 0 表示最小的值），删除处在指定排名范围内的所有元素，并返回删除的元素数量。如：</p>
<pre class=" language-bash"><code class="language-bash">$ ZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
$ ZREMRANGEBYRANK testRem 0 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
$ ZRANGE testRem 0 -1
1<span class="token punctuation">)</span> <span class="token string">"d"</span>
2<span class="token punctuation">)</span> <span class="token string">"e"</span>
3<span class="token punctuation">)</span> <span class="token string">"f"</span></code></pre>
<ol start="10">
<li>按照分数范围删除元素</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZREMRANGEBYSCORE key min max</code></pre>
<p><code>ZREMRANGEBYSCORE</code> 命令会删除指定分数范围内的所有元素，返回值的删除的元素数量。</p>
<ol start="11">
<li>获得元素的排名</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZRANK key member
$ ZREVRANK key member</code></pre>
<p><code>ZRANK</code> 命令会按照元素分数从小到大的顺序获得指定元素的排名（从 0 开始，即分数最小的元素排名为 0）。</p>
<p><code>ZREVRANK</code> 命令则相反（分数最大的元素排名为 0 )。</p>
<ol start="12">
<li>计算有序集合的交集</li>
</ol>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>WEIGHTS weight <span class="token punctuation">[</span>weight <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AGGREGATE SUM<span class="token operator">|</span>MIN<span class="token operator">|</span>MAX<span class="token punctuation">]</span></code></pre>
<p><code>ZINTERSTORE</code> 命令用来计算多个有序集合的交集并将结果存储在 destination 键中（同样以有序类型集合存储），返回值为 destination 键中的元素个数。<code>numkeys</code>必须 等于参与集合的个数。</p>
<p>destination 键中元素的分数是由 <code>AGGREGATE</code> 参数决定的。</p>
<ul>
<li>当 <code>AGGREGATE</code> 是 <code>SUM</code> 时（也就是默认值），destination 键中元素的分数是每个参与计算的集合中改元素分数的和。例如：</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ ZADD sortedSets1 1 a 2 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZADD sortedSets2 10 a 20 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"11"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"22"</span></code></pre>
<ul>
<li>当 <code>AGGREGATE</code> 是 <code>MIN</code> 时，destination 键中元素的分数是每个参与计算的集合中该元素分数的最小值。例如：</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MIN
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$  ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"1"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"2"</span></code></pre>
<ul>
<li>当 <code>AGGREGATE</code> 是 <code>MAX</code> 是，destination 键中元素的分数是每个参与计算的集合中该元素分数的最大值。例如：</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MAX
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"10"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"20"</span></code></pre>
<p><code>ZINTERSTORE</code> 命令还能够通过 <code>WEIGHTS</code> 参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。例如：</p>
<pre class=" language-bash"><code class="language-bash">$ ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 WEIGHTS 1 0.1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
$ ZRANGE sortedSetsResult 0 -1 WITHSCORES
1<span class="token punctuation">)</span> <span class="token string">"a"</span>
2<span class="token punctuation">)</span> <span class="token string">"2"</span>
3<span class="token punctuation">)</span> <span class="token string">"b"</span>
4<span class="token punctuation">)</span> <span class="token string">"4"</span></code></pre>
<p>另外还有一个命令与 <code>ZINTERSTORE </code>命令的用法一样，名为 <code>ZUNIONSTORE</code>，它的作用是计算集合间的并集，这里不再赘述。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群</title>
    <url>/posts/119d.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>即使使用哨兵，此时的 Redis 集群的每个数据库依然存有集群中的所有数据，从而导致集群的总数据存储量受限于可用存储内存最小的数据库节点，形成木桶效应。由于 Redis 中的所有数据都是基于内存存储，这一问题尤为突出了，尤其是当使用 Redis 做持久化存储服务使用时。</p>
<p>对 Redis 进行水平扩容，在旧版 Redis 中通常使用客户端分片来解决这个问题，即启动多个 Redis 数据库节点，由客户端决定每个键交由哪个数据库节点存储，下次客户端读取改键时直接到该节点读取。这样可以实现将整个数据库分布存储在 N 个数据库节点中，每个节点只存放总数据量的 1/N。但对于需要扩容的场景来说，在客户端分片后，如果想增加更多的节点，就需要对数据进行手工迁移，同时在迁移的过程中为了保证数据的一致性，还需要将集群暂时下线，相对比较复杂。</p>
<p>考虑到 Redis 实例非常轻量的特点，可以采用预分片技术（<code>presharding</code>）来一定程度上避免此问题，具体来说是在节点部署初期，就提前考虑日后的存储规模，建立足够多的实例（如 128 个节点），初期时数据很少，所以每个节点存储的数据也非常少，但由于节点轻量的特性，数据之外的内存开销并不大，这使得只需要很少的服务器即可运行这些实例。日后存储规模扩大后，所要做的不过是将某些实例迁移到其它服务器上去，而不需要对所有数据进行重新分片并进行集权下线和数据迁移了。</p>
<p>无论如何，客户端分片终归是有非常多的缺点，比如维护成本高，增加、移除节点较繁琐等。Redis 3.0 版的一大特性就是支持集群（Cluster）功能。集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。另外集群支持几乎所有的单机实例支持的命令，对于涉及多键的命令（如 MGET），如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外集群还有一个限制是只能使用默认的 0 号数据库，如果执行 SELECT 切换数据库则会提示错误。</p>
<p>哨兵与集群是两个独立的功能，但从特性来看哨兵可以视为集群的子集，当不需要数据分片或者已经在客户端进行分片的场景下哨兵就足够使用了，但如果需要进行水平扩容，则集权是一个非常好的选择。</p>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p>使用集群，只需要将每个数据库节点的 <code>cluster-enabled</code> 配置选项打开即可。每个集群中至少需要三个主数据库才能正常运行。</p>
<p>为了演示集群的应用场景以及故障恢复等操作，这里以配置一个 3 主 3 从的集群系统为例。首先建立启动 6 个 Redis 实例，需要注意的是配置文件中应该打开 <code>cluster-enabled</code>。 一个示例配置为：</p>
<pre class=" language-shell"><code class="language-shell">port 6380
cluster-enabled yes</code></pre>
<p>其中 port 参数修改成实际的端口即可。这里假设 6 个实例的端口分别是 6380、6381、6382、6383、6384 和 6385。集群会将当前节点记录的集群状态持久化地存储在指定地文件中，这个文件默认为当前工作目录下的 <code>nodes.conf</code> 文件。每个节点对应的文件必须不同，否则会造成启动失败：</p>
<pre class=" language-bash"><code class="language-bash">Sorry, the cluster configuration <span class="token function">file</span> nodes.conf is already used by a different Redis Cluster node. Please <span class="token function">make</span> sure that different nodes use different cluster configuration files.</code></pre>
<p>所以启动节点时要注意最后为每个节点使用不同的工作目录，或者通过 <code>cluster-config-file</code> 选项修改持久化文件的名称：</p>
<pre class=" language-bash"><code class="language-bash">cluster-config-file nodes.conf</code></pre>
<p>每个节点启动后都会输出类似下面的内容：</p>
<pre class=" language-bash"><code class="language-bash">No cluster configuration found, I'm ef81cf4da7040c9d93bc85cfd358ed3886080fb4</code></pre>
<p>其中 <code>ef81cf4da7040c9d93bc85cfd358ed3886080fb4</code> 表示该节点的运行 ID，运行 ID 是节点在集群中的唯一标识；同一个运行 ID ，可能地址和端口是不同的。</p>
<p>启动后，可以使用 Redis 命令行客户端连接任意一个节点使用 INFO 命令来判断集群是否正常启用了：</p>
<pre class=" language-bash"><code class="language-bash">$ INFO cluster
<span class="token comment" spellcheck="true"># Cluster</span>
cluster_enabled:1</code></pre>
<p>其中 cluster_enabled 为 1 表示集群正常启用了。现在每个节点都是完全独立的，要将它们加入同一个集群里还需要几个步骤。</p>
<ul>
<li>初始化集群</li>
</ul>
<pre class=" language-bash"><code class="language-bash">$ redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385</code></pre>
<p>其中 <code>create</code> 参数表示要初始化集群， <code>--cluster-replicas 1</code> 表示每个主数据库拥有的从数据库个数为 1，所有整个集群共有3（6/2）个主数据库以及 3 个从数据库。</p>
<p>执行完后会输出如下内容：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385

<span class="token operator">>></span><span class="token operator">></span> Performing <span class="token function">hash</span> slots allocation on 6 nodes<span class="token punctuation">..</span>.
Master<span class="token punctuation">[</span>0<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 0 - 5460
Master<span class="token punctuation">[</span>1<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 5461 - 10922
Master<span class="token punctuation">[</span>2<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 10923 - 16383
Adding replica 127.0.0.1:6384 to 127.0.0.1:6380
Adding replica 127.0.0.1:6385 to 127.0.0.1:6381
Adding replica 127.0.0.1:6383 to 127.0.0.1:6382
<span class="token operator">>></span><span class="token operator">></span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity
<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same host as their master
M: 70448213e6665fcaea8ed94d7f77b31db0ef3a43 127.0.0.1:6380
   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master
M: ef81cf4da7040c9d93bc85cfd358ed3886080fb4 127.0.0.1:6381
   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> master
M: f4ae8d7e88aacb0bf60cf926f143474d7dc4950c 127.0.0.1:6382
   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master
S: 4ab18f8ac3f516f48922df4319154f3cd5361310 127.0.0.1:6383
   replicates 70448213e6665fcaea8ed94d7f77b31db0ef3a43
S: a1a19b41fb7736ac610a46c448ebd000cb4a342e 127.0.0.1:6384
   replicates ef81cf4da7040c9d93bc85cfd358ed3886080fb4
S: bddfa2c27943030592fe138cdc37697ff33d1f28 127.0.0.1:6385
   replicates f4ae8d7e88aacb0bf60cf926f143474d7dc4950c
Can I <span class="token keyword">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>:</code></pre>
<p>内容包括集群具体的分配方案，如果觉得没问题则输入 yes 来开始创建。首先客户端会尝试连接所有的节点，并发送 PING 命令以确定节点能够正常服务。如果有任何节点无法连接，则创建失败。同时发送 <code>INFO</code> 命令获取每个节点的运行 ID 以及开启了集群的功能（即 cluster_enabled 为 1）。</p>
<p>准备就绪后集群会向每个节点发送 <code>CLUSTER MEET</code> 命令，格式为：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER MEET ip port</code></pre>
<p>这个命令用来告诉当前节点指定 <code>ip</code> 和 <code>port</code> 上在运行的节点也是集群的一部分，从而使得 6 个节点最终可以归为一个集群。在分配主从数据库节点，分配的原则是尽量保证每个主数据库运行在不同的 IP 低智商，同时每个从数据库和主数据库均不运行在同一 IP 地址上，以保证系统的容灾能力。分配结果如下：</p>
<pre class=" language-bash"><code class="language-bash">Master<span class="token punctuation">[</span>0<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 0 - 5460
Master<span class="token punctuation">[</span>1<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 5461 - 10922
Master<span class="token punctuation">[</span>2<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 10923 - 16383
Adding replica 127.0.0.1:6384 to 127.0.0.1:6380
Adding replica 127.0.0.1:6385 to 127.0.0.1:6381
Adding replica 127.0.0.1:6383 to 127.0.0.1:6382</code></pre>
<p>其中主数据库是 6380、6381 和 6382 端口上的节点（以下使用端口号来指代节点），6384 是 6380 的从数据库，6385 是 6381 的从数据库，6383 是 6382 的从数据库。</p>
<p>分配完成后，会为每个主数据库分配插槽，分配插槽的过程其实就是分配哪些键归哪些节点负责。之后对每个要成为子数据库的节点发送 ：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER REPLICATE 主数据库的运行ID</code></pre>
<p>来将当前当前节点转换成从数据库并复制指定运行 ID 的节点（主数据库）。</p>
<p>此时整个集群的过程即创建完成，使用 Redis 命令行客户端连接任意一个节点执行 :</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER NODES</code></pre>
<p>可以获得集群中的所有节点信息：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER nodes
fc0bb101cb9fb83cc7387c5436cea4e31f37933a 127.0.0.1:6380@16380 myself,master - 0 1611279056000 1 connected 0-5460
4092663430bae1fc3b2cfc6a622e56e0bd6cdd42 127.0.0.1:6383@16383 slave 789ff268a004e79d27298b08ac14b6e7927ed8a7 0 1611279058000 3 connected
a1a19b41fb7736ac610a46c448ebd000cb4a342e 127.0.0.1:6384@16384 slave fc0bb101cb9fb83cc7387c5436cea4e31f37933a 0 1611279058000 1 connected
789ff268a004e79d27298b08ac14b6e7927ed8a7 127.0.0.1:6382@16382 master - 0 1611279059797 3 connected 10923-16383
bddfa2c27943030592fe138cdc37697ff33d1f28 127.0.0.1:6385@16385 slave ba332a22254bd3dbaa8c2900f97b882ee245cf77 0 1611279058000 2 connected
ba332a22254bd3dbaa8c2900f97b882ee245cf77 127.0.0.1:6381@16381 master - 0 1611279058786 2 connected 5461-10922</code></pre>
<p>从上面的输出中可以看到所有节点的运行 ID、地址和端口、角色、状态以及负载的插槽等信息。</p>
<h3 id="节点的增加"><a href="#节点的增加" class="headerlink" title="节点的增加"></a>节点的增加</h3><p>加入新节点非常简单，只需要向新节点（一下记作 A） 发送如下命令即可：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER MEET ip port</code></pre>
<p>IP 和 PORT 是集群中任意一个节点的地址和端口号，A 接收到客户端发来的命令后，会与 该地址和端口号 的节点 B 进行握手，使 B 将 A 认作当前集群中的一员。当 B 与 A 握手成功后，B 会使用 <code>Grossip</code> 协议将节点A的信息通知给集群中的每一个节点。通过这一方式，即使集群中有多个节点，也只需要选择 MEET 其中任意一个节点，即可使新节点最终加入整个集群中。</p>
<h3 id="插槽的分配"><a href="#插槽的分配" class="headerlink" title="插槽的分配"></a>插槽的分配</h3><p>新的节点加入集群中有两个选择，要么使用 <code>CLUSTER REPLICATE</code> 命令复制每个主数据库来以从数据库的形式运行，要么向集群申请分配插槽（slot） 来以主数据库的形式运行。</p>
<p>在一个集群中，所有的键会被分配成 16384 个插槽，而每个主数据库会负责处理其中的一部分插槽。现在再回头来看创建集群时的输出：</p>
<pre class=" language-bash"><code class="language-bash">fc0bb101cb9fb83cc7387c5436cea4e31f37933a 127.0.0.1:6380@16380 myself,master - 0 1611279056000 1 connected 0-5460
789ff268a004e79d27298b08ac14b6e7927ed8a7 127.0.0.1:6382@16382 master - 0 1611279059797 3 connected 10923-16383
ba332a22254bd3dbaa8c2900f97b882ee245cf77 127.0.0.1:6381@16381 master - 0 1611279058786 2 connected 5461-10922</code></pre>
<p>上面的每一行表示一个主数据库的信息，其中可以看到 6380 负责处理 0<del>5460 这 5461 个插槽，6381 负责处理 5461 ~ 10922 这 5462 个插槽，6382 则负责处理 10923</del>16383 这 5461 个插槽。虽然初始化集群时分配给每个节点的插槽都是连续的，但是实际上 Redis 并没有此限制，可以将任意的几个插槽分配给任意的节点负责。</p>
<p>在介绍如何将插槽分配给指定的节点前，先来介绍键与插槽的对应关系。Redis 将每个键的键名的有效部分使用 CRC16 算法计算出散列值，然后去对 16384 的余数。这样使得每个键都可以分配到 16384 个插槽中，进而分配给执行的一个节点中处理。 这里键名的有效部分是指：</p>
<ul>
<li>如果键名包含 { 符号，且在符号的后面存在 } 符号，并且 { 和 } 之间有至少一个字符，则有效部分是指 { 和 } 之间的内容；</li>
<li>如果不满足上一条规则，那么整个键名为有效部分。</li>
</ul>
<p>例如，键 <code>hello.world</code> 的有效部分为 <code>“hello.world”</code>，键 <code>{user102}:last.name</code> 的有效部分为 <code>user102</code>。如果命令设计多个键（如 MGET），只有当所有键都位于同一个节点时 Redis 才能正常支持。利用键的分配规则，可以将所有相关键的有效部分设置成同样的值使得相关键都能分配到同一个节点以支持多键操作。比如，<code>{user102}:first.name</code> 和 <code>{user102}:last:name</code> 会被分配到同一个节点，所以可以使用：</p>
<pre class=" language-bash"><code class="language-bash">$ MGET <span class="token punctuation">{</span>user102<span class="token punctuation">}</span>:first.name <span class="token punctuation">{</span>user102<span class="token punctuation">}</span>:last.name </code></pre>
<p>来同时获取这两个键的值。</p>
<p>介绍完键与插槽的对应关系后，接下来再来介绍如何将插槽分配给执行节点。插槽的分配分为如下情况：</p>
<ul>
<li>插槽之前没有被分配过，现在向分配给指定节点。</li>
<li>插槽之前被分配过，现在想移动到指定节点。</li>
</ul>
<p>其中第一种情况使用 <code>CLUSTER ADDSLOTS</code> 来实现。 <code>CLUSTER ADDSLOTS</code> 命令的用法为：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER ADDSLOTS slot1 <span class="token punctuation">[</span>slot2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. <span class="token punctuation">[</span>slotN<span class="token punctuation">]</span></code></pre>
<p>如想将 100 和 101 两个插槽分配给某个节点，只需要在该节点执行：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER ADDSLOTS 100 101</code></pre>
<p>如果执行插槽已经分配过了，则会提示：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR Slot 100 is already busy</code></pre>
<p>可以通过命令 <code>CLUSTER SLOTS</code> 来查看插槽的分配情况，如：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER SLOTS
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5460
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6380
      3<span class="token punctuation">)</span> <span class="token string">"fc0bb101cb9fb83cc7387c5436cea4e31f37933a"</span>
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6384
      3<span class="token punctuation">)</span> <span class="token string">"a1a19b41fb7736ac610a46c448ebd000cb4a342e"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10923
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 16383
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6382
      3<span class="token punctuation">)</span> <span class="token string">"789ff268a004e79d27298b08ac14b6e7927ed8a7"</span>
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6383
      3<span class="token punctuation">)</span> <span class="token string">"4092663430bae1fc3b2cfc6a622e56e0bd6cdd42"</span>
3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5461
   2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10922
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6381
      3<span class="token punctuation">)</span> <span class="token string">"ba332a22254bd3dbaa8c2900f97b882ee245cf77"</span>
   4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6385
      3<span class="token punctuation">)</span> <span class="token string">"bddfa2c27943030592fe138cdc37697ff33d1f28"</span></code></pre>
<p>其中返回结果的格式很容易理解，一共 3 条记录，每条记录的前两个值表示插槽的开始号码和结束号码，后面的值则为负责该插槽的节点，包括主数据库和所有的从数据库，主数据库始终在第一位。</p>
<p>对于情况2，处理起来相对复杂一些，我们首先将一个插槽从 6380 迁移到 6381，执行如下命令：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER SETSLOT 插槽号 NODE 新节点运行的ID</code></pre>
<p>如想要把 0 号插槽迁移到 6381：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ba332a22254bd3dbaa8c2900f97b882ee245cf77 是 6381 的运行 id</span>
redis 6380<span class="token operator">></span> CLUSTER SETSLOT 0 NODE ba332a22254bd3dbaa8c2900f97b882ee245cf77
OK</code></pre>
<p>此时重新使用 <code>CLUSTER SLOTS</code> 查看插槽的分配情况：</p>
<pre class=" language-bash"><code class="language-bash">fc0bb101cb9fb83cc7387c5436cea4e31f37933a 127.0.0.1:6380@16380 myself,master - 0 1611283004000 1 connected 1-5460

ba332a22254bd3dbaa8c2900f97b882ee245cf77 127.0.0.1:6381@16381 master - 0 1611283005000 2 connected 0 5461-10922</code></pre>
<p>然而这样迁移插槽的前提是插槽中并没有任何键，因为使用 <code>CLUSTER SETSLOT</code> 命令迁移插槽时并不会连同相应的键一起迁移，这就造成了客户端在指定节点无法找到未迁移的键，造成这些键对客户端来说“丢失了”，为此需要手工获取插槽中存在哪些键，然后将每个键迁移到新的节点中才能运行。</p>
<p>手工获取某个插槽中存在哪些键的方法时：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER GETKEYSINSLOT 插槽号 要返回的键的数量</code></pre>
<p>之后对每个键，使用 MIGRATE 命令将其迁移到目标节点：</p>
<pre class=" language-bash"><code class="language-bash">$ MIGRATE 目标节点地址 目标节点端口 键名 数据库号码 超时时间 <span class="token punctuation">[</span>COPY<span class="token punctuation">]</span> <span class="token punctuation">[</span>REPLACE<span class="token punctuation">]</span></code></pre>
<p>其中 <code>COPY</code> 选项表示不将键从当前数据库中删除，而是复制一份副本。<code>REPLACE</code> 表示如果目标节点存在同名键，则覆盖。因为集群模式只能使用 0 号数据库，所以数据库号码始终为 0。如要把键 <code>abc</code> 从当前节点（如 6381）迁移到 6380：</p>
<pre class=" language-bash"><code class="language-bash">redis 6381<span class="token operator">></span> MIGRATE 127.0.0.1 6380 abc 0 16000 REPLACE</code></pre>
<p>至此，我们已经知道如果将插槽委派给其它节点，并同时将当前节点中插槽下所有的键迁移到目标节点中。然而还有最后一个问题是如果要迁移的数据量比较大，整个过程会发费较长时间，那么究竟什么时候执行 <code>CLUSTER SETSLOT</code> 命令来完成插槽的交接呢？如果在键迁移未完成时执行，那么客户端就会尝试在新的节点读取键值，此时还没有迁移完成，自然有可能读不到键值，从而造成相关键的“临时丢失”。相反，如果在键迁移完成后再执行，那么在迁移时客户端会在旧的节点读取键值，然后有些键已经迁移到新的节点上了，同时也会造成键的临时“丢失”。Redis 提供了如下两个命令用来实现再集群不下线的情况下迁移数据：</p>
<pre class=" language-bash"><code class="language-bash">$ CLUSTER SETSLOT 插槽号 MIGRATING 新节点的运行ID
$ CLUSTER SETSLOT 插槽号 IMPORTING 原节点的运行ID</code></pre>
<p>进行迁移时，假设要把 0 号插槽从 A 迁移到 B，此时会执行如下操作：</p>
<ol>
<li>在 B 执行 <code>CLUSTER SETSLOT 0 IMPORTING A 。</code></li>
<li>在 A 执行 CLUSTER SETSLOT 0 MIGRATING B。</li>
<li>执行 <code>CLUSTER GETKEYSINSLOT 0</code> 获取 0 号插槽的键列表。</li>
<li>对第 3 步获取的每个键执行 MIGRATE  命令，将其从 A 迁移到 B。</li>
<li>执行 <code>CLUSTER SETSLOT 0 NODE B</code> 来完成迁移。</li>
</ol>
<p>上面的 1 和 2 步骤就是为了解决迁移过程中键的临时 “丢失” 问题。首先执行完前两步后，当客户端 A 请求插槽 0 中的键时，如果键存在（即尚未被迁移），则正常处理，如果不存在，则返回一个 ASK 跳转请求，告诉客户端这个键在 B 里，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/16251611285456_.pic_hd.jpg"></p>
<p>客户端收到 ASK 跳转请求后，首先向 B 发送 ASKING 命令，然后再重新发送之前的命令。相反，当客户端向 B 请求插槽 0 中的键时，如果前面执行了 ASKING 命令，则返回键值内容，否则返回 MOVE 跳转请求。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AsiaMa/AsiaMa-imgs/images/16241611285104_.pic_hd.jpg"></p>
<p>这样一来客户端只有能够处理 ASK 跳转，则可以在数据库迁移时自动从正确的节点获取到相应的键值，避免了键在迁移过程中临时 “丢失” 的问题。</p>
<h3 id="获取与插槽对应的节点"><a href="#获取与插槽对应的节点" class="headerlink" title="获取与插槽对应的节点"></a>获取与插槽对应的节点</h3><p>介绍了插槽的分配方式，对于指定的键，可以根据前面所说的算法来计算其属于哪个插槽，但是如何获取某一个键由哪个节点负责呢？</p>
<p>实际上，当客户端向集群中的任意一个节点发送命令后，该节点会判断相应的键是否在当前节点中，如果键在该节点中，就会像单机实例一样正确处理该命令：如果键不在该节点中，就会返回一个 MOVE 重定向请求，告诉客户端这个键目前由哪个节点负责，然后客户端再将同样的请求向目标节点重新发送一次以获得结果。</p>
<p>一些语言的 Redis 库支持代理 MOVE 请求，所以对于开发者而言命令重定向的过程是透明的，使用集权与使用单机实例并没有什么不同。然而也有些语言的 Redis 库并不支持集群，这时就需要在客户端编码处理了。</p>
<p>还是以上面的集群配置为例，键 foo 实际应该由 6382 节点负责，如果尝试在 6380 节点执行与键 foo 相关的命令，就会有如下输出：</p>
<pre class=" language-bash"><code class="language-bash">redis 6380<span class="token operator">></span> <span class="token keyword">set</span> foo bar
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> MOVED 12182 127.0.0.1:6382</code></pre>
<p>返回的是一个 MOVE 重定向请求，12182 表示 foo 所属的插槽号，127.0.0.1:6382 则是负责该插槽的节点地址和端口，客户端收到重定向请求后，应该将命令重新向 6382 节点发送一次：</p>
<pre class=" language-bash"><code class="language-bash">redis 6382<span class="token operator">></span> <span class="token keyword">set</span> foo bar
OK</code></pre>
<p>Redis 命令行客户端提供了集群模式来支持自动重定向，使用 -c 参数来启用：</p>
<pre class=" language-bash"><code class="language-bash">$ redis-cli -c -p 6380

redis 6380<span class="token operator">></span> <span class="token keyword">set</span> foo bar
-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>12182<span class="token punctuation">]</span> located at 127.0.0.1:6382
OK</code></pre>
<p>可见加入了 -c 参数后，如果当前节点并不负责要处理的键，Redis 命令行客户端会进行自动命令重定向。而这一过程正是负责集群的客户端应该实现的。</p>
<p>然而相比单机实例，集群的命令重定向也增加了命令的请求次数，原先只需要执行一次的命令，现在有可能一次发向两个节点，算上往返时延，可以说请求重定向对性能还是有些影响的。</p>
<p>为了解决这一问题，当发现新的重定向请求时，客户端应该在重新向正确节点发送命令的同时，缓存插槽的路由信息，即记录下当前插槽是由哪个节点负责的。这样每次发起命令时，客户端首先计算相关键是属于哪个插槽的，然后根据缓存的路由判断插槽由哪个节点负责。考虑到插槽总数相对较少（16384个），缓存所有插槽的路由信息后，每次命令将均只发向正确的节点，从而达到和单机实例同样的性能。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>在一个集群中，每个节点都会定期向其它节点发送 PING 命令，并通过有没有收到回复来判断目标节点是否已经下线了。具体来说，集群中的每个节点每个 1 秒就会随机选择 5 个节点，然后选择其中最久没有相应的节点发送 PING 命令。</p>
<p>如果一定时间内目标节点没有相应回复，则发起 PING 命令的节点会认为目标节点疑似下线（PFALL）。疑似下线可以与哨兵的主观下线类比，两者都表示某一节点从<strong>自身的角度认为</strong>目标节点是下线的状态。与哨兵的模式类似，如果要使在整个集群中的所有节点都认为某一节点已经下线，需要一定数量的节点都认为该节点疑似下线才可以，这一过程具体为：</p>
<ul>
<li>一旦节点 A 认为节点 B 是疑似下线状态，就会在集群中传播该消息，所有其它节点收到消息后都会记录下这一信息；</li>
<li>当集群中的某一节点 C 收集到半数以上的节点认为 B 是疑似下线的状态时，就会将 B 标记为下线（FALL），并且向集群中的其它节点传播该消息，从而使得 B 在整个集群中下线。</li>
</ul>
<p>在集群中，当一个主数据库下线时，就会出现一部分插槽无法写入的问题。这时如果该主数据库拥有至少一个从数据库，集群就进行故障恢复操作来将其中一个从数据库转变成主数据库来保证集群的完成。选择哪个从数据库来作为主数据库的过程与在哨兵中选择领头哨兵的过程一样，都是基于Raft 算法，过程如下：</p>
<ol>
<li>发现其复制的主数据库下线的从数据库库（下面称作 A）向每个集群中的节点发送请求，要求对方选自己成为主数据库。</li>
<li>如果请求的节点没有选过其他人，则会同意 A 设置成主数据库。</li>
<li>如果 A 发现有超过集群中节点总数一半的节点同意选自己成为主数据库，则 A 成功成为主数据库。</li>
<li>当有多个从数据库节点同时参选主数据库，则会出现没有任何节点当选的可能。此时每个参选点将等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。</li>
</ol>
<p>当某个从数据库当选为主数据库后，会通过命令 <code>SLAVEOF NO ONE</code> 将自己转换成主数据库，并将旧的数据库插槽转换给自己负责。</p>
<p>如果至少负责一个插槽的主数据库下线且没有相应的从数据库可以进行故障恢复，则整个集群默认会进入下线状态无法继续工作。如果想在这种情况下使集群仍能正常工作，可以修改配置：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 默认为 yes</span>
cluster-require-full-coverge no</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
